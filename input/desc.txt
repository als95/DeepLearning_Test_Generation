BETA_JAVA8:  This bug is to record & track a clarification request to the 335 EG:  // ---- 8< -------  The following lambda expression does not compile with 8b74, while the  implementation of the method in a class does compile:   // ------------  interface G1 {    <E extends Exception> Object m(E p) throws E;  }  interface G2 {    <F extends Exception> String m(F q) throws Exception;  }  interface G extends G1, G2 {}   // G has descriptor <F extends Exception> ()->String throws F   public class X {                   G g = (x) -> { // Elided type is inferred from descriptor to be F              throw x;    // ~== throw new F()          };  }   class Y implements G {          public <T extends Exception> String m(T t) throws T {                  throw t;          }  }  // -----------------------   Is this a bug in the implementation or the specification ?  Since the lambda cannot refer to the type variables of the  descriptor by name nor declare its own, if 8b74 behavior is  correct, that would mean that, no checked exceptions could  be thrown from a lambda if the descriptor of the target  interface method mentions a type variable in throws clause.   My analysis is that the lambda should be accepted as it does  not manufacture any fresh exceptions and simply throws an  exception that is known to have satisfied the constraints at  the invocation site, i.e no additional/unexpected surprises  are there due the lambda throwing the object it was handed.
+++ This bug was initially created as a clone of Bug #247845 +++  While it is good that JDT Core does not log those exceptions, it should pass them back to the client.  Currently, we can't show the user that the attached Javadoc could not be accessed.   T
4.3 M5a.  Currently JDT Core ignores some exceptions and returns 'null'. This violates the API/Javadoc. Bug 400060 tracks that part. Once this is fixed we need to adjust our code to handle those exceptions and show them to the user without logging them.
"this is the exception:  !ENTRY org.eclipse.ui 4 0 2013-02-08 23:36:40.932 !MESSAGE Unhandled event loop exception !STACK 0 org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.prepareDelayedProjection(JavaSourceViewer.java:658) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2582) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2571) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395) 	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4289) 	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4311) 	at org.eclipse.ui.internal.WorkbenchPage.reuseEditor(WorkbenchPage.java:2885) 	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3023) 	at org.eclipse.ui.internal.WorkbenchPage.access$22(WorkbenchPage.java:2969) 	at org.eclipse.ui.internal.WorkbenchPage$8.run(WorkbenchPage.java:2951) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2947) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2911) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2902) 	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:373) 	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:179) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.gotoSelectedElement(AbstractInformationControl.java:440) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.access$0(AbstractInformationControl.java:435) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$2.widgetDefaultSelected(AbstractInformationControl.java:227) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:119) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4169) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3758) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)   I already had that also in my 3.8.x version, but now i am on the 4.3 stream:  Version: 4.3.0 Build id: I20130205-0800  i i still have this. For that workspace i really need to say that it shouldn't close editors automatically for a specific number (16) now.  If this happens, i really have first to close 1 and then i can reopen on."
We're using Google Guice (com.google.inject) dependency injection, which means that a field annotated with @Inject cannot be null unless it is explicitly annotated as @Inject(optional=true). Since Kepler M5, JDT's null pointer analysis for fields reports errors on almost all fields now.
We have to document removal of 'org.junit4' and 'org.junit' 3.8.2 in the migration guide.
"BETA_JAVA8:  The following program compiles silently with HEAD:  // ---- X.java import p.I;  public class X { 	I i = (p) -> { return null; }; } // ---- I.java package p; public interface I { 	ReturnType doit(ParameterType p) throws ExceptionType; }  class ReturnType { }  class ParameterType { }  class ExceptionType extends Exception { } // ----------------------  It should report three errors, one each about ReturnType, ParameterType and Exception type as they are not visible at the lambda definition site.  Interestingly javac 8b74 complains:  X.java:6: error: ParameterType is not public in p; cannot be accessed from outsi de package X.java:4: error: ParameterType is not public in p; cannot be accessed from outsi de package         I i = (p) -> { return null; };               ^ 2 errors  // ----  Here is the relevant wording:   For each checked exception that can result from execution of the body of the lambda expression, a compile-time error occurs unless that exception type or a supertype of that exception type is mentioned in the throws clause of the descriptor of T'.   It is a compile-time error if any class or interface mentioned by either T' or the descriptor of T' is not accessible from the class in which the lambda expression appears."
Bug 391894 added support for type annotations Array creation nodes. This bug will be used to add the rewrite support for array creation with type annotations.
Created attachment 226944 [details] JDT branding plugin  Make the branding plugin qualifiers consistent with the buildId  PW
This appears to be a regression in Kepler M5. When debugging an Eclipse Application, codeassist does not work in Display view. This worked in Kepler M4.  Not sure if this makes any difference, I am on OSX 10.8.2 with Oracle Java 1.7.0_10.
For the entire Type Hieararchy (AnnotatableType) and Type Parameter hierarchy - ASTRewrite implementation [to be done in cases missing or corrected in cases existing if need be].  This is the ASTRewrite Equivalent of bug 391890.
"In a project with nullity annotations present I have a lot of warnings like:  Null type safety: the expression of type AppSession needs unchecked conversion to conform to '@Nonnull AppSession'.  On the warning message, click ""quick fix"" and select ""Change parameter type to @Nonnull"", select a single file, then press finish. Eclipse comes with a popup stating ""an exception occured while applying the quick fix"", and the message in the title of this bug report.  Selecting multiple files to fix dies without any kind of message, and no files are changed.  The log shows (dont't be scared, huge stack trace): !ENTRY org.eclipse.jdt.ui 4 10001 2013-02-13 11:41:55.559 !MESSAGE Internal Error !STACK 1 Java Model Exception: Core Exception [code 0] The fix 'Add Annotations' generated a null change. 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:50) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5332) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal$1.run(FixCorrectionProposal.java:218) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.resolve(FixCorrectionProposal.java:225) 	at org.eclipse.jdt.internal.ui.text.correction.CorrectionMarkerResolutionGenerator$CorrectionMarkerResolution.run(CorrectionMarkerResolutionGenerator.java:145) 	at org.eclipse.ui.internal.views.markers.QuickFixPage$11.run(QuickFixPage.java:565) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixPage.performFinish(QuickFixPage.java:554) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard$1.run(QuickFixWizard.java:97) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard.performFinish(QuickFixWizard.java:106) 	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:827) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:432) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3705) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3326) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.internal.views.markers.QuickFixHandler.execute(QuickFixHandler.java:165) 	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:76) 	at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:231) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:212) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:277) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:496) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:547) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:368) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:314) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:83) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1552) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1391) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1416) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1401) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1428) 	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:829) 	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3180) 	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:758) 	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2092) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5334) 	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:3566) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4532) 	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method) 	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:8549) 	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1241) 	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method) 	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2281) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3324) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: org.eclipse.core.runtime.CoreException: The fix 'Add Annotations' generated a null change. 	at org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFix.createChange(CompilationUnitRewriteOperationsFix.java:106) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:810) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80) 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5332) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal$1.run(FixCorrectionProposal.java:218) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.resolve(FixCorrectionProposal.java:225) 	at org.eclipse.jdt.internal.ui.text.correction.CorrectionMarkerResolutionGenerator$CorrectionMarkerResolution.run(CorrectionMarkerResolutionGenerator.java:145) 	at org.eclipse.ui.internal.views.markers.QuickFixPage$11.run(QuickFixPage.java:565) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixPage.performFinish(QuickFixPage.java:554) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard$1.run(QuickFixWizard.java:97) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard.performFinish(QuickFixWizard.java:106) 	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:827) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:432) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3705) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3326) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.internal.views.markers.QuickFixHandler.execute(QuickFixHandler.java:165) 	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:76) 	at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:231) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:212) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:277) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:496) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:547) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:368) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:314) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:83) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1552) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1391) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1416) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1401) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1428) 	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:829) 	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3180) 	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:758) 	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2092) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5334) 	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:3566) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4532) 	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method) 	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:8549) 	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1241) 	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method) 	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2281) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3324) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) !SUBENTRY 1 org.eclipse.jdt.ui 4 0 2013-02-13 11:41:55.561 !MESSAGE The fix 'Add Annotations' generated a null change."
"Created attachment 226996 [details] formatter settings to reproduce  Hi,  Version: Juno Service Release 1 Build id: 20121004-1855  I noticed that the Save Action 'correct indentation' conflicts with the formatter 'line wrapping'. I attached my formatter configuration as reference.  The issue can be seen when using arguments with enums. The formatter uses indentation so that all types are indented on the same column, as well as the arguments for the enums and arguments to those arguments (think arrays).  Desired result (which the formatter does correctly): <pre> public enum TestEnum {  	FIRST_ENUM(""first type"", 	           new SomeClass(), 	           new OtherEnumType[] { OtherEnumType.FOO}),  	SECOND_ENUM(""second type"", 	            new SomeClassOtherClass(), 	            new OtherEnumType[] { OtherEnumType.BAR}),  	THIRD_ENUM(""third type"", 	           new SomeThirdClass(), 	           new OtherEnumType[] { OtherEnumType.BAZ}),  	FOURTH_ENUM(""fourth type"", 	            new YetAnotherClass(), 	            new OtherEnumType[] { OtherEnumType.FOOBAR, 	                                  OtherEnumType.FOO, 	                                  OtherEnumType.FOOBARBAZ, 	                                  OtherEnumType.LONGERFOOBARBAZ, 	                                  OtherEnumType.REALLYLONGFOOBARBAZ, 	                                  OtherEnumType.MORELETTERSINHERE});  /* data members and methods go here */  } </pre>  However when using the save action 'correct indentation', the 'SECOND_ENUM' start on the column of the arguments for 'FIRST_ENUM', the 'THIRD_ENUM' start on the column for arguments to the second one, and so on. This creates the dreaded staircase effect."
"The following code generates wrong code:  interface I {     public void foo() default {         System.out.println(""default"");     } } public class C implements I {     public static void main(String[] args) {         C c = new C();         c.foo();     } }  At runtime this produces: Exception in thread ""main"" java.lang.NoSuchMethodError: java.lang.Object.foo()V 	at C.foo(C.java:1) 	at C.main(C.java:9)  The reason is in the way a synthetic method (SuperMethodAccess) for foo is generated: it is assumed that the super method must be in accessMethod.declaringClass.superclass(), which leads to trying to invoke java.lang.Object.foo(), which obviously doesn't exist."
"BETA_JAVA8:  Amends to JLS7 read:  ""It is a compile-time error if the name of a local class C is used to declare a new local class within the scope of C, unless the new local class is declared in the body of C or within another class whose declaration is within the scope of C.""  So the following program should be rejected, but is not.  // -------- interface I { 	void foo(); }  public class X { 	void foo() { 		class Y {}; 		I i = ()  -> { 			class Y {}; 		}; 	}	 }   // ---  javac complains:   X.java:9: error: class Y is already defined in method foo()                         class Y {};                         ^ 1 error"
"M5: The following 	 	boolean badFunction(int i) { 		return i > 0 ? true : null; 	}  gives no diagnostic. Whereas  	 	boolean badFunction(int i) { 		return null; 	}  gives a cannot convert null to boolean."
Created attachment 227060 [details] Project to reproduce the bug  OVERVIEW Selecting code fragments or using "Open Declaration" on a selected part of code causes an endless loop in AbstractCommentParser:177 and eclipse generates 100% cpu  load on one core. If main thread gets in the loop eclipse is not responding and can only be terminated by task manager with losing all unsaved code.  REPRODUCTION Import the attached project in a clean workspace. Open the class "Bug" and scroll to the "TODO" task tag. Double click on "componentShown" in the next line and press F3.  RESULT Eclipse is hanging in an endless lopp with 100% cpu load on one core.  EXPECTED Eclipse should jump to the marked method.  ADDITIONAL INFORMATION The problem is caused by the JavadocParse. The parser tries to parse the package-info.java of a referenced package. After that the actual source is parsed, but the scanner used by the parser has still the source of the package-info.java. This leads to parsing the same source range over and over again.  WORKAROUND Disable javadoc comment processing in compiler options.  POSSIBLE FIX Initialising the source of the Scanner in org.eclipse.jdt.internal.compiler.parser.JavadocParser:94  CURRENT CODE public boolean checkDeprecation(int commentPtr) {   [...]   // Parse   try {     this.source = this.sourceParser.scanner.source;     [...]   } finally {     this.source = null; // release source as soon as finished   }   return this.deprecated; }  CODE FIXING THE PROBLEM public boolean checkDeprecation(int commentPtr) {   [...]   // Parse   try {     this.source = this.sourceParser.scanner.source;     this.scanner.setSource(this.source); //updating source in scanner     [...]   } finally {     this.source = null; // release source as soon as finished     this.scanner.setSource((char[]) null); //release source in scanner   }   return this.deprecated; }
Update the code formatter for Java 8 constructs. Currently, the formatter just gives up if it e.g. sees an annotation on an array type or vararg.  ASTRewrite needs a working code formatter to work correctly. ASTRewriteFormatter formats snippets to find the current formatter settings, and it runs the code formatter for new nodes.
BETA_JAVA8:  A number of changes are being made to overload resolution mechanism to accommodate poly expressions in method invocation context.  ECJ needs to evolve to address this scenario, which creates some interesting problems: When a lambda expression occurs in method invocation context as an argument, the type of the lambda expression cannot be determined until the overloaded method is chosen and the overloaded method cannot be chosen until the lambda expression's type is known.  JLS8 15.12.2 (part F of JSR335 specification) spells out the amended  overload resolution rules to address this and other scenarios.
BETA_JAVA8:  A number of changes are being made to type inference mechanism to fix specification bugs, clarify issues, to address poly expressions etc.  These are captured in section 18 of JLS8 - part G of JSR335 specification. ECJ should evolve to cope with these changes.
This will be the master bug for this project.
0.6.1 9.8 is silent about descriptor computation in the presence of raw types. Is this specified somewhere else ? Discouraged though this scenario may be,  we can expect to run into this sooner or later, intentionally coded or otherwise.  The reference compiler at 8b74 seems to erase the descriptor as seen by the following program: This seems reasonable from one pov. From another, this is somewhat at odds with the ban on lambdas implementing generic methods in that, in both cases we have (or are likely to have) unadaptable type variable usage in various constituents of the descriptor. And the target type is raw in one case and the lambda is "raw" in the other case (by virtue of there being no grammar support for type parameter encoding)  I am happy erasing the descriptor, but (a) should this stay unspecified if it indeed is and (b) does the inconsistency in treatment with generic lambdas OK ?  // --- import java.util.List; interface I<T> {     void foo(List<T> f); }  class Y {     void goo(I<String> f) {     } }  class Z {     void zoo(I f) {     } } public class X {     public static void main(String [] args) {        new Y().goo((List<String> ls) -> {});  // Compiles OK with 8b74        new Z().zoo((List ls) -> {});          // OK     } }  --------------------  To see the correlation between generic lambdas and raw types in target type study this program in which 8b74 is inadvertently allowing a generic lambda since it does not see the descriptor as being generic due to erasure:  // ----- import java.util.List; interface I<T> {     <P> P foo(List<T> f); }  class Y {     void goo(I<String> f) {     } }  class Z {     void zoo(I f) {     } } public class X {     public static void main(String [] args) {       new Y().goo((List<String> ls) -> { return null; }); // Fails: descriptor is generic        new Z().zoo((List ls) -> { return null; }); // compiles fine, we are overriding a generic method with another that has no type variables!!     } }
BETA_JAVA8:  This ER will be used as the master/umbrella entry for search engine changes to support Java 8. Please don't attach patches/fixes here. Any high level discussions can be had here, but all activity should be on broken down blocker unit level tasks each with its own bug number.  Some quick experiments show that the search engine as is is able to discover types and variables properly for lambda expressions.  For type annotations and reference expressions, there are various things that appear broken.
"BETA_JAVA8:  // ---------  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.io.Serializable;  public class X extends @Marker Object implements @Marker Serializable { 	int x = (@Marker int) 0; }  @Target(ElementType.TYPE_USE)	 @interface Marker { 	 } // ------------------------   Searching for references to Marker brings up only one result - the one inside the cast. The other two are missing."
"BETA_JAVA8:  Attempt to search for the declarations of an interface method fails to find lambda methods:  // ---- interface I { 	void doit(); }  class X { 	static void foo() {} 	I i = () -> {}; 	I i2 = new I() { 		void doit() { 			 		} 	}; }  Search for implementations of I#doit, brings up the one inside the anonymous class, but not the anonymous lambda method."
"BETA_JAVA8:  Searching for references to Existing in the following program brings up only one - it should show two:  // --- import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.Map; import java.util.List; import java.util.Collection;  interface I { 	I doit(); }  class X { 	class Folder<F extends @Existing File> {  } 	Collection<? super @Existing File> s; }  @Target(ElementType.TYPE_USE) @interface Existing { 	 }"
"BETA_JAVA8:  0.6.1 pulled back the allowance made for an interface method to be tagged with the keyword synchronized.  As a result, the following should not compile, but does:  interface I { 	synchronized default void foo() { 		 	} }  // ---  While fixing this, also see if we need a Java8 version of this message: 359 = Illegal modifier for the interface method {0}; only public & abstract are permitted  Now interface methods can also have default and static as keywords.  Also see  1050 = Illegal modifier for the interface method {0}; only public, abstract, strictfp & synchronized are permitted"
BETA_JAVA8:  As a foundation for the new type inference (JSR 335) I will capture the concepts from JLS8 Section 18.1: - 18.1.1 Inference Variables - 18.1.2 Constraint Formulas - 18.1.3 Bound Sets  It remains to be seen if a direct mapping of these concepts onto code yields a practical implementation: Pro: structural similarity will facilitate implementation and maintenance of advanced algorithms Con: the new structures might conflict with our existing implementation or with performance goals. Let's see.
(1) 0.6.1, 15.28 says:   "It is a compile-time error if the ClassType of a constructor reference denotes a class that is an enum type or that is abstract. "   While JLS7 15.9 in addition says:   "It is a compile-time error if any of the type arguments used in a class instance  creation expression are wildcard type arguments (§4.5.1)."   So is the less restrictive version with constructor references intentional ? I don't see anything in  the design/motivation section regarding this to determine if it is.   I would like to use one definition of what can be instantiated unless the relaxation is deliberate.   So, should the following program compile ?   // ---  interface I {    X<?> zoo(int x, String p);  }  public class X<T> {          X(int x, String p) {}          I i = X<? extends String>::new; // will compile        X<?> x = new X<? extends String>(); // will not compile.  }   I don't see a type safety issue here since the parameterization would have pass bounds check, only a consistency issue.   (2) And since the production for ClassType (despite the name) cannot prune type variables and  annotation types, should these also be called out as error scenarios ?   (3) Should the (obvious) point about primary evaluating to base type being a forbidden scenario  be mentioned ?   (4) "The immediately enclosing instance of an inner class instance (15.9.2) must be provided for a constructor reference by a lexically enclosing instance of this (8.1.3). "  Is this restrictive ? Can this be supplied at method invocation time or even via a primary from ? Implementable != useful and  I don't have an assessment as to how useful practically it would be though. Again this is a consistency issue: the call to  new Inner() can occur outside of the enclosing class in an entirely unrelated class as long as there an enclosing instance is  available and the types are visible.
From bug 378724 comment 15:  ---- Cast obscures nullness of a field:  class NPEonCast {      @Nullable     private Object nullable;      public void test() {         if (nullable instanceof Number) {             ((Number)nullable).intValue(); // A         }         if (nullable != null) {             nullable.toString(); // B         }         nullable.toString(); // C     }  }  Error missing for A (while correct for B and C) ----  While the result would be correct when syntactic analysis for fields is enabled (because the instanceof provides protection), without syntactic analysis we should see a warning, which we don't.
BETA_JAVA8:  This may be broken.   LambdaExpression.resolveType is an amalgam of   MethodScope.createMethod SourceTypeBinding.resolveTypesFor AbstractMethodDeclaration.resolve  I may not have hooked up all portions needed for null inheritance/analysis since some of this code was too dependent on the method binding having an associated AbstractMethodDeclaration.  In particular, the call to SourceTypeBinding.createArgumentBindings is not there.  Please see Scope.isLambdaScope, Scope.isLambdaSubscope, scope.namedMethodScope et al which may help with an alternate implementation.
BETA_JAVA8:   org.eclipse.jdt.core.tests.compiler.parser.GenericDietRecoveryTest.test0025() and org.eclipse.jdt.core.tests.model.ReconcilerTests.testMethodWithError01() have started failing since yesterday.  At least on the first, I could see that if I roll back the clock to before c4baf766be166b04f595eec5cebbd2a64f399daa the problem goes away.
"// Try this public class WrongRedundantNullCheck {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static void open() throws Exception { 		occasionallyThrowException(); 	}  	private static void close() throws Exception { 		occasionallyThrowException(); 	}  	public static void main(String s[]) { 		Exception exc = null; 		try { 			open(); 			// do more things 		} 		catch (Exception e) { 			exc = e; 		} 		finally { 			try { 				close(); 			} 			catch (Exception e) { 				if (exc == null) // Wrong warning in this line 					exc = e; 			} 		} 		if (exc != null) 			System.err.println(exc); 	} }"
"// Compile this import java.util.Date;  public class WrongRedundantNullCheck {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static Date createDate() throws Exception { 		occasionallyThrowException(); 		return new Date(); 	}  	public static void main(String s[]) { 		Date d = null; 		try { 			d = createDate(); 			System.out.println(d.toString()); 			try { 				occasionallyThrowException(); 			} 			catch (Exception exc) { 			} 		} 		catch (Exception exc) { 			if (d != null) // Wrong warning in this line 				System.out.println(d.toString()); 		} 	} }"
In a local build I just happened to try this afternoon, I'm seeing following error. My guess is something was removed from a "project pom", but not from the "repo pom"? I know this as been changing ... not sure why this error shows up just now. (This will prevent next production build to fail, if still exists ... apologies if I'm must catching you in the middle of making changes not fully committed/pushed yet).   Here's full error message:  [ERROR] The build could not read 1 project -> [Help 1] org.apache.maven.project.ProjectBuildingException: Some problems were encountered while processing the POMs: [ERROR] Child module /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/org.junit4 of /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml does not exist @          at org.apache.maven.project.DefaultProjectBuilder.build(DefaultProjectBuilder.java:363)         at org.apache.maven.DefaultMaven.collectProjects(DefaultMaven.java:636)         at org.apache.maven.DefaultMaven.getProjectsForMavenReactor(DefaultMaven.java:585)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:234)         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)         at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:601)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352) [ERROR] [ERROR]   The project eclipse.jdt.ui:eclipse.jdt.ui:3.8.0-SNAPSHOT (/data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml) has 1 error [ERROR]     Child module /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/org.junit4 of /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml does not exist
Per the javadoc for org.eclipse.jdt.internal.compiler.apt.model.ElementsImpl#getAllAnnotations(Element), "Annotations are inherited only if the annotation type is meta-annotated with @Inherited". However, the check for the @Inherited meta-annotation does not occur, and indeed all annotations on super classes of the class represented by element are returned, regardless of whether they are annotated with @Inherited.  Steps To Reproduce: 1. create annotation @Foo which is *not* annotated with @Inherited   2. create annotation processor with @SupportedAnnotationTypes("*"), and have it call processingEnv.getElementUtils().getAllAnnotationMirrors(element) for each root element, and print out the results (or use a debugger to see what it gets) 3. use annotation and processor like this:    a. create BaseClass and apply the annotation @Foo    b. create SubClass inheriting BaseClass. 4. The processor will be told that SubClass has the @Foo annotation on it.
I tried to use null analysis on all of my workspace projects which includes a couple of test projects.  I got a lot of warnings in unit tests, that looked like this:  Something x = someService.getNullableThing(); org.junit.Assert.assertNotNull("x", x); x.doMore(); // warning on this line  It would be great of the semantics of org.junit.Assert could be respected. I'd be willing to work on this. Can you provide a hint where to start, e.g. were the special handling of o.e.c.r.Assert is implemented.
For the program below javac 8b76 reports: C:\jtests>C:\lambda-8-b76-windows-x64-05_feb_2013\jdk1.8.0\bin\javac -cp c:\jtes ts X.java X.java:5: error: incompatible types: bad type in conditional expression; int can not be converted to List<String>                 List<String> l = x== 2 ? (List<String>)(null) : 1;                                                                 ^ 1 error  while eclipse BETA_JAVA8 head and javac7 report that Object cannot be converted to List<String>  This difference needs to be investigated.
JSR 335 0.6.1 Part H  "A this expression may appear in a default method body; its type is the type of the enclosing interface. Similarly, an anonymous or local class may be declared in a default method body, so the enclosing instance of an inner class may have an interface type. "  This is actually a NOP, because this is already correctly handled by the compiler. Still corresponding tests should be added.
JSR 335 0.6.1 has a new exception in 8.4.8.4  "It is a compile-time error if a class C inherits a default method whose signature is override-equivalent with another method inherited by C, unless there exists an abstract method declared in a superclass of C and inherited by C that is override-equivalent with the two methods."  The "unless" part is new and must be implemented.
"I have the following conditional breakpoint running in indigo without any problems  text != null && text.contains("";"")  In Kepler M5 I get the following exception  The Exception occurs as soon as I connect two expressione with &&. So text == null && text != null also causes this Exception. The two expressions in isolation do not cause any trouble.  Message: An internal error occurred during: ""JDI Event Dispatch"". ========  Exception Stack Trace: ======================  java.util.EmptyStackException 	at java.util.Stack.peek(Unknown Source) 	at java.util.Stack.pop(Unknown Source) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.pop(ASTInstructionCompiler.java:293) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.storeInstruction(ASTInstructionCompiler.java:297) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.endVisit(ASTInstructionCompiler.java:686) 	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:138) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2562) 	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:565) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:348) 	at org.eclipse.jdt.internal.debug.core.breakpoints.ConditionalBreakpointHandler.breakpointHit(ConditionalBreakpointHandler.java:211) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread.handleSuspendForBreakpoint(JDIThread.java:1275) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.suspend(JavaBreakpoint.java:401) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleBreakpointEvent(JavaBreakpoint.java:390) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent(JavaBreakpoint.java:308) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:186) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)    Session Data: ============= eclipse.buildId=I20130204-1400 java.version=1.7.0_09 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64"
"When searching for References in the workspace, a StackOverflow occurs.  What steps will reproduce the problem? 1. Open a .class file with added sources (it has the J010-Icon and shows source code) 2. Select a method: click on ""getProperty"" (it will be highlighted)  public static String getProperty( final String key ) {  ... }  3. Press Shift-Ctrl-G or select from menu: Search->References->Workspace  A window pops up, reporting a StackOverflowError.   -- Error Details -- Date: Wed Feb 20 09:04:40 CET 2013 Message: An internal error occurred during: ""Java Search"". Severity: Error Product: Eclipse SDK 3.8.0.v201206081200 (org.eclipse.sdk.ide) Plugin: org.eclipse.core.jobs Session Data: eclipse.buildId=I20120608-1200 java.version=1.6.0_35 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US Framework arguments:  -eclipse.password /home/mm/.eclipse/Eclipse.password -keyring /home/mm/.eclipse-keyring/.keyring Command-line arguments:  -os linux -ws gtk -arch x86 -eclipse.password /home/mm/.eclipse/Eclipse.password -keyring /home/mm/.eclipse-keyring/.keyring  Exception Stack Trace: java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.Scope.compilationUnitScope(Scope.java:508) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2524) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526) ... 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526)"
"Build id: I20130204-1400  - configure a project for an early-access JRE8 - open class AbstractList - search for references to method add(E e)  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding$3.compare(ReferenceBinding.java:69) 	at java.util.TimSort.countRunAndMakeAscending(TimSort.java:329) 	at java.util.TimSort.sort(TimSort.java:189) 	at java.util.Arrays.sort(Arrays.java:727) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.sortMethods(ReferenceBinding.java:171) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.availableMethods(BinaryTypeBinding.java:265) 	at org.eclipse.jdt.internal.core.search.matching.ClassFileMatchLocator.locateMatches(ClassFileMatchLocator.java:200) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1699) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1143) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1184) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1316) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53) 	 - search for references to get(int)  java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.search.matching.ClasspathSourceDirectory.directoryTable(ClasspathSourceDirectory.java:52) 	at org.eclipse.jdt.internal.core.search.matching.ClasspathSourceDirectory.findClass(ClasspathSourceDirectory.java:109) 	at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.findClass(JavaSearchNameEnvironment.java:146) 	at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.findType(JavaSearchNameEnvironment.java:185) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:145) 	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:197) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2798) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2516) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getType(MatchLocator.java:899) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding0(MatchLocator.java:955) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding(MatchLocator.java:907) 	at org.eclipse.jdt.internal.core.search.matching.MethodLocator.matchMethod(MethodLocator.java:327) 	at org.eclipse.jdt.internal.core.search.matching.MethodLocator.resolveLevel(MethodLocator.java:664) 	at org.eclipse.jdt.internal.core.search.matching.ClassFileMatchLocator.locateMatches(ClassFileMatchLocator.java:209) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1699) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1143) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1184) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1316) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53) 	 Neither of the problems occurs with JRE7."
Created attachment 227361 [details] Screen shot  When you search for a JDK/JRE on Mac, we use information from the plist file to compute a name. This works fine most of the time, but if you happen to have more than one of the same version of VM installed they are added with the same name.  To make matters a bit worse, if you edit one of the JREs the wizard starts out with an error complaining that the name is already in use.  The attached screen shot shows the duplicated names for the Java 7 JREs
4.3 M5.  Add test case for bug 346230.
JSR 355 0.6.1 uses the phrase "assignment or invocation contexts" to denote situations where an expression may be a poly expression.  The introduction of section 5 has an informal discussion  where item 2 bullet 1 starts:    "Assignment contexts (including return statements, etc.) are supported"   which implies that the term "assignment context" is used loosely, to include many more syntactic constructs. I cannot find a precise definition for this.  This needs clarification, for which I could envision two alternatives: (a) give a complete positive list of syntactic contexts (b) explicitly extend the notion to all expression contexts *except for*     statement contexts.
"Created attachment 227415 [details] Project that shows the error  Error is: The method addListener(App.Command_1<Object>) in the type App.ObservableEventWithArg.Monitor is not applicable for the arguments (new App.Command_1<String>(){})  I've narrowed down the code to simple repro, see attached project. The source is:  import java.util.List;  public class App {          public interface Command_1<T> {         public void execute(T o);     }     public static class ObservableEventWithArg<T> {         public class Monitor {             public Object addListener(final Command_1<T> l) {                 return null;             }         }     }         public static class Context<T> {           public ObservableEventWithArg<String>.Monitor getSubmissionErrorEventMonitor() {               return null;           }   }       	public static void main(String[] args) { 		compileError(new Context<List<String>>()); 	}  	private static void compileError(Context context) { 		context.getSubmissionErrorEventMonitor().addListener(new Command_1<String>() {             @Override             public void execute(String o) {             }         }); 	} }"
"interface I { 	def<CTRL+SPACE> }   For Java 8, we should propose default as a choice."
Some DOM/AST Javadocs like MethodDeclaration have become quite hard to read, because they start with outdated grammar rules. The corresponding API methods are already deprecated, and the old grammar doesn't matter any more.  Any opposition to removing the outdated grammar and just leaving the current version?
"BETA_JAVA8: -----------  While the broader issue of overload resolution is the subject matter of bug 400871, we can already enable lambda/reference expressions in non-overloaded scenarios : i.e where we have just a single candidate method that is both potentially applicable and applicable under one of strict, loose or variable arity invocation. This would enable us to compile the following program which fails to compile as of now:  // --- interface I {     void foo(); } public class X {    void foo(I i) {     System.out.println(""foo"");   } 	   public static void main(String[] args) {     new X().foo(()->{}); // incorrect complaint about non-functional interface.   } } // -----  This solution would also outline how the concern raised in https://bugs.eclipse.org/bugs/show_bug.cgi?id=382701 could be readily addressed and can serve as a sketch for how the overall overload resolution problem is planned to be tackled."
BETA_JAVA8 ----------  The smoke test RunAllJava8Tests should also run RunCompilerTests, but only in 1.8 mode. We are missing some failures otherwise sometimes, which cause needless disruption to other committers.
We need UI for the Java 8 code formatter options from bug 400830.
master  No ITypeHierarchyChangedListener#typeHierarchyChanged(..) event is sent when I add a type with a parametrized supertype.  Steps: - paste into Package Explorer:  abstract class AAAList extends java.util.ArrayList<String> { } abstract class AAAListRaw extends java.util.ArrayList { }  - comment both lines - open Type Hierarchy on ArrayList - uncomment one of the lines and save the editor  => When I uncomment the type AAAListRaw, the Type Hierarchy view is updated and shows the new subtype. OTOH, when I uncomment AAAList, the TH is not refreshed.  The bug is in  org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.subtypesIncludeSupertypeOf(IType): "type.getSuperclassName()" and "type.getSuperInterfaceNames()" include the type arguments, but hasSubtypeNamed(String) expects a raw type.
BETA_JAVA8:  As outlined in https://bugs.eclipse.org/bugs/show_bug.cgi?id=400874#c12, in order to determine whether a lambda is compatible with a type T from its context, we need to compute the set of all "results expressions". These are the types of the expressions in return statements of the lambda body in all possible paths of execution.  Computing this set requires us to traverse the lambda more than once, one time each for possible target types from an overloaded call context.  The present solution adopted is from https://bugs.eclipse.org/bugs/show_bug.cgi?id=400874#c18. While this is a super clean solution, it is not also super efficient. The method LambdaExpression#isComptaibleWith is coded to minimize the copies - for example if the lambda is not even potentially applicable, we will not traverse it multiple times. Another opportunity is for isComptaibleWith to always return true, IFF we are in a INVOCATION_CONTEXT but not in an overload resolution scenario (i.e singleton potentially applicable method) - this could allow resolution to succeed where it should not, but the error will surface itself during resolve.  Even better solutions could exist - This bug is to explore them.
"BETA_JAVA8:  As a first step to supporting full blown usage of method and constructor reference in overloaded method calls, I'll use this ER to enable support for these expressions in non-overloaded calls (actually in calls which end up with just one applicable method - i.e deferring work on most specific method determination to a later date)  The following program should compile, but does not:  // ------------- interface I { 	void foo(X x); }  public class X { 	void foo(I i) {}  	void goo() {} 	 	{ 		foo(X::goo); 	} }  // --------------"
BETA_JAVA8: In bug 401610, I handled only message sends and overlooked explicit constructor calls and allocation expressions. I'll use this bug to address them.
"Consider this example:  public interface I1 { 	default void m() { } } public abstract class C1 { 	public abstract void m(); } public class C2 extends C1 implements I1 { }  I read the spec 0.6.1 part H, 8.4.8 as saying: - I1.m is inherited because C1.m does not override it from C1 - C1.m is inherited because I1.m does not override it from I1  In 8.4.8.4 none of the sentences starting with ""It is a compile-time error"" apply.  This puts the following sentence to action: ""Otherwise, the set of override-equivalent methods consists of at least one abstract method and zero or more default methods; then the class is necessarily an abstract class and is considered to inherit all the methods.""  Thus we should issue an error because C2 is not abstract. This error is not reported currently."
There are 5 failing tests on Windows and Linux for the PList parsing.  http://download.eclipse.org/eclipse/downloads/drops4/I20130225-2315/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html  The problem is that these are now Mac-specific - as they should have always been since the PList parser is only used to create Mac OSX VM installs.
"What steps will reproduce the problem? 1.  2.  3.    -- Error Details -- Date: Tue Feb 26 23:26:06 CET 2013 Message: Server returned HTTP response code: 403 for URL: http://www.junit.org/junit/javadoc/4.5/org/junit/Assert.html Severity: Error Product: Eclipse 1.5.1.20121004-1506 (org.eclipse.epp.package.jee.product) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=M20120914-1800 java.version=1.6.0_27 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=ca_ES Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product  Exception Stack Trace: java.io.IOException: Server returned HTTP response code: 403 for URL: http://www.junit.org/junit/javadoc/4.5/org/junit/Assert.html 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1403) 	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:765) 	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037) 	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:619) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
"BETA_JAVA8:  The following triggers two errors. I believe it should be accepted:  // --------- interface I { 	Integer foo(X x); }  public class X {  	int foo(I ...i) { return 10;}  	int goo() { return 0;} 	 	{ 		foo(X::goo); 		foo(()-> {return 10;}); 	} }  // ---------- Interestingly javac accepts the first call to foo and rejects the second."
"BETA_JAVA8:  The following program should compile, but fails instead with a ClassCastException:  // --- interface I { 	Integer foo(X x); }  public class X { 	int foo(I ...i) { return 10;}  	int goo() { return 0;} 	 	{ 		foo(true ? X::goo : X::goo); 		foo(true ? x-> 1 : x->0); 	} }"
Created attachment 227640 [details] Testcase to reproduce the error  A "\n" introduced when an additional Annotation is added using rewrite
"Compiling the following code   --- import java.util.ArrayList;  public class ForLoopBug { 	public static void main(String[] argv) { 		for (long l : new ArrayList<Long>()) {} 	} } ---  With  ""Preserve unused (never read) local variables"" turned OFF (in the ""Java Compiler"" properties) leads to invalid bytecode:  --- public class ForLoopBug extends java.lang.Object  ...   public static void main(java.lang.String[]);   Code:    Stack=2, Locals=2, Args_size=1    0:   aconst_null    1:   invokeinterface #12,  1; //InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;    6:   astore_1    7:   goto    23    10:  aload_1    11:  invokeinterface #18,  1; //InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;    16:  checkcast       #24; //class java/lang/Long    19:  invokevirtual   #26; //Method java/lang/Long.longValue:()J    22:  pop    23:  aload_1    24:  invokeinterface #30,  1; //InterfaceMethod java/util/Iterator.hasNext:()Z    29:  ifne    10    32:  return   StackMapTable: number_of_entries = 2    frame_type = 252 /* append */      offset_delta = 10      locals = [ class java/util/Iterator ]    frame_type = 12 /* same */ } ---  invokevirtual at pc=19 pushes a long onto the stack (using two stack entries) but the pop at cp=22 removes just a single entry from the stack. This is also reported by the JVM bytecode verifier when the JVM tries to load that class:  --- java.lang.VerifyError: (class: ForLoopBug, method: main signature: ([Ljava/lang/String;)V) Attempt to split long or double on the stack Exception in thread ""main""  ---"
In the fix for bug 393143 we added a handmade icon for the Link With Selection icon that indicates out of sync.  We need to replace this with an official icon from our designers.  /org.eclipse.jdt.ui/icons/full/elcl16/sync_broken.gif
"BETA_JAVA8:  The following program should compile, but doesn't:  // --- interface I { 	int foo(); }  class X { 	void foo(I i) {} 	I i = ()->{ throw new RuntimeException(); }; // OK 	{ 		foo(()->{ throw new RuntimeException(); }); // Error: Bad 	} }  The lambda is value compatible, we conclude otherwise."
Large-scale review of all JLS8 DOM/AST changes.  Major topics: - removed "infos" from extra dimension APIs - added more instructions to ASTNode (and followed them) - fixed ordering of property declarations, in traversal/clone/match/etc. operations, and in implementations where regularity reduces errors - fixed @since tags (missing/redundant) - many Javadoc fixes (missing @exception UnsupportedOperationException tags, missing "added in JLS8 API", etc.) - properly implemented properties in abstract AST node types. VariableDeclaration was already in a bad shape in 3.8, but at least the necessary APIs were there and were correctly implemented. I cleaned this up, moved all fields and accessors etc. into the superclass, and added VariableDeclaration#getExtraDimensions2Property(). Added AnnotatableType#getAnnotationsProperty() and also moved all the implementations to the supertype.
"I was alerted by code in LocalDeclaration.analyzeCode() which relies on methodScope.referenceMethod() to perform ""can be static"" analysis, the latter method returning null within lambda expressions. While that particular piece of code might actually be OK, I noticed a problem with the following program:  interface I { 	void make(); } public class Nesting { 	int val; 	private I test() { 		return () -> System.out.print(val); 	} 	public void call() { test().make(); } }  When enabled, the following bogus warning is issued:   The method test() from the type Nesting can be declared as static  We should check what exactly is missing to let lambda expressions participate in this analysis."
Bug 401030 comment 9 raised a question regarding null annotations on reference expressions.  This bug to address any interaction between null analysis (w/ or w/o annotations) and reference expressions.  One thing clearly calls for action:    X x = null;   I i = x::bar;    This should report a null reference against x but doesn't.   As for null annotations on reference expressions it takes more investigation to see how and why this could be useful.  The easiest solution would be to let the target functional type completely determine any null contracts, and use only inference to see if the reference expressions meets the required null contract. I'll need to play with this a bit more to see if explicit null annotations on a reference expression will be needed in some cases.
"BETA_JAVA8:  I am unable to control+click or use F3 to jump to declaration from the method reference. Constructor reference may also be broken:  // --- interface I {     String foo(String x); }  public class X {     public  String goo(String x) {         return null;     }     void foo()     {     	X x = new X();     	I i = x::goo;  // control+click/F3 on goo.     } }"
"BETA_JAVA8:  No proposals offered at |  //----- interface I {     String foo(String x); }  public class X {     public  String longMethodName(String x) {         return null;     }     void foo()     {     	X x = new X();     	I i = x::longMethodN|     } }"
Code formatter should understand and process lambda expressions.
Method and constructor references should be understood by the formatter and processed properly.
BETA_JAVA8:  Overload resolution in Java 8 requires the same construct (lambda expression, method/constructor references) to be analyzed more than once. Any errors encountered during these steps should not be treated as an error in the program and should not be exposed to the programmer - they may at best steer the resolution in a certain direction.  Presently, we have a hackish solution in place that switches the compilation result object that accumulates the problem markers. We need a cleaner abstraction and this ER is raised for that purpose.
"BETA_JAVA8:  The following program is required to be rejected per 0.6.1 with a ""method is ambiguous"" error. Beginning 0.6.2 though, compile errors discovered during (potential and full) applicability analysis should disqualify an overload resolution candidate method and the program should compile.  // ---- interface I { 	String foo(String s1, String s2); }  interface J { 	X foo(X x1, X x2); }  public class X {  	void goo(I i) {} 	void goo(J j) {}     public static void main(String [] args) { 	new X().goo((p1, p2) -> p1 = p1 + p2);     } }   // -----  ECJ has already been ""partly"" implementing this semantics: if the body of the lambda were to be p1 + p2 instead of p1 = p1 + p2, we would not report any ambiguity - (because return expressions need to be analyzed for assignment compatibility as a part of cpmpatibility check, an erroneous return type would fail to quality)"
BETA_JAVA8:   Now that bug 399793 is closed, we should start work on ASTRewrite support for lambda expressions as a top priority.
BETA_JAVA8:  The most specific applicable overloaded method resolution in Java8 differs from  Java 7 in that it is not just a pair wise comparison of methods as in the case of Java 7. The expression that constitutes the argument must also be taken into consideration to decide which one of the parameter types is more specific.  This requires some infrastructure in the form of new methods in Expression and its subtypes.  (It can be argued this new method belongs in type binding, but if we take that route for poly expressions, we have to turn around and ask the expression itself - given you are who you are which of T and S is more specific - Given that I am proposing to implement this only in Expression)
"BETA_JAVA8:  The following program triggers an NPE: Noticing the missing semicolon after the return.  // ---- interface I { 	J foo(); }  interface J { 	void foo(); }  public class X { 	void foo(I i) {}; 	public static void main(String[] args) { 		new X().foo(() -> { return () -> { return}; }); 	} }"
"BETA_JAVA8:  The following program should compile, but does not and fails with: ""The method foo(I) in the type X is not applicable ..."" message  // ---  interface I { 	J foo(); }  interface J { 	void foo(); }  public class X { 	void foo(I i) {}; 	public static void main(String[] args) { 		new X().foo(() -> { class local { void foo() { return; }} return () -> { return;}; }); 	} } // ---  The return from the inner classes is confused to be a return from the lambda. However the return from the lambda that forms the return expression of the first lambda is handled properly."
No time to investigate recent changes, but my local test builds are now failing with the following.     buildPlatformDoc:      [copy] Copying 1 file to /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv  BUILD FAILED /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/buildDoc.xml:12: The following error occurred while executing this line: /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/buildDoc.xml:105: Either token or a nested replacefilter must be specified  Total time: 0 seconds  An error has occurred. See the log file /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/workspace/.metadata/.log.
When referencing an enum containing constants that override methods,the autocompletion suggestions for that enum don't always contain all enum fields, even with specific typing to narrow suggestions.  Upgraded to Juno from Helios - Helios did not exhibit this behavior.
"BETA_JAVA8:  The following program triggers an AIOOB:  interface I { 	void foo(X x); }  interface J { 	void foo(X x); }  abstract class Y { 	abstract void foo(); } public class X extends Y {  	void f(I i) {} 	void f(J j) {} 	 	void foo() { 	} 	 	public static void main(String[] args) { 		f(super::foo); 	} }"
"BETA_JAVA8:  The following program should fail to compile, but compiles successfully:  // ---- interface I { 	void foo(X x); }  public class X { 	void foo() { 	} 	 	public void main(String[] args) { 		I i = @Marker X::foo; 	} }   The compiler silently acepts the undefined annotation Marker"
"In LambdaExpressions, parameters of type VariableDeclarationFragment are missing a source range. The AST view shows such nodes with a red background color.  Example:  package jsr335;  public class SpecExamples335 { 	public static interface StringToInt { 		int stoi(String s); 	} 	public static interface ReduceInt { 		int reduce(int a, int b); 	} 	 	void foo(StringToInt s) { } 	void bar(ReduceInt r) { } 	 	void bar() { 		foo(s -> s.length()); 		foo((s) -> s.length()); 		foo((String s) -> s.length()); //SingleVariableDeclaration is OK 		 		bar((x, y) -> x+y); 		bar((int x, int y) -> x+y); //SingleVariableDeclarations are OK 	} }"
"ASTs before JLS8 must not try to create nodes that are only allowed in JLS8.  Hint: Open a call hierarchy on ASTNode#unsupportedIn2_3_4() and make sure all accesses are properly protected. You may want to set ""Search Scope > Project"" in the view menu.   E.g. LambdaExpression nodes:  package jsr335; public class RunnableTest { 	Runnable r = () -> System.out.println(""hi""); }  java.lang.UnsupportedOperationException: Operation only supported in JLS8 and later AST 	at org.eclipse.jdt.core.dom.ASTNode.unsupportedIn2_3_4(ASTNode.java:1906) 	at org.eclipse.jdt.core.dom.LambdaExpression.<init>(LambdaExpression.java:127) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2144) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1724) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3137) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3026) 	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:417) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2809) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1329) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
LambdaExpression#resolveTypeBinding() (inherited from Expression) always returns null. E.g. in examples from bug 402665 comment 0.
Created attachment 228095 [details] jdt.core.patch  eclipse.jdt.core R3_8_maintenance branch pom versions are out of sync. Attached patch updates the versions.
"BETA_JAVA8:  Java 8 allows code carrying methods in interfaces in the form of static methods (not inherited by subtypes even though public; They can be accessed only  statically using the declaring interface's type reference.) and default instance methods.  There are various issues in completing on these method names as shown by the snippet below:  | indicates cursor position.  // --- interface I { 	static void staticMethod() {} 	default void defaultMethod() { 		stat|  // no proposals here 	} }  public class X implements I { 	public void foo(I i) { 		i.defaultMethod(); // proposal for defaultMethod offered here 		I.stat|  // no proposals here. 		this.d| // no proposals here. 	} }"
"BETA_JAVA8:  Attempting to format the following program leaves the program unchanged both the classes and interface parts:  // --- class I { 	 int id(int x,      int y)  	{ 		return 0; 	} 	 	static void foo(int x      ,      int    y)  	{ 		 	} }  interface J { 	default int id(int x,      int y)  	{ 		return 0; 	} 	 	static void foo(int x      ,      int    y)  	{ 		 	} }"
"BETA_JAVA8:  The following program fails to get formatted properly. If you change the intersection type cast to a normal cast, all is well:  // ---- import java.io.Serializable; interface I { 	void doit(); } class X { 	void foo(   int x   ,     int   y ) {} 	I i = (I       &       Serializable   ) () -> {}; }"
BETA_JAVA8:  There is an abstraction/modeling problem in that ReferenceExpression implements ReferenceContext (through its parent FunctionalExpression) Only LambdaExpression needs to implement ReferenceContext to trap errors and signal incompatibility during applicability check phase of overload resolution.  ReferenceExpressions do not introduce a scope and their congruence with the target type is limited to there being a single compile time declaration with suitable return types and hence these need/should not implement ReferenceContext.  Patch will follow shortly.
BETA_JAVA8:  We need formatter support for JSR308 style annotations.
"Why would we not issue warnings on the two lines called out ??  // --- public class NPEonCast {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static void open() throws Exception { 		occasionallyThrowException(); 	}  	private static void close() throws Exception { 		occasionallyThrowException(); 	}  	public static void main(String s[]) { 		Exception exc = null; 		if (exc == null) 			; 		try { 			open(); 			// do more things 		} 		catch (Exception e) { 			if (exc == null) // no warning here ?? 				; 		} 		finally { 			try { 				close(); 			} 			catch (Exception e) { 				if (exc == null) // No warning here ?? 					exc = e; 			} 		} 	} }"
Backporting fix for bug 327193 to 3.6.2+.
"I20130311-2000  Have this detail formatter for org.eclipse.core.internal.registry.ConfigurationElementHandle:  return ""namespace: "" + getNamespace() + ""\nname: "" + getName() + ""\nattrs: "" + java.util.Arrays.asList(getAttributeNames());  Select such an element in the Variables view. My scenario was: - breakpoint in SearchDialog.getPreferredPageIndex() - in debug target: open Search dialog - step to SearchPageDescriptor descriptor - expand descriptor in Variables view and select child fElement   Error dialog:  java.util.EmptyStackException 	at java.util.Stack.peek(Stack.java:113) 	at java.util.Stack.pop(Stack.java:95) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.pop(Interpreter.java:156) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.Instruction.popValue(Instruction.java:109) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.BinaryOperator.executeBinary(BinaryOperator.java:83) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.BinaryOperator.execute(BinaryOperator.java:40) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.execute(Interpreter.java:66) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable$1EvaluationRunnable.run(ASTEvaluationEngine.java:684) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread.runEvaluation(JDIThread.java:765) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable.run(ASTEvaluationEngine.java:734) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)  Also found this in the log:  java.util.EmptyStackException 	at java.util.Stack.peek(Stack.java:113) 	at java.util.Stack.pop(Stack.java:95) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.storeInstruction(ASTInstructionCompiler.java:300) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.endVisit(ASTInstructionCompiler.java:695) 	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:138) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2562) 	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:566) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:504) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:465) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getCompiledExpression(JavaDetailFormattersManager.java:389) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.resolveFormatter(JavaDetailFormattersManager.java:154) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.access$1(JavaDetailFormattersManager.java:139) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager$1.run(JavaDetailFormattersManager.java:134) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"1.Create a class:   public class C1 { 	String s;   }  2. Hover on 'String' and click on the link for 'java' package.  The message shown in ""Note: The attached Javadoc could not be retrieved as the specified Javadoc location is either wrong or currently not accessible.""  The javadoc location is specified correctly and is accessible but for 'java' there is no javadoc available and hence no content can be retrieved.  The message indicates a problem with the url even though it is correct.  Cases for a wrong/Inaccessible url and a url where no content is available is not handled differently."
This bug is the parent of bug 403000, bug 403004, bug 403016 and bug 403023.
"from bug 382069 comment 10:  > class Y { > 	@Nullable String str; > 	int foo(@Nullable String str2) { > 		int i; > 		assert str2 != null; > 		i = str2.length();	// No warning > 		 > 		org.junit.Assert.assertNotNull(str2); > 		i = str2.length();	// No warning > 		 > 		org.junit.Assert.assertNotNull(str); > 		i = str.length();	// No warning >  > 		assert this.str != null; > 		i = str.length(); // Potential NPE warning >  > 		return i; > 	} > } >  > Why is the assert not having any effect on the nullable field?  Answer: I haven't yet integrated the conditional analysis of 'assert' with the syntactical analysis for @Nullable fields. I.e., we must combine bug 325342 with bug 383368."
"Created attachment 228323 [details] ASTConverter18Tests.java test case to reproduce the issue  Annotations are not converted (and displayed) correctly in case of annotations on inner classes.  Test program to reproduce:  import java.lang.annotation.ElementType; import java.lang.annotation.Target; public class X  { 	void foo1(@Marker X this) {} 	public class Y {		  	    void foo(@Marker X.@Marker Y this) {} 	} } @Target(ElementType.TYPE_USE)	 @interface Marker {}   OR   Add the attached test case to ASTConverter18Tests.java and the test will fail at the last assertion"
Bug 400761 has introduced some more diagnostics for NPE due auto-unboxing. This solution should be checked for completeness in two dimensions: - are all relevant AST nodes covered? - does the analysis create correct results within (nested) control structures that demand deferred checking? Hopefully, this will also simplify the code a bit, by reducing code duplication.
4.3 M6.  IJavaElement.getAttachedJavadoc(IProgressMonitor) should throw exception if base URL is wrong.  See bug 403036 comment 1 for details.  A point  to consider is a potential performance impact.
"As a result, when null analysis is enabled, the following code has one compilation error where there is none when not enabled:  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class Test {}  class X { 	class Y { 		public void foo( @A X. @B Y this) {} 	} } @Target(value={ElementType.TYPE_USE}) @interface A {} @Target(value={ElementType.TYPE_USE}) @interface B {}  The result is a ParameterizedTypeBinding when null analysis is enabled and MemberTypeBinding otherwise for the explicit receiver type."
There are 3 failing tests in the M6 candidate: http://download.eclipse.org/eclipse/downloads/drops4/I20130313-2000/testResults.php  They have failed for the last three builds. It appears that one of the new tests added for bug 403028 forgets to clean up after itself and leaves a dead launch in the view, which leaks an instruction pointer and prevents the watch expression from updating (because the debug selection does not change).  This is a problem only in the tests.  The offending test is: ConditionalBreakpointsWithGenerics#testBreakpointWithGenericCondition4
The latest spec doesn't allow modifiers on explicit 'this' parameters:  FormalParameterOrReceiverDecls: Type [Identifier .] this [, FormalParameterDecls] FormalParameterDecls  The javac allows final but rejects static. But as per the spec, all modifiers should be rejected on receiver params.
"Inspect example from bug 402665 in ASTView with AST Level 4:  package jsr335;  public class SpecExamples335 { 	public static interface StringToInt { 		int stoi(String s); 	} 	public static interface ReduceInt { 		int reduce(int a, int b); 	} 	 	void foo(StringToInt s) { } 	void bar(ReduceInt r) { } 	 	void bar() { 		foo(s -> s.length()); 		foo((s) -> s.length()); 		foo((String s) -> s.length()); 		 		bar((x, y) -> x+y); 		bar((int x, int y) -> x+y); 	} }  When I drill down to the argument of ""foo(s -> s.length())"", I get this exception:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.LambdaExpression cannot be cast to org.eclipse.jdt.internal.compiler.ast.Literal 	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:735) 	at org.eclipse.jdt.core.dom.Expression.resolveTypeBinding(Expression.java:113) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:112) ..."
"BETA_JAVA8:  The following program triggers an NPE:  // --- //import java.util.Map; import java.lang.annotation.*;  public class X { 	void foo(Map<@Marker ? super @Marker Object, @Marker ? extends @Marker String> m){}    void goo(Map<@Marker ? extends @Marker Object, @Marker ? super @Marker String> m){} }  @Target(ElementType.TYPE_USE) @interface Marker { 	 }  If the import is uncommented, it compiles OK."
In Following test case too much frames gets dropped without need:  1. In the test program (TestHCR.java) set a breakpoint in TestHCR.run() 2. After the breakpoint gets hit, change TestHCR.run() (e.g. add new println) 3. Save the file.  Now, 2 frames are dropped and we are at the start of TestHCR.InnerClass.run()  even though we should be at the start of TestHCR.run() (only one frame should have been dropped, not two).  The reason for this behavior is that both methods TestHCR.run() and TestHCR.InnerClass.run() have the same name and in JavaHotCodeReplaceManager.getAffectedFrame(), CompilationUnitDelta.hasChanged() and MethodSearchVisitor.setTargetMethod() only name of the method gets checked without checking to which class the method belongs.   I've made a short bugfix (see MethodSearchVisitor.java, JavaHotCodeReplaceManager.java, CompilationUnitDelta.java in the attachment) which works for me but am not sure, if this is enought in general.
"BETA_JAVA8:  The following program is incorrectly rejected with three bogus syntax errors:  // --- import java.util.List;  public class X { 	void foo(List<String> @Marker ... ls) {} } @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker { 	 }  Fix is trivial and will follow shortly."
Created attachment 228586 [details] Code that reproduces the bug  Using a @Nullable enum value in a switch statement does not trigger the "Potential null pointer access" warning that it should, potentially leading to runtime NullPointerExceptions. The warning appears correctly when switching on a @Nullable String or Integer object (the latter, presumably, because of the auto-unboxing operation).  I've attached example code that, for me, shows an error when trying to switch on a @Nullable String value, but does not show errors when switching on @Nullable enum values.
"Created attachment 228601 [details] Screen shot of blank JRE tab in External Tools Config dialog  I recently upgraded to Eclipse Juno on my Windows XP machine:  Eclipse Java EE IDE for Web Developers. Version: Juno Service Release 2 Build id: 20130225-0426  When I open the External Tools Configurations dialog and try to select one of my Ant Build launch configurations, this message appears at the top of the dialog:  ""[JRE]: Unable to resolve JRE: jdk1.5.0_19 (Standard VM)"".  I try navigating to the JRE tab to fix this, but the UI of the tab is totally blank (see attached screen shot).  I also get a ""Problem Occurred"" pop-up dialog with the text ""An error has occurred.  See error log for more details.  java.lang.NullPointerException.""  I've tried closing and reopening the External Tools Configuration dialog, and running Eclipse with -clean, but the JRE tab is always blank now, so I can't figure out how to get into a state where I could designate the correct JRE.  Here is the full stack trace from the log file:  java.lang.NullPointerException 	at org.eclipse.core.runtime.Path.append(Path.java:261) 	at org.eclipse.jdt.launching.JavaRuntime.newJREContainerPath(JavaRuntime.java:1915) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.selectJRE(JavaJRETab.java:417) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.updateJREFromConfig(JavaJRETab.java:361) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.initializeFrom(JavaJRETab.java:164) 	at org.eclipse.ant.internal.ui.launchConfigurations.AntJRETab.initializeFrom(AntJRETab.java:160) 	at org.eclipse.debug.ui.AbstractLaunchConfigurationTabGroup.initializeFrom(AbstractLaunchConfigurationTabGroup.java:86) 	at org.eclipse.ant.internal.ui.launchConfigurations.AntTabGroup.initializeFrom(AntTabGroup.java:50) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupWrapper.initializeFrom(LaunchConfigurationTabGroupWrapper.java:194) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.displayInstanceTabs(LaunchConfigurationTabGroupViewer.java:753) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer$8.run(LaunchConfigurationTabGroupViewer.java:624) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.inputChanged(LaunchConfigurationTabGroupViewer.java:641) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput0(LaunchConfigurationTabGroupViewer.java:603) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput(LaunchConfigurationTabGroupViewer.java:579) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:941) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog$3.selectionChanged(LaunchConfigurationsDialog.java:560) 	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:888) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49) 	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175) 	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:886) 	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1226) 	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1251) 	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:262) 	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:256) 	at org.eclipse.jface.util.OpenStrategy$3.run(OpenStrategy.java:433) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1132) 	at org.eclipse.debug.ui.DebugUITools$2.run(DebugUITools.java:600) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:608) 	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:542) 	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:81) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4169) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3758) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1053) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:942) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438) !SESSION 2013-03-18 17:10:10.639 ----------------------------------------------- eclipse.buildId=M20130204-1200 java.version=1.6.0_31 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.jee.product -clean  Please advise if I need to provide any more details.  Thank you, Jennifer"
Created attachment 228605 [details] Failure List  Attached list of failures for b81.
For javadoc written like this:   /**    * Initialization for adminRatingScaleController.    * @throws AjaxServiceException    *           when AjaxServiceException    */  The output of ASTNode.toString() makes it "@throws AjaxServiceExceptionwhen AjaxServiceException", missing an important whitespace.    The below is my fix for your information (diff to master HEAD)                         // assume text elements include necessary leading and trailing whitespace                         // but Name, MemberRef, MethodRef, and nested TagElement do not include white space                         boolean currentIncludesWhiteSpace = (e instanceof TextElement); +                       if ((TextElement) e).getText.charAt(0) != ' ') { +                               currentIncludesWhiteSpace = false; +                       }                         if (previousRequiresNewLine && currentIncludesWhiteSpace) {                                 this.buffer.append("\n * ");//$NON-NLS-1$                         }  For the javadoc I'm working on, the TextElement does not have leading whitespace, so the assuming failed.
BETA_JAVA8:  At the moment, we have been tagging Java 8 API items (mostly IProblems) with "@since 3.9"  This needs to be adjusted to be "@since 3.9 BETA_JAVA8"  We don't want to use 3.9.1 since we want to be able to distinguish between what gets added in 3.9.1 in normal course and what got expressly added for Java 8 support.
Section 18.5 distinguishes Invocation Applicability Inference (18.5.1) from Invocation Type Inference (18.5.2).  Here the second phase is to reuse the bound set of the first phase, but any results of resolution, notably any instantiations have to be dropped and re-computed with more constraints in the lot.
"As part of the work for upgrading our test infrastructure to use 8b81, I had to modify org.eclipse.jdt.core.tests.compiler.regression.InterfaceMethodsTest.testSuperCall2 to be:  // --- import java.util.*; import java.util.stream.Stream; public abstract class X<E> implements OrderedSet<E> { 	@Override 	public Stream<E> stream() { 		return List.super.stream(); // List is not a direct super interface 	} 	@Override 	public Stream<E> parallelStream() { return OrderedSet.super.parallelStream();}    class Inner { 		public Stream<E> stream() { 			return OrderedSet.super.stream(); // not a super interface of the direct enclosing class 		} 	} 	@Override 	public boolean add(E o) { 		OrderedSet.super.add(o); // target not a default method 	} 	X() { 		OrderedSet.super(); // not applicable for super ctor call 	} } interface OrderedSet<E> extends List<E>, Set<E> { 	@Override 	boolean add(E o); 	@Override    default Spliterator<E> spliterator() { return List.super.spliterator(); } } // --  This program generates 4 errors when compiled with javac 8b81. Eclipse reports the same 4 errors, but in addition also reports againt class X an error about there being unrelated default methods spliterator().  This is suspect since OrderedSet's implementation has replaced List and Set's versions and these should be out of reckoning altogether.  See that there is no error reported against OrderedSet itself regarding duplicate unrelated defaults.  Strangely, the unmodified method must have had the same issue - but we never reported an error earlier."
"BETA_JAVA8:   There is no effect seen while formatting this program:  // --- public class X { 	void foo(@Marker X this) {} 	class Y { 		Y(@Marker X X.this) {} 		void foo(X.Y this) {} 	} }  @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker { 	 }  This could be due to assumptions that argument name is an TokenNameIdentifier, which is not true for receiver parameters."
Render TYPE_USE annotations in Javadoc hover/view.
Handle annotations on extra dimensions in the AST.  For jsr308, a new extraDimensions2 property has been added to MethodDeclaration and to the two concrete VariableDeclaration types. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.  File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
Replace usages of MethodDeclaration#thrownExceptions() in the AST.  For jsr308, MethodDeclaration's thrownExceptions property has been replaced with thrownExceptionTypes. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.  File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
Created attachment 228756 [details] patch.eclipse.jdt.core.binaries.R3_8_maintenance  To be applied right after I20130326-0800
Created attachment 228759 [details] patch.eclipse.jdt.R3_8_maintenance  To be applied right after I20130326-0800
This probably needs no additional rewrite work. But needs to be investigated and new tests can be added.
See, e.g., GenericTypeTest.test0805():   String s = foo(numbers, floats);    During Invocation Applicability Inference we find that T = Number[], but during Invocation Type Inference we find no solution matching the expected type String. This leads the initial implementation to report:    "The method foo(T, T) in the type X is not applicable for the arguments (Number[], Float[])" where we expect:   "Type mismatch: cannot convert from Number[] to String"    This can be rectified by falling back to the provisional result. I have a small correction in this regard, which will later need careful integration with overload resolution.
For these DefaultCodeFormatterConstants options, the value NEXT_LINE_ON_WRAP is not implemented:  FORMATTER_BRACE_POSITION_FOR_BLOCK_IN_CASE FORMATTER_BRACE_POSITION_FOR_SWITCH FORMATTER_BRACE_POSITION_FOR_ARRAY_INITIALIZER FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY  This can be seen in the Code Formatter preference dialog when you set "Line Wrapping > Maximum line width" to 10 and then play on the Braces tab.
Created attachment 228918 [details] wrong uploaded file  A lot of nested try-catch-finally-blocks leads to unrunnable Java byte code (JDT for Java 7). See the attached Java file.  When I compile the same code with javac (Java 7 Update 17) the Java byte code is valid and runnable.  JDT for Java 6 has also no problem with the attached Java file.
Since JUnit 4.11, junit.framework.Assert is deprecated. This creates a bunch of warnings in the test projects.  AFAIK, the goal is still to keep the tests runnable with Java 1.4 / JUnit 3, so the fix is to: - just drop the "Assert." if it occurs in a subclass of TestCase - replace the "Assert." with "junit.framework.TestCase."
Created attachment 228982 [details] Fix this bug by appending interval whitespaces  Please look at an expression like this:  threadMessagePrefix + "Processing " + ++i + " of " + total + "..."  ASTRewriteFlattener prints it as:   threadMessagePrefix + "Processing "+++i+" of "+total+"..."  Code is broken because '+++' is an invalid operator.
BETA_JAVA8  Deprecate AST.JLS4.
The 'step into selection' action lives in a different menu to the 'step into' action in the 'run' menu. This makes it difficult to discover for those are looking in the same place as 'step into'.
The DOM AST APIs are pretty type safe. ASTNode#checkNewChild(..) is used everywhere to ensure that new nodes are of the right type.  ASTRewrite is currently unsafe, since it doesn't do the type tests in ASTRewrite#set(..) and in ListRewriteEvent#insert(..) etc.  These tests should be added, so that type errors can be detected early. The API Javadoc already tell that an IllegalArgumentException is thrown "if the described modification is invalid".  However, before releasing the fix, we need to check fallout from bad client code that was accepted before. If it turns out this happens everywhere, then we maybe have to deprecate ASTRewrite.create(AST) and only ensure sanity in a new creation method.
"Here is the original source code:  public class A { 	public int i = 0; 	public void m(B b) { 		i++; 	}	 }  public class B { 	public void m() {		 	} }  When method m of A is moved to B by applying move-refactoring, Eclipse error occurs saying that ""A method with name 'm' already exists in the target type 'B'. But it should not be an error since method m will have different parameters in B:  public class B { 	public void m() {		 	}  	public void m(A a) { 		a.i++; 	} }"
"Example:  package jsr308.bug; import java.lang.annotation.*; public class AnnotatedQualifiedType { 	@Target(ElementType.TYPE_USE) 	@Retention(RetentionPolicy.RUNTIME) 	@Documented 	static @interface NonNull { }  	java.io.@NonNull IOException foo( 			java.io.@NonNull FileNotFoundException arg) 			throws java.io.@NonNull EOFException { 		try { 		} catch (java.io.@NonNull IOError e) { 		} 		return null; 	} }  The ""java.io.@NonNull XyException"" are all represented like this in the AST:  SimpleType                         ""java.io.@NonNull XyException"" + annotations: MarkerAnnotation            ""@NonNull"" + name: QualifiedName              ""java.io.@NonNull XyException""         + qualifier: QualifiedName ""java.io""         + name: SimpleName                          ""XyException""  This is incorrect. The first QualifiedName's source range cannot contain the ""@NonNull"". In the current API, the legal representation would be:  QualifiedType                       ""java.io.@NonNull XyException"" + qualifier: SimpleType             ""java.io""              + annotations: <empty>              + name: QualifiedName  ""java.io"" + annotations: MarkerAnnotation             ""@NonNull"" + name: SimpleName                                   ""XyException""  Alternatively, the first qualifier could also be a QualifiedType containing a SimpleType and a SimpleName. Both of these representations have the problem that the ""qualifier"" property of a QualifiedType is a Type, but ""java.io"" is not a type.  I don't have a good solution right now."
We are using Execution Environment Descriptions http://wiki.eclipse.org/Execution_Environment_Descriptions to contribute custom Java VM installations to eclipse. VM has ee.language.level=1.4 and eclipse IDE decides that it has support for JAXP for some reason. This is needed to evaluating VM system properties by executing special class org.eclipse.jdt.internal.launching.support.SystemProperties used for retrieving system information for the VM itself. This class uses JAXP which is NOT mandatory functionality for jdk 1.4. As result all features of eclipse which use these system properties doesn't work. New property should be added to the execution environment descriptions which informs eclipse to use the legacy org.eclipse.jdt.internal.launching.support.LegacySystemProperties instead of detecting XML support by language level.
Created attachment 229190 [details] jdt.core.patch  Parse error in pom file causing Maven to be unable to parse due to commit:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/diff/pom.xml?h=R3_8_maintenance&id=acb602ad4eb430f5d9505052936cd13d1f359884
As of 0.6.2 para 15.12.3 contains this:  " If the method invocation has, before the left parenthesis, the form ClassName TypeName . super . NonWildTypeArgumentsopt Identifier, then:     [...]     Otherwise, if the TypeName denotes an interface, let T be the type declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (9.4.1) the compile-time declaration from a direct superclass or direct superinterface of T."      This rule is yet unimplemented.
"BETA_JAVA8 follow-up of bug 382721:  The following program is currently accepted (except for the expected ""Missing code implementation in the compiler"" during code-gen):  public class EffectivelyFinalInLoop { 	void executeLater(Runnable r) { /*...*/ } 	void test() { 		int n; 		for (int i=0; i<3; i++) { 			n=i; 			executeLater(()-> System.out.println(n)); 		} 	} }  The analysis incorrectly believes that n is assigned only once.  I noticed this by analogy to definite-assignment analysis: The error duplicateInitializationOfFinalLocal() is triggered from 3 locations: - SingleNameReference.analyseAssignment() - FinallyFlowContext.complainOnDeferredChecks() - LoopingFlowContext.complainOnDeferredFinalChecks()  Of these locations only the first resets IsEffectivelyFinal, whereas all of them should consider to do so."
Created attachment 229203 [details] Patch file where the test case is mentioned. Can be applied to ASTRewritingExpressionTest.java  Expected Output: String myString = (@Annot String) myObject;\n"); Actual Output  : String myString = ( @AnnotString) myObject
Bug 391376 solves a problem that should actually be handled in the VM, see    http://bugs.sun.com/view_bug.do?bug_id=8009130  Once that bug is fixed we should revisit our strategy for generating bridges.
"Created attachment 229243 [details] Test case to reproduce  For the attached test case, JDT gives an NPE (although it shows an error message as well)   Stack shown below:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference.resolveType(QualifiedSuperReference.java:47) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:87) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:275) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:505) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1198) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:565) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"After upgrading to 4.2.2, after a few hours of usage of Eclipse IDE, entries under ""Run Configuration..."" are suddenly not available any more. None of the usual entries like ""Run Java Application"", ""Run JUnit Test"", ... appear, not on the project-tree and not in the JAva Editor as well. Also keyboard shortcuts like F11 and SHIFT-F11 stop working, they do not start the currently opened context any more, but always the last executed one, i.e. if I open another app, they still start the previously executed one.  Restarting Eclipse helps, but only for a while until it reappears.  I could not yet attribute it to something specific, only that it consistently happens at least after a few hours of usage on two different installations of Eclipse. Both were updated from 4.2 to 4.2.1 and then to 4.2.2.  Log contains a number of exceptions, but I am not sure which ones are directly related:  !ENTRY org.eclipse.ltk.core.refactoring 4 10009 2013-04-02 15:15:10.416 !MESSAGE Participant 'org.eclipse.jdt.debug.refactoring.launchConfiguration.typeMove' removed due to the following exception !STACK 1 Java Model Exception: Java Model Status [[Working copy] MyTextTest.java [in com.c.timesheet [in src [in TimesheetHelper]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:495) 	at org.eclipse.jdt.internal.core.Openable.getUnderlyingResource(Openable.java:343) 	at org.eclipse.jdt.internal.core.CompilationUnit.getUnderlyingResource(CompilationUnit.java:943) 	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:226) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:104) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:137) 	at org.eclipse.jdt.internal.debug.core.refactoring.LaunchConfigurationProjectMainTypeChange.perform(LaunchConfigurationProjectMainTypeChange.java:159) 	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306) 	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) !SUBENTRY 1 org.eclipse.jdt.core 4 969 2013-04-02 15:15:10.418 !MESSAGE [Working copy] MyTextTest.java [in com.compuware.timesheet [in src [in TimesheetHelper]]] does not exist    !ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2013-04-02 15:15:10.531 !MESSAGE Internal Error !STACK 1 Java Model Exception: Java Model Status [MyTextTest.java [in com.c.timesheet [in src [in TimesheetHelper]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:495) 	at org.eclipse.jdt.internal.core.Openable.getUnderlyingResource(Openable.java:343) 	at org.eclipse.jdt.internal.core.CompilationUnit.getUnderlyingResource(CompilationUnit.java:943) 	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:226) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:104) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:137) 	at org.eclipse.jdt.internal.debug.core.refactoring.LaunchConfigurationProjectMainTypeChange.perform(LaunchConfigurationProjectMainTypeChange.java:159) 	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306) 	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) !SUBENTRY 1 org.eclipse.jdt.core 4 969 2013-04-02 15:15:10.531 !MESSAGE MyTextTest.java [in com.compuware.timesheet [in src [in TimesheetHelper]]] does not exist    Conflicting handlers for org.eclipse.debug.ui.commands.eof: {org.eclipse.debug.internal.ui.views.console.ProcessConsolePageParticipant$EOFHandler@27d399e8} vs {org.eclipse.debug.internal.ui.views.console.ProcessConsolePageParticipant$EOFHandler@27d399e8}   !ENTRY org.eclipse.equinox.event 4 0 2013-04-02 15:57:42.756 !MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/ElementContainer/selectedElement/SET] to handler org.eclipse.e4.ui.services.internal.events.UIEventHandler@6eef7d8f !STACK 0 java.lang.ClassCastException: java.lang.Object cannot be cast to org.eclipse.e4.core.commands.EHandlerService 	at org.eclipse.ui.internal.menus.MenuHelper$1.evaluate(MenuHelper.java:240) 	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.isVisible(ContributionsAnalyzer.java:248) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.computeVisibility(ToolBarContributionRecord.java:114) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.updateVisibility(ToolBarContributionRecord.java:68) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer$6.changed(ToolBarManagerRenderer.java:352) 	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:328) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:342) 	at org.eclipse.e4.core.internal.contexts.EclipseContext$1.changed(EclipseContext.java:738) 	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:328) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:342) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.activate(EclipseContext.java:625) 	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.switchPerspective(PartServiceImpl.java:503) 	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:124) 	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:67) 	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:41) 	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:180) 	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:150) 	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4687) 	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:187) 	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38) 	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197) 	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197) 	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1) 	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) 	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) 	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135) 	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78) 	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39) 	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:80) 	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:58) 	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374) 	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135) 	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1) 	at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:3558) 	at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:2674) 	at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:2614) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager.switchToPerspective(PerspectiveManager.java:367) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$5.runInUIThread(PerspectiveManager.java:446) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$1.run(PerspectiveManager.java:211) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1053) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:942) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)"
Preferences>Java>Debug>Open popup when suspended on exception doesn't work. Even if it is checked, ExceptionInspector won't popup.  Maybe because... It is stored at org.eclipse.jdt.internal.debug.ui.JavaDebugPreferencePage.performOk() with JDIDebugUIPlugin.getDefault().getPreferenceStore(). So I can see it in org.eclipse.jdt.debug.ui.prefs under .metadata. However, org.eclipse.jdt.internal.debug.ui.breakpoints.ExceptionInspector.ExceptionInspector() refers JDIDebugPlugin.getUniqueIdentifier(). I cannot see the option in org.eclipse.jdt.debug.prefs of course. (Sorry if I misunderstood)
"BETA_JAVA8  ""Correct Indentation"" doesn't indent a default method. It even removes the indentation here:  public interface DefaultMethod { 	void bar();  	default void foo() { 		System.out.println(""foo""); 	} }  The code formatter is fine."
Couple of cases being:  AST.JLS4 MethodDeclaration@thrownExceptions()  The former should be replaced with JLS8 and the code using thrownExceptions() should be changed to use thrownExceptionTypes().
Up until M6 given source text such as (@ is the cursor position)       @xxxx  it was possible to insert type       if (yyyy != null) {@xxxx  then new line to get       if (yyyy != null) {         xxxx      }  Now (in M6) and in eclipse-SDK-I20130402-0800-win32.zip we get       if (yyyy != null) {               }xxxx  Super-irritating.
Created attachment 229331 [details] jdt.core.binaries.patch  The parent group for one of the bundles does not match the group of it's actual parent. Attached patch updates the bundle pom to match.
Add a debug option to verify proper nesting of ASTNodes according to ASTParser#setKind(int):   * Source ranges nest properly: the source range for a child is always  * within the source range of its parent, and the source ranges of sibling  * nodes never overlap.  This should avoid issues like bug 404489 and bug 391894 comment 4 in the future.
After bug 399792 is released, AST rewrite support should be added to casts with intersection types.
master (from bug 405015)  IJavaProject#findType(String) should never find a secondary type. But if you call this methods with "x.y.z.test13outer" for the CU below, then you get an IType iff the CU is open in a Java editor.  -------------------------------------- package x.y.z;  public interface test13 { }  /**  * @noreference  */ interface test13outer {} --------------------------------------  The problem is that "considerSecondaryTypes" is dropped in org.eclipse.jdt.internal.core.NameLookup.findType(String, String, boolean, int, boolean, boolean, boolean, IProgressMonitor) line 662, and eventually, seekTypesInWorkingCopies(..) finds the secondary type.
When the search engine is primed (as part of calling JavaCore.initializeAfterLoad(IProgressMonitor)) then it populates the index manager based on the information returned from IndexManager#computeIndexLocation(IPath containerPath).  If the underlying index is a pre-built index but it has been deleted from the file-system, then the index is re-created in the workspace metadata and not in the location specified by the INDEX_LOCATION_ATTRIBUTE_NAME classpath attribute.  This is because search has no concept of the classpath containers - it simply knows a list of project and the corresponding archive files.  In JavaCore.initializeAfterLoad(IProgressMonitor) the call to refresh external archives (which populates the index manager with the correct classpath attribute information) happens after the search occurs.  Since the index has already been built from the search call then it ends up being used.  There are two ways to fix this:  1) In JavaCore.initializeAfterLoad(IProgressMonitor), move the call to refresh the archives to happen BEFORE the search engine is primed.  2) In IndexManager#computeIndexLocation(IPath containerPath, final URL newIndexURL) added via bug 395897, if the existing URL is different from the new URL then the index needs to be rebuilt after it is removed.  I think fix 1 makes more sense as, ideally, you want to know the latest archive state before a search is done.  This approach also ensures that the indexer manager is doing less work
BETA_JAVA8:  This ER will be used to implement the infrastructure support for generating code for lambda expressions and method references.  Among other things:  We need to add capability to generate:   - ConstantPool sections for MethodHandles, MethodType, InvokeDynamic   - Attribute section for BootStrapMethods  - Adding of InnerClass reference for MethodHandles.Lookup  The patch at https://bugs.eclipse.org/bugs/show_bug.cgi?id=400875 has support for these. The infrastructure portion needs to be separated out, reviewed and released.
BETA_JAVA8:  This ER will be used to implement/track generation of code for stateless lambda's.
BETA_JAVA8:  This ER will be used to implement/track code generation for lambda expressions that refer to effectively final variables or fields of its enclosing class.
BETA_JAVA8:  This ER will be used to implement/track code generation for method references
BETA_JAVA8:  This ER will be used to implement/track code generation for constructor references.
BETA_JAVA8:  This ER will be used to implement/track generate code for array constructor references.
Looking at QuickFixProcessor.process() two kinds of problems could actually trigger insertion of null annotations while annotation-based null analysis is disabled:   IProblem.NonNullLocalVariableComparisonYieldsFalse   IProblem.RedundantNullCheckOnNonNullLocalVariable  Checks should be inserted to prevent bogus proposals.  Even if null annotations are enabled, some proposals offered on this route don't make much sense, I'm afraid.   I'll investigate.
Editor save action "Remove unnecessary parentheses" makes code uncompilable.  Code line below before save: static final Short cache[] = new Short[-(-128) + 127 + 1]; //compilable  code line after save: static final Short cache[] = new Short[--128 + 127 + 1];  //uncompilable  This line of code is from java.lang.Short.
BETA_JAVA8:  This ER will be used to implement track support for serializeable lambdas.
"public interface Foo {  	int run(int s1, int s2);  }  interface X { 	      static Foo f = (int s5, int s6) -> x<ctrl-space>     static int x1 = 2; }  x1 should have been suggested in assist; but not happening that way.  Thanks Anirban"
"public interface Foo {  	int run(int s1, int s2);  }  interface X { 	      static Foo f = (int x5, int x11) -> x     static int x1 = 2; }  class C { 	void method1(){ 		int p = X.<ctrl-space> 	} }  Wrongly suggesting x5, x11. Only x1 should have been suggested."
"public interface Foo {  	int run1(int s1, int s2); 	static int x2 = 0; }  interface Foo1 { 	Foo run2(int argFoo1); }  interface X extends Foo{ 	     static int x1 = 2;     static Foo f = (x5, x6) -> x5;     static Foo1 f1 = af1 -> (a1,b1) -> {int uniqueName = 4; return uniqueName;};     		 }  eclipse compiler clean, reference commandline compiler crash and seemingly total breakdown of code-assist inside the curly braces in the above multilevel lambda.  Thanks Anirban"
"public interface Foo {  	int run1(int s1, int s2); }  interface X extends Foo{ 	     static Foo f = (x5, x6) -> {x<ctrl-space>     		 }  x5, x6 are not suggested."
Created attachment 229449 [details] Missing carriage return at the end of the error summary output.  When compiling a Java file that contains errors using ecj from command line, the error output lacks a final carriage return. This means that the shell prompt or the next output from the invoking shell script appears on the same line as the last line of the ecj error output.  For example, you get this output:   [mbooth@10-2-5-11 calameo]$ CLASSPATH=/usr/share/java/ecj.jar:. \   java org.eclipse.jdt.internal.compiler.batch.Main Envelope.java ... error output etc ... ---------- 4 problems (4 errors)[mbooth@10-2-5-11 calameo]$    When it would be more desirable to have this output:   [mbooth@10-2-5-11 calameo]$ CLASSPATH=/usr/share/java/ecj.jar:. \   java org.eclipse.jdt.internal.compiler.batch.Main Envelope.java ... error output etc ... ---------- 4 problems (4 errors) [mbooth@10-2-5-11 calameo]$    The attached patch makes a small change to the output so that instead of including a final carriage return *only* in EMACS log output mode, we include a final carriage return in every output mode *except* for XML log output mode.
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=41ef4898bfd4399802c4b7fddb8b2e4f958ada78 says "Clean up new warnings introduced by merge from master", but it actually reintroduces some of the warnings from bug 404169. This commit should be reverted.  Srikanth, could it be that you're running against an old target platform or a target that replaces org.junit 4.11 with an older version?
when compiling a project via the BatchCompiler on Java 7 I get an NPE thrown from org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202)  the problem seem to be at line 573:      return this.locations.get(location.getName());  which works fine in Java 6, but returns null for Java 7.  location.getName() is "PLATFORM_CLASS_PATH" at that point.  building the same project with Java 6 works fine.  see more details at: http://stackoverflow.com/questions/15819926/eclipse-jdt-compiler-ecj-throws-npe-in-java-1-7  stacktrace: java.lang.NullPointerException     at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202)     at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.handleOption(EclipseFileManager.java:669)     at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchProcessingEnvImpl.(BatchProcessingEnvImpl.java:88)     at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager.configure(BatchAnnotationProcessorManager.java:69)     at org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager(Main.java:3632)     at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:3737)     at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1679)     at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1372)     at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:80)     at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:52)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:601) ...     at java.lang.Thread.run(Thread.java:722)
Currently it doesn't recognize 1.8 as an option. There are probably other things to be taken care of as well. This bug is to make the batch compiler work in 1.8 mode with support for annotation processing.
import java.util.@<ctrl-space>
Investigate what we have to do for LambdaExpressions in the UI.  Possible pain points:  - code that traverses the parent chain to find the enclosing scope (e.g. to find visibility of variables, possible target position for Extract Local Variable or Extract Method)  - type of lambda expression is inferred from context (e.g. extracting a lambda expression into a local variable may need special handling to get the right type; compare to MethodInvocation.isResolvedTypeInferredFromExpectedType())  - problems with lambda parameters without a declared type  - ...
When using the formatter from the command line on a large number of files, an ArrayIndexOutOfBoundsException is thrown by the formatter. Here's the contents of the log file denoted by the resulting error dialog:  !SESSION 2013-04-09 21:49:29.546 ----------------------------------------------- eclipse.buildId=M20130204-1200 java.version=1.7.0_15 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments] Command-line arguments:  -os linux -ws gtk -arch x86_64 -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments]  !ENTRY org.eclipse.osgi 4 0 2013-04-09 21:49:31.580 !MESSAGE Application error !STACK 1 java.lang.ArrayIndexOutOfBoundsException: 100         at org.eclipse.jdt.internal.formatter.Scribe.printNewLinesCharacters(Scribe.java:4867)         at org.eclipse.jdt.internal.formatter.Scribe.addOptimizedReplaceEdit(Scribe.java:571)         at org.eclipse.jdt.internal.formatter.Scribe.addReplaceEdit(Scribe.java:663)         at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2553)         at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2406)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:4379)         at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:277)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:593)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.formatTypeMembers(CodeFormatterVisitor.java:2212)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:1217)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:5586)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1286)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:3305)         at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:679)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:863)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.formatCompilationUnit(DefaultCodeFormatter.java:241)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:163)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:146)         at org.eclipse.jdt.core.formatter.CodeFormatterApplication.formatFile(CodeFormatterApplication.java:223)         at org.eclipse.jdt.core.formatter.CodeFormatterApplication.start(CodeFormatterApplication.java:418)         at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)         at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)         at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)         at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)         at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:601)         at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)         at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)         at org.eclipse.equinox.launcher.Main.run(Main.java:1438)         at org.eclipse.equinox.launcher.Main.main(Main.java:1414)  The command I run is:  ~/eclipse-4.2/eclipse -nosplash -application org.eclipse.jdt.core.JavaCodeFormatter -config ...  In my particular case, it crashes when there are 183 or more files. This seems like a simple case of not checking the current size of the Scribe.edits array before appending to it.
R3.8.  The Open Input action in the info views should be disabled if the input is empty/null. Currently, it is not, and clicking it, gives an error dialog saying:  Problem opening editor for '': 'Could not get an editor input for the given element'
Follow-up to bug 399791. That bug only added API in Flags for AccDefaultMethod, but the flag isn't actually returned by IMethod#getFlags().  On the other hand IMethod#getFlags() currently includes the unspecified Bit18 (ClassFileConstants.AccAnnotationDefault) for an annotation type method with a default value, e.g. javax.annotation.Generated#date() -- but ONLY if it's coming from a class file. For source files, it's masked away in SourceElementNotifier #notifySourceElementRequestor(AbstractMethodDeclaration, ...)   For IMethod#getFlags() and IMethodBinding#getModifiers(), we need to decide which of these flags to include:  - Flags/ClassFileConstants#AccDeprecated: included in getFlags(), but not in getModifiers() (spec'd like this) => keep it like this  - ClassFileConstants#AccAnnotationDefault (no API yet): sometimes included in getFlags() => needs a new API constant in Flags => getFlags(): should always be returned since we may want to show this in the element icon => getModifiers(): not necessary; checking IMethodBinding#getDefaultValue() for null is good enough  - Flags/ExtraCompilerModifiers#AccDefaultMethod: currently not returned anywhere => getFlags(): should always be returned since we may want to show this in the element icon; absence of 'abstract' is not enough to detect this in source => getModifiers(): not necessary; if declaring type is an interface type and IMethodBinding#getModifiers() includes 'abstract', then we know it's a default method.
"Created attachment 229664 [details] Fix the javadoc comment typo  /** foobar(<ul> 	 * <li>    #fragment1, #fragment2,  </li> 	 * <li>     #fragment3, #fragment4, </li> 	 * </ul> 	 */ 	public static final int M_COMPACT_FIRST_BREAK_SPLIT = 32; ----- fragment5 should be fragment3, according to the context and neighbor fields."
"I believe I'm getting a false positive resource leak warning when resources are closed using apache dbutils closeQuietly methods. Simplified Code: public static void test(Connection con){  	PreparedStatement ps = null; 	try { 		ps = con.prepareStatement(""foo""); 		// Remove this loop for no warning  		for (int i = 0; i < 1; i++) { 			try { 				ps.executeUpdate(); 			} catch (SQLException e) { 				throw new SQLException(""Some message"", e); // << warning 			} 			// << move the closing finally to here for no warning 		} 	} catch (SQLException e) { 		throw new RuntimeException(e); 	} finally { 		DbUtils.closeQuietly(ps);  // << change this to ps.close for no warning 	} }    The warning is removed if:  1, I add the finally block after the inner try-catch  2, I change closeQuietly to ps.close() (with the required try-catch wrapper)  3, I remove the for-loop"
The constructor/method parameter tooltip (Ctrl+Shift+Space) indicates the wrong parameter as current under some circumstances. To provoke the behavior, the parameter list must span multiple lines. But that doesn't seem to be the only condition. Unfortunately I wasn't able to reproduce the behavior with a small self-contained snippet. However, it can be observed with the MessageDialogWithToggle constructor:     MessageDialogWithToggle dialog       = new MessageDialogWithToggle( parentShell,                                      "Dialog Title",                                      null,                                      message,                                      MessageDialog.INFORMATION,                                      new String[] { IDialogConstants.OK_LABEL },                                      0,                                      "&Don't show this again",                                      false ); Place the cursor e.g. on the 'false' parameter and hit Ctrl+Shift+Space. The tooltip appears but draws the 'Shell parentShell' parameter in bold letters instead of 'boolean toggleState'.
Created attachment 229713 [details] test code  I created a CompilationUnit, call recordModifications() and do some modifications on it, and then use CompilationUnit#rewrite(...) to generate changed code.  BUT such modifications come into problem:         cu.accept(new ASTVisitor() {             @Override             public boolean visit(CatchClause node) {                 if (node.getException().getType().toString().equals("RemoteException")) {                     AST ast = node.getAST();                     CatchClause newCC = (CatchClause) ASTNode.copySubtree(ast, node);                     newCC.getException().setType(ast.newSimpleType(ast.newSimpleName("ServiceApplicationException"))); // This has no effect,  isn't it recorded?                     TryStatement parent = (TryStatement) node.getParent();                     parent.catchClauses().add(newCC);                 }                 return true;             }         });  A modification has no effect. So is it normal or a bug?
Add an icon adornment for default methods and annotation type elements with a default value.  The overlay for both will be a blue "D" with colors borrowed from native_co.gif / final_co.gif.
"Created attachment 229715 [details] TypeUnsafe class  Steps to reproduce  * using Eclipse Indigo SR2 or Eclipse Juno SR1  * compile the following code  ---------------------------------------------------------------------- import java.util.Collection;  public class TypeUnsafe { 	public static <Type, 			CollectionType extends Collection<Type>> 			CollectionType 			nullAsCollection(Class<Type> clazz) { 		return null; 	}  	public static void main(String[] args) { 		Collection<Integer> integers = nullAsCollection(String.class); 	} } ----------------------------------------------------------------------  Expected  * compilation *error* like the one below, produced by javac 1.7.0_09  ---------------------------------------------------------------------- TypeUnsafe.java:13: error: invalid inferred types for CollectionType; inferred type does not conform to declared bound(s)                 Collection<Integer> integers = nullAsCollection(String.class);                                                                ^     inferred: Collection<Integer>     bound(s): Collection<String>   where CollectionType,Type are type-variables:     CollectionType extends Collection<Type> declared in method <Type,CollectionType>nullAsCollection(Class<Type>)     Type extends Object declared in method <Type,CollectionType>nullAsCollection(Class<Type>) 1 error ----------------------------------------------------------------------  Observed  * code compiles without error or warning"
3.8.  Remove no longer used bundles from 'eclipse.jdt' repository: org.eclipse.jdt.macosx-feature org.eclipse.jdt.macosx.source-feature org.eclipse.jdt.macosx.source org.eclipse.jdt.macosx org.eclipse.jdt.source-feature org.eclipse.jdt.source  NOTE: Must also update root pom.xml if necessary.
"Our org.eclipse.jdt.ui.tests.refactoring.ExtractMethodTests#test803() fails in BETA_JAVA8 because the error recovery in the AST doesn't work any more and we don't get the AST we expect.  Source:  package error_in;  public class A_test803 { 	void m(String[] names) { 		/*[*/ 		for (String string : names) { 			System.out.println(string.); 		} 		/*]*/ 	} 	} }   In master, the method body is recovered down to the method argument ""string."". In BETA_JAVA8, the whole method body is just one recovered Block whose children are missing.  The additional '}' at the end doesn't make a difference."
N20130414-2000, broken since 4.3 M5. Works fine in 3.x, 4.2, and 4.2.x.  1. start new workspace 2. open 'Resource' perspective 3. open the main 'Run' menu ==> disabled 'Step Into Selection' menu item which should not be there.
This bug to be used to discuss and come up with changes that are required in Java model to support type annotations (JSR 308). At this point there is nothing critical or broken, but the requirement will be driven largely by the client.  If needed, raise separate bugs to track individual requirements.  Some of the things that may need correction are method signatures, type parameter signatures etc.
BETA_JAVA8:  Spawned from https://bugs.eclipse.org/bugs/show_bug.cgi?id=405066#c2  review comment 4.
"master and BETA_JAVA8  package xy; import javax.annotation.Generated; @Generated() class Try { }  Get the binding for @Generated and then call getAllMemberValuePairs() => NPE.  The problem is that Generated declares an array-valued ""String[] value();"" without a default, but the reference doesn't supply a value.  java.lang.NullPointerException 	at org.eclipse.jdt.core.dom.DefaultValuePairBinding.<init>(DefaultValuePairBinding.java:31) 	at org.eclipse.jdt.core.dom.AnnotationBinding.getAllMemberValuePairs(AnnotationBinding.java:98) 	at org.eclipse.jdt.astview.views.Binding.getChildren(Binding.java:232) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getChildren(ASTViewContentProvider.java:95) ..."
Created attachment 229839 [details] possible patch  If the JDT index manager rebuilds a pre-built index (see bug 395897) then it is saved in the index manager with a SAVE_STATE rather than REUSE_STATE.  If a single project in the workspace uses these indexes, and is then deleted, then the underlying index is also deleted.  A pre-built index (even if rebuilt by JDT) should never be deleted programmatically by JDT.
Created attachment 229840 [details] Test case to reproduce  See  java.io.@NonNull EOFException node in the attached test case using ast viewer:  thrownExceptions are converted to Name in ast level prior to 8. These nodes should have malformed flag set (somewhere) in case of presence of type annotations in the thrown exceptions.
"While navigating some code in the Scala IDE v3.0.0 for Eclipse 3.7, the following exception was reported by the Eclipse platform: ""Next Word"" did not complete normally. I believe this happened while pressing ""CMD + Right arrow"" on a dirty (i.e., not yet saved) editor. Unfortunately, I can't reproduce it.  I'm filing a ticket here and not the Scala IDE issue tracker because in the stacktrace (see below) there isn't any call that involves the Scala IDE codebase. That being said, the Scala IDE could still be in fault, because the Scala Editor is built on top of the Java Editor.  Below follows the full stacktrace  org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jface.text.Position.<init>(Position.java:62) 	at org.eclipse.jface.text.link.LinkedPosition.<init>(LinkedPosition.java:43) 	at org.eclipse.jface.text.link.LinkedPosition.<init>(LinkedPosition.java:58) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor$NextSubWordAction.findNextPosition(JavaEditor.java:806) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor$NextSubWordAction.run(JavaEditor.java:768) 	at org.eclipse.ui.texteditor.TextNavigationAction.runWithEvent(TextNavigationAction.java:99) 	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:185) 	at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:109) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:476) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:468) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:885) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:567) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:508) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:123) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1069) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4127) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1457) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1480) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1465) 	at org.eclipse.swt.widgets.Control.traverse(Control.java:4768) 	at org.eclipse.swt.widgets.Control.translateTraversal(Control.java:4552) 	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1058) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5563) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68) 	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:587) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5473) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2095) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2253) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5535) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:4989) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5138) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610) 	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701) 	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665) 	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499) 	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)"
"BETA_JAVA8: The fix for bug 405067 addressed only block bodies lambdas. Expression body lambdas will be handled as the topic of this bug.  At the moment the following program generates a verify error:  // --- interface I { 	String id(String s); } public class X { 	public static void main(String[] args) { 		I i = (s) -> s; 		System.out.println(i.id(""Hello"")); 	} }"
Attached test case says it all, but basically the "current" JDKs BinaryOperator<T> which extends BiFunction<T,T,T> without adding methods, gives an error since the single abstract method cannot be found during code generation, possibly since the superinterfaces aren't searched for the most specific match.
BETA_JAVA8:   The following program triggers an IncompatibleClassChangeError very likely due to the fact that ECJ at this point does not generate a synthetic bridge method to paper over signature differences.  // --------------- interface I {   void foo(int x, int y); } public class X {   public static void main(String[] args) {     BinaryOperator<String> binOp = (x,y) -> { return x+y; };      System.out.println(binOp.apply("SUCC", "ESS")); // when lambdas run\n" +   } } @FunctionalInterface interface BiFunction<T, U, R> {      R apply(T t, U u); } @FunctionalInterface  interface BinaryOperator<T> extends BiFunction<T,T,T> {  }
"Consider the below interface package p1;  public interface I1 {	 	 default int defaultMethod(){ 		 return 10; 	 }	 }  Invoke 'Refactor-> Extract Interface...' on I1. Select #defaultMethod to be part of the new interface. Click 'OK' button. In the newly created interface the method is created as abstract and in the original interface the method is removed. So basically the method implementation is lost after refactoring."
BETA_JAVA8:   This is spawned by splitting Bug 405068. I'll retain that bug for capture of locals from enclosing context and use the present one for enclosing instance capture as these two topics are unconnected and involve altogether different implementation concerns.  When this is resolved, we should also reenable the tests disabled via: eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=92dfd6c989831ab263c5667f92428e6c9943c027
When I'm trying to build p2.tests in my workspace. I get the following error.   Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.isDefinitelyUnknown(UnconditionalFlowInfo.java:814)
"BETA_JAVA8: -----------  The following program when compiled and run with branch head, produces:  Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception 	at java.lang.invoke.CallSite.makeSite(CallSite.java:298) 	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:294) 	at X.main(X.java:7) Caused by: java.lang.NullPointerException 	at java.lang.invoke.MethodHandleInfo.<init>(MethodHandleInfo.java:53) 	at java.lang.invoke.AbstractValidatingLambdaMetafactory.<init>(AbstractValidatingLambdaMetafactory.java:110) 	at java.lang.invoke.InnerClassLambdaMetafactory.<init>(InnerClassLambdaMetafactory.java:109) 	at java.lang.invoke.LambdaMetafactory.metaFactory(LambdaMetafactory.java:188) 	at java.lang.invoke.CallSite.makeSite(CallSite.java:283) 	... 2 more  ------------------  // -- interface I {     Object copy(int [] ia); }  class X  {     public static void main(String [] args) {         I i = int[]::<String>clone;         i.copy(new int[10]);     } }  // ---  Thanks to Andy Clement for reporting this."
"BETA_JAVA8:  For the ER described by the bug 406319, we need to reliably identify those  lambda methods that cannot be static. Presently the ""method can be static"" diagnostics and analysis still has some issues and can stand for further clean up: See that in the following program we don't suggest that foo could be static when in fact it could be:  // ----  public class X  { 	int f; 	void foo() { 		class Y { 			int p; 			{ 				class Z { 					int f = p; 				} 			} 		}; 	} }"
"(1) In the following program, foo is not tagged as can be static, while goo is. Both can be static:   // --- public class X  { 	int f; 	int foo() { 		int f = 0; 		return f; 	} 	int goo() { 		return 0; 	} }  // ---  Problem stems from the fact we do a look up for any existing f, to report hiding diagnostics. That look up is confused with a real field access.   (2) See that in the following program we don't suggest that foo could be static when in fact it could be:  // ----  public class X  { 	int f; 	void foo() { 		class Y { 			int p; 			{ 				class Z { 					int f = p; 				} 			} 		}; 	} }  Basically the analysis as is implemented is broken and I don't see any quick fixes. We can take solace that we are not meant to report  every possible candidate, but what we report should be correct."
Follow-up to bug 404489.  package jsr308.bug; public class X {     @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)     @interface Marker {     }      class Y {         class Z {         }     }      jsr308.bug.X.Y.Z z0;     jsr308.bug.@Marker X.@Marker Y.@Marker Z z; }                                  ^ The QualifiedType for Y here     ^ has a type binding for Z, but should be for Y, like its "name" child.  The PackageQualifiedType for X also has a type binding for Z. The qualifier of X has the correct package binding for jsr308.bug.
"BETA_JAVA8:   interface I { 	X [][][] copy (int x); } public class X  { 	public static void main(String[] args) { 		I i = X[][][]::new; 		X[][][] x = i.copy(136); 		System.out.println(x.length);                 |  // - no completion proposals here.		 	} 	 }"
Implement ASTRewrite for PackageQualifiedType. Duplicate and adapt the visit(QualifiedType) methods of ASTRewriteFlattener and ASTRewriteAnalyzer.
I suggest to use the foreach loop in ContentAssistProcessor. Patch to follow soon.
Created attachment 230101 [details] Test case to reproduce the issue  Use the attached testcase to open in ASTViewer, select the type parameter F to see the AST in the viewer.  ASTViewer bailed out with error message: "could not create ast, bad ast node structure".  This is due to incorrect source positions of the parent node if there are annotations.
We should propose the keywords even if there is no prefix. We already do this when outside a class but not when inside a class or method.
"BETA_JAVA8:  From bug 406388 comment 5:   // ---- interface I {     Object copy(); }  class X  {     public static void main(String [] args) {     	int [] x = new int[10];     	I i = x::<String>clone;         System.out.println(i.copy());     } } // ---- produces:  Exception in thread ""main"" java.lang.ClassFormatError: Invalid method signature in class X referenced from constant pool index 19 in method X.main([Ljava/lang/String;)V 	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2474) 	at java.lang.Class.getMethod0(Class.java:2715) 	at java.lang.Class.getMethod(Class.java:1622) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:555) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:537)  // -------------  javac is OK."
"BETA_JAVA8:  The following program should trigger an error about missing enclosing instance but doesn't:  // ---- interface I { 	X.Y makeY(); }  public class X { 	public class Y { 	} 	static void foo() { 		I i = Y::new; 	} }"
Can't see an existing bug for this (apologies if there is one!). This came up whilst working on JSR308 code generation.  For this code: ==== import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.CLASS) @interface B {     int value() default -1; }  class X {   @B(1) java.lang.String field; } ====  javac flags that 'nested type cannot be annotated'.  ECJ just lets it compile.  IIRC as of the current spec version it should be written 'java.lang.@B(1) String field' for a type_use annotation that is intended to apply to the String reference.
"BETA_JAVA8:  ECJ is not passing enclosing instance for inner class constructors. As a result, we get errors shown below for the program shown below:  ----- Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception 	at java.lang.invoke.CallSite.makeSite(CallSite.java:298) 	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:294) 	at X.foo(X.java:10) 	at X.main(X.java:15) Caused by: java.lang.invoke.LambdaConversionException: Incorrect number of parameters for static method newinvokespecial X$Y.<init>:(X)void; 0 captured parameters, 0 functional interface method parameters, 1 implementation parameters 	at java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:189) 	at java.lang.invoke.LambdaMetafactory.metaFactory(LambdaMetafactory.java:190) 	at java.lang.invoke.CallSite.makeSite(CallSite.java:283) 	... 3 more ----------  Program:  // ---- interface I { 	X.Y makeY(); }  public class X { 	public class Y { 	} 	 	void foo() { 		I i = Y::new; 		Y y = i.makeY(); 	} 	 	public static void main(String[] args) { 		new X().foo(); 	} }"
"BETA_JAVA8:  The following program prints X.foo, while it should actually print Y.foo  // ---- interface I { 	void foo(); }  class Y { 	void foo() { 		System.out.println(""Y.foo""); 	} } public class X extends Y { 	void foo() { 		System.out.println(""X.foo""); 	} 	void goo() { 		I i = super::foo; 		i.foo(); 	} 	public static void main(String[] args) { 		new X().goo(); 	} }"
"BETA_JAVA8:  I get a hint from the compiler that default method foo of I can be declared static. Default methods cannot be static.  // --- interface I { 	default int foo(int x, int y) { 		System.out.println(""I.foo("" + x + "","" + y + "")""); 		return 10; 	} }"
"BETA_JAVA8:  Given the program below, annotations on lambda parameters do not show up in the class file, despite the retention being runtime. Interestingly JDK 8b81 also has the same problem.   // ---- import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  interface I { 	void doit (Object o, Object p); }  public class X { 	I i = (@Annotation Object o, @Annotation Object p) -> { 		 	}; 	void foo(@Annotation Object o, @Annotation Object p) {         } }  @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @interface Annotation { 	 }  // ---  Problem is in org.eclipse.jdt.internal.compiler.ClassFile.generateMethodInfoAttributes(MethodBinding) - there is an expectation of AMD, which needs to be reconciled."
"BETA_JAVA8:   The disabled test org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest._test014() when run generates an AIIOB exception with this stack:   java.lang.ArrayIndexOutOfBoundsException: 1434 	at org.eclipse.jdt.internal.core.util.ClassFileStruct.u2At(ClassFileStruct.java:56) 	at org.eclipse.jdt.internal.core.util.BootstrapMethodsEntry.<init>(BootstrapMethodsEntry.java:33) 	at org.eclipse.jdt.internal.core.util.BootstrapMethodsAttribute.<init>(BootstrapMethodsAttribute.java:45) 	at org.eclipse.jdt.internal.core.util.ClassFileReader.<init>(ClassFileReader.java:277) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:239) 	at org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest.verifyClassFile(Jsr335ClassFileTest.java:51) 	at org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest.test014(Jsr335ClassFileTest.java:2027)"
"BETA_JAVA8:  The following program when run produces strange messages about Exception in thread ""main"" java.lang.NoClassDefFoundError:  notional  	at X.f(X.java:13) 	at X.main(X.java:9) Caused by: java.lang.ClassNotFoundException:  notional   This is because code generation is not in place for intersection casts.  // --  interface I { }  interface J { 	 } public class X implements I, J { 	public static void main( String [] args) { 		f(new X()); 	} 	 	static void f(Object o) { 		X x = (X & I & J) o; 	} }"
BETA_JAVA8:  We generate bad code that triggers a LCE for this program:  // --- interface I {     void foo(Integer a1, Integer a2, String a3); }  class Y {     static void m(Number a1, Object... rest) {          System.out.println(a1);         print(rest);     }     static void print (Object [] o) {         for (int i = 0; i < o.length; i++)             System.out.println(o[i]);     }      }  public class X {     public static void main(String [] args) {         I i = Y::m;         i.foo(10, 20, "10, 20");     } }
"BETA_JAVA8:   The following program triggers a verify error:   Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     X$Y$Z.f()V @7: invokedynamic   Reason:     Type 'X' (current frame, stack[0]) is not assignable to 'X$Y$Z'   Current Frame:     bci: @7     flags: { }     locals: { 'X$Y$Z' }     stack: { 'X' }   Bytecode:     0000000: 2ab4 000a b800 14ba 001d 0000 4cb2 001e     0000010: 2bb9 0024 0100 b600 2a2a b400 0ab8 0014     0000020: ba00 3200 004c b200 1e2b b900 2401 00b6     0000030: 002a b1                                  	at X.main(X.java:18)   // ---- interface I { 	String doit(); } public class X extends B { 	class Y { 		class Z { 			void f() { 				 				 I i = X.super::toString; // Verify error 				 System.out.println(i.doit()); 				 i = X.this::toString; // This call gets dispatched OK. 				 System.out.println(i.doit()); 			} 		} 	} 	 	public static void main(String[] args) { 		new X().new Y().new Z().f();  	} 	 	public String toString() { 		return ""X's toString""; 	} }  class B { 	public String toString() { 		return ""B's toString""; 	} }"
"BETA_JAVA8:   The following error is triggered by the program below:  Exception in thread ""main"" java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at X$Y.f(X.java:12) 	at X.main(X.java:25) Caused by: java.lang.IllegalAccessException: member is private: X.<init>(int)void/invokeSpecial, from X$Y 	at java.lang.invoke.MemberName.makeAccessException(MemberName.java:732) 	at java.lang.invoke.MethodHandles$Lookup.checkAccess(MethodHandles.java:1135) 	at java.lang.invoke.MethodHandles$Lookup.getDirectConstructor(MethodHandles.java:1243) 	at java.lang.invoke.MethodHandles$Lookup.linkMethodHandleConstant(MethodHandles.java:1270) 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:381) 	... 2 more   // --- interface I { 	X makeX(int x); } public class X { 	class Y extends X { 		private Y (int y) { 			System.out.println(y); 		} 		Y() { 		} 		void f() { 			I i = X::new; 			i.makeX(123456); 			i = X.Y::new; 			i.makeX(987654); 		} 	} 	private X(int x) { 		System.out.println(x); 	} 	X() { 	} 	 	public static void main(String[] args) { 		new X().new Y().f(); 	} }"
"Consider the following interfaces: I2 (having lambda expression) and I3 (having default and static methods).  Perform ""Extract Method"" refactoring on the lines with comments. We get exception and no refactoring is performed. It should be possible to extract methods in interfaces which would be created as default or static methods in those interfaces.  @FunctionalInterface public interface I1 { 	int foo(int a); }  interface I2 { 	I1 i1= (a) -> { 		int b= 10; // Exception on extracting to method 		return a + b; 	}; }  interface I3 { 	default int foo () { 		int a= 10; // Exception on extracting to method 		return a; 	} 	 	static int bar() { 		int a= 10; // Exception on extracting to method 		return a; 	} }"
Refer to bug 401040.  CBI produced ECJ contains META-INF/maven, which isn't necessary. The folder needs to be removed.
"The following test fails with a JavaModelException (does not exist) on #getParameterNames for binary types:  ASTParser parser = ASTParser.newParser(AST.JLS3); parser.setIgnoreMethodBodies(true); parser.setProject(javaProject); IType type = javaProject.findType(""TestEnum""); IBinding[] bindings = parser.createBindings(new IJavaElement[] { type }, null); ITypeBinding typeBinding = (ITypeBinding) bindings[0]; IMethodBinding[] methods = typeBinding.getDeclaredMethods(); for(IMethodBinding method: methods) { 	if (method.isConstructor()) { 		IMethod element = (IMethod) method.getJavaElement(); 		String[] parameterNames = element.getParameterNames(); 		// BOOM 	} }  The enum declaration:  public enum TestEnum {  	FirstValue(""Zonk"") { 		@Override 		public String toString() { 			return super.toString(); 		} 	}, 	SecondValue(""Bla""); 	 	String string; 	 	TestEnum(String string) { 		this.string = string; 	}  }  I can apply a local fix by using a handcrafted BinaryKey to obtain the enum constructor, e.g. use   String[] parameterTypes = Signature.getParameterTypes(   new BindingKey(""Lx;.x(Ljava/lang/String;ILjava/lang/String;)"").toSignature()); IMethod constructor = type.getMethod(name, parameterTypes);  The parameter types cannot be obtained from the BinaryMethod afterwards, since BinaryMethod.getParameterNames uses   // let's see if we can retrieve them from the debug infos char[][] argumentNames = info.getArgumentNames(); if (argumentNames != null && argumentNames.length == paramCount) {   String[] names = new String[paramCount];   for (int i = 0; i < paramCount; i++) {     names[i] = new String(argumentNames[i]);   }   return this.parameterNames = names; }  to read the param names from the debug information. The number of arguments in the info object is different from the number of arguments in the key. The paramCount == 3 but the argumentNames contain only a single entry ['string'] which is correct but fails to fulfil the condition."
Clean up APIs IField#getConstant() and IVariableBinding#getConstantValue().  These APIs are supposed to implement JLS7 4.12.4 and should return a non-null value iff the field is a constant variable.  Unfortunately, there's a bug in JLS7: It would also allow an instance field to be a constant variable. But this contradicts the JVMS7. I've sent a mail to the JLS maintainers to fix this.   Once the definition of "constant variable" is clear, our implementations and Javadocs should be adapted. Bugs I saw: - IVariableBinding#getConstantValue(): should return null for final instance fields - IField#getConstant(): should not return null for non-trivial initializers like "1<<8"   Test class:  package p;  public class B {     public static final int SFC = 1, SFC2 = 1<<8;     public final int IFC = 2;      public static final int SF = Integer.valueOf(-1).intValue();     public final int IF = Integer.valueOf(-2).intValue();      public static int SC = 3;     public int IC = 4;      public static int S = Integer.valueOf(-3).intValue();     public int I = Integer.valueOf(-4).intValue();      public static void main(String[] args) {         print(SFC);         print(SFC2);         print(SC);          print(SF);         print(S);          foo(new B());     }      private static void foo(B b) {         print(b.IFC);         print(b.IC);          print(b.IF);         print(b.I);     }      private static void print(int i) {         final int fi = i;         System.out.println(fi);     } }
"I was adding this lambda testcase as it didn't appear to be working for me when built with ECJ (I was adding it into LambdaExpressionsTest). It is *not* a finished test yet as the expected output is not right.  However, I accidentally ran it without 1.8 compliance and crashed ECJ.  public void test045() { 	this.runConformTest( 			new String[] { 					""C.java"", 					""import java.util.*;\n"" + 					""public class C {\n"" + 					""  public static <E> void printItem(E value, int index) {\n"" + 					""    String output = String.format(\""%d -> %s\"", index, value);\n"" + 					""    System.out.println(output);\n"" + 					""  }\n"" + 					""  public static void main(String[] argv) {\n"" + 					""    List<String> list = Arrays.asList(\""A\"",\""B\"",\""C\"");\n"" + 					""    eachWithIndex(list,C::printItem);\n"" + 					""  }\n"" + 					""  interface ItemWithIndexVisitor<E> {\n"" + 					""    public void visit(E item, int index);\n"" + 					""  }\n"" + 					""  public static <E> void eachWithIndex(List<E> list, ItemWithIndexVisitor<E> visitor) {\n"" + 					""    for (int i = 0; i < list.size(); i++) {\n"" + 					""         visitor.visit(list.get(i), i);\n"" + 					""    }\n"" + 					""  }\n"" + 					""}\n"" 			},""XXX""); }  During compilation of that:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.redeclaresPublicObjectMethod(MethodBinding.java:1211) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getInterfaceAbstractContracts(ReferenceBinding.java:1681) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getSingleAbstractMethod(ReferenceBinding.java:1733) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:494) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isCompatibleWith(TypeBinding.java:483) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4151) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:638) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:580) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1456) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1366) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2155) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:666) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1001) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:297) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:505) ...  I fixed it by changing:  Scope.parameterCompatibilityLevel  this bit (line 4151):  if (arg != param && !arg.isCompatibleWith(param.erasure())) 					return NOT_COMPATIBLE;  change that call to include the scope:  if (arg != param && !arg.isCompatibleWith(param.erasure(),this)) 					return NOT_COMPATIBLE;  and then the correct errors will come out:  		""1. ERROR in C.java (at line 3)\n"" +  		""	public static <E> void printItem(E value, int index) {\n"" +  		""	               ^\n"" +  		""Syntax error, type parameters are only available if source level is 1.5 or greater\n"" +  		""----------\n""  etc/etc. I will likely raise a separate issue for the lambda behaviour not working."
"Following on from bug 406846, once I got it compiling, this testcase (for LambdaExpressionsTest):  public void test045() {   this.runConformTest(     new String[] {       ""C.java"",       ""import java.util.*;\n"" +       ""public class C {\n"" +       ""  public static <E> void printItem(E value, int index) {\n"" +       ""    String output = String.format(\""%d -> %s\"", index, value);\n"" +       ""    System.out.println(output);\n"" +       ""  }\n"" +       ""  public static void main(String[] argv) {\n"" +       ""    List<String> list = Arrays.asList(\""A\"",\""B\"",\""C\"");\n"" +       ""    eachWithIndex(list,C::printItem);\n"" +       ""  }\n"" +       ""  interface ItemWithIndexVisitor<E> {\n"" +       ""    public void visit(E item, int index);\n"" +       ""  }\n"" +       ""  public static <E> void eachWithIndex(List<E> list, ItemWithIndexVisitor<E> visitor) {\n"" +       ""    for (int i = 0; i < list.size(); i++) {\n"" +       ""         visitor.visit(list.get(i), i);\n"" +       ""    }\n"" +       ""  }\n"" +       ""}\n""     },""XXX""); }  (expected output is not complete) It compiles but fails to run with:  junit.framework.AssertionFailedError: Unexpected error running resulting class file for C.java: --[START]-- java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at C.main(C.java:9) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:487) 	at ---[END]---  Same code works fine with javac (b81). Should produce the output:  0 -> A 1 -> B 2 -> C"
"BETA_JAVA8:   In the following program, the compiler hints the user that X.foo could be declared as static. This is wrong and will result in the code not continuing to compile:  // --- interface I { 	void foo(int i); } public class X { 	public static void main(String[] args) { 		X x = null; 		I i = x::foo; 		try { 			i.foo(10); 		} catch (NullPointerException npe) { 			System.out.println(npe.getMessage()); 		} 	} 	int foo(int x) { 		return x; 	} }"
"M6 and a bit, In  import org.eclipse.jdt.annotation.NonNull;  public class Test { 	boolean booleanFunction() { return true; } 	 	Boolean BooleanFunction() { 		@NonNull Boolean aBoolean = booleanFunction(); 		return aBoolean; 	} }"
"Not strictly a Java8 bug but it is a problem on BETA_JAVA8. Testcase (I had this in MethodVerifyTest):  Map compilerOptions16 = getCompilerOptions(); compilerOptions16.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, CompilerOptions.VERSION_1_6); compilerOptions16.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_6); compilerOptions16.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_6); this.runConformTest(   new String[] {     ""TestPointcut.java"",     ""interface MethodMatcher {\n""+     ""	boolean matches();\n""+     ""}\n""+     ""abstract class StaticMethodMatcher implements MethodMatcher { }\n""+     ""abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher { }\n""+     ""\n""+     ""class TestPointcut extends StaticMethodMatcherPointcut {\n""+     ""	@Override\n""+     ""	public boolean matches() { return false; } \n""+     ""}\n""   },   """",   null,   true,   null,   compilerOptions16,   null);  That code should not produce a warning for @Override but it does. It looks like some refactoring was done in MethodVerifier.computeInheritedMethods() in BETA_JAVA8 and the algorithm that collects up the super interfaces fails to collect 'MethodMatcher' in the above example (i.e. an interface on the superclass of the superclass of the class we are interested in).  Without knowing about that interface the @Overrides looks like an error.  I'll attach a patch in a moment containing the test and my fix (you may choose to fix it differently...)."
BETA_JAVA8:  We need to add support for JEP 118 & JEP 120 for Java 8.
The MethodParameters attribute must be recognized and correctly read by a class file reader in order to properly implement the Java SE platform class libraries (§2.12), if the class file's version number is 52.0 or above and the Java virtual machine implementation recognizes class files whose version number is 52.0 or above.
I20130430-2000.  The icons for ignored and assumption failed test should use the '/org.eclipse.jdt.ui/icons/full/ovr16/ignore_optional_problems_ovr.gif' decorator instead of crossing out the "normal" icon.
Generate the MethodParameters attribute into the attributes table of a method_info structure.
"package xy; public class CompletionTest { 	{ 		new File() 	} }  - put caret between () - press Ctrl+Space  => 4.3 M5a allowed me to choose a constructor proposal, press Enter, and then see context information. But now, I get a bunch of less interesting template proposals in front."
"With the automatic addition of ';' to void-returning method completion proposals, we don't show Context Information any more for such completions.  Example: Complete after ""wait"" here and choose a method with parameters:  package xy; public class CompletionTest { 	{ 		wait 	} }  The problem in this case is that JavaMethodCompletionProposal#computeContextInformation() needs another condition ""|| getReplacementString().endsWith(SEMICOLON)"".  Need to check other proposals as well."
Support the new PackageQualifiedType AST node from bug 404489 in JDT UI.  The node occurs when a type-use annotation is added to a package-qualified type. Before, such types were represented as SimpleType(QualifiedName).  See the explanations in the Javadoc of QualifiedType in BETA_JAVA8.
Created attachment 230399 [details] Fix  http://download.eclipse.org/eclipse/downloads/drops4/I20130501-2000/compilelogs/jdt.doc.isv.javadoc.txt has 7 warnings of this kind:  ../../../eclipse.jdt.ui/org.eclipse.jdt.ui/ui/org/eclipse/jdt/ui/wizards/NewPackageWizardPage.java:22: error: package org.eclipse.equinox.bidi does not exist import org.eclipse.equinox.bidi.StructuredTextTypeHandlerFactory;                                ^  The generated Javadoc is not affected, since the type is not used in an API.
"interface Foo {  	void run1(int s1, int s2); }  interface X extends Foo{ 	   static Foo f = (first, second) -> System.out.print(firs<ctrl-space>);     		 }  Code assist not making suggestion."
ASTRewritingTest should also support _since and _only on whole test class.   Currently, all tests in ASTRewritingTypeAnnotationsTest start with     if (this.apiLevel < AST.JLS8) return; , making it look like they also run on earlier AST levels.
1. In a Javadoc comment, type '@' and press Ctrl+Space. We can see tags like {@code}, {@link} etc in Default proposals. 2. Type a letter, say 'a'.  3. Press Backspace key to delete 'a'. We get the Default proposals but tags like {@code} are missing.
Although not documented in the JEP, the current EA javac supports generation of parameter names by option '-options' in javac. ECJ should follow this lead for now. There should be a distinct Java Code Generation option for this in the UI, too.
ASTRewrite testcases for QualifiedType need to be added to complete the list.
"1. Open a new workspace. 2. Go to File -> New -> Class. (Open any New type wizard). 3. Check ""Enclosing type"". 4. Press Ctrl+Space in the text field of Enclosing type. We get an exception in Error Log view.  org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63) .... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.ui.refactoring.contentassist.CUPositionCompletionProcessor.computeCompletionProposals(CUPositionCompletionProcessor.java:159)"
Bug 407383 creates the initial document with all the M1-M7 JDT items. Those items now need to be grouped, like in the past release [1]. Similar items need to be collapsed into one.   [1] http://help.eclipse.org/juno/topic/org.eclipse.jdt.doc.user/whatsNew/jdt_whatsnew.html
We need to update the F1 Help and the documentation to cover our new features.
In windows & linux OS the checked JRE is the one defined in eclipse.ini (see screen-cap), on MAC OS the JRE listed in eclipse.ini is not even one of the listed JREs, what is checked instead is the defined Default OS JRE (could be different Java version entirely than what is listed in eclipse.ini)
"public class Test { 	void foo(int i) { 		bar(i); 	} 	 	static void bar(Integer i) 	{ 		 	} }  The compiler throws up a incorrect warning message Null type safety: The expression of type int needs unchecked conversion to conform to '@NonNull Integer'  at the function call: bar(i).    Discussion: Well, that's cheating :) No, the compiler correctly recognized the need to perform a boxing conversion from int to Integer. The bug is real: after converting to Integer it *thinks* it must continue converting from plain Integer to ""@NonNull Integer"", but in fact the boxing conversion already provides ""@NonNull Integer"". There is no int value that would yield a boxed value of ""null"".  cheers, Stephan  On 05/07/2013 03:00 PM, Shankha Banerjee1 wrote: > Hi Stephan, > I modified the example a bit : > > *package*test2; > > *public**class*Test { > *void*foo(*int*i) { > /bar/(i); >          } > > *static**void*bar(*int*i) //*_Changed the argument type from integer to > int_* >          { > >          } > } > > The warning disappears. Could it be that the compiler is correct in > throwing up the warning since it thinks the argument is a Integer type. > > Thanks, > Shankha > > > > From: Stephan Herrmann <stephan.herrmann@berlin.de> > To: Shankha Banerjee1/India/IBM@IBMIN, Jayaprakash > Arthanareeswaran/India/IBM@IBMIN, > Date: 05/07/2013 06:18 PM > Subject: Re: Query on Null Analysis and suggested quick fix > ------------------------------------------------------------------------ > > > > Hi Shankha, > > this is an interesting bug. > > After I've done some work on properly including *unboxing* in > null analysis, here we have the case where *boxing* is not > correctly analyzed. The quick fix isn't really to blame, > its the warning that is bogus: boxing a primitive value > can never produce a null value. > > Please file a bug. > > @Jay, this isn't strictly a regression, but a genuine bug > that will become more and more relevant as people are starting > to jump on the train of null annotations. > Please let me know if I should attempt a fix for Kepler, which > *might* be a fairly easy tasks. Haven't look yet. > > Thanks, > Stephan > > > On 05/07/2013 07:44 AM, Shankha Banerjee1 wrote: >  > Hi Stephan, >  > I had the following test case with null analysis enabled. >  > >  > *package*test2; >  > *import*_org.eclipse.jdt.annotation.NonNull_; >  > >  > *public**class*Test { >  > *void*foo(*int*i) { >  > /bar/(_i_); >  >          } >  > >  > *static**void*bar(Integer i) >  >          { >  > *assert*(i != *null*); >  >          } >  > } >  > >  > >  > There also exists a package-info.java as part of the package: >  > @org.eclipse.jdt.annotation.NonNullByDefault(*true*) >  > *package*test2; >  > >  > We report a error >  > at >  > bar(i) >  > Null type safety: The expression of type int needs unchecked conversion >  > to conform to '@NonNull Integer' >  > >  > The Quick fix suggests the following fix: >  > ... >  > public class Test { >  > void foo(@NonNull int i) { >  > bar(i); >  > ... >  > >  > >  > After following the quick fix: >  > >  > The error thrown up is: >  > The nullness annotation @NonNull is not applicable for the primitive >  > type int >  > at void foo(@NonNull int i). >  > >  > Do you think it is a possible bug as the quick fix results in a error? >  > >  > Thanks, >  > Shankha > >"
Yearly pass to find and remove unused NLS strings in platform and JDT debug.
Created attachment 230737 [details] screen shot  There should be a space in the name of the debug target before the host:port information.  See screen shot.
"Created attachment 230786 [details] Source file that causes error when cleanup is applied  Greetings. The stack trace reproduced below is generated when I try to run a cleanup operation on the attached source file.   My cleanup function is configured to run these operations: Change non static accesses to static members using declaring type Change indirect accesses to static members to direct accesses (accesses through subtypes) Convert control statement bodies to block Convert 'for' loops to enhanced 'for' loops Add final modifier to private fields Add final modifier to local variables Remove unused imports Add missing '@Override' annotations Add missing '@Override' annotations to implementations of interface methods Add missing '@Deprecated' annotations Remove unnecessary casts Remove unnecessary '$NON-NLS$' tags Sort members excluding fields, enum constants, and initializers Organize imports Format source code Remove trailing white spaces on all lines Correct indentation   eclipse.buildId=4.3.0.I20130314-1330 java.version=1.7.0_21 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.classic.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.classic.product  Error Thu May 09 17:03:12 PDT 2013 Internal Error  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:502) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114) 	at org.eclipse.jdt.internal.ui.fix.CleanUpRefactoringWizard$CleanUpConfigurationPage.getNextPage(CleanUpRefactoringWizard.java:456) 	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:908) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:428) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:826) 	at org.eclipse.jface.window.Window.open(Window.java:802) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122) 	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38) 	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startCleanupRefactoring(RefactoringExecutionStarter.java:251) 	at org.eclipse.jdt.internal.ui.actions.AllCleanUpsAction.performRefactoring(AllCleanUpsAction.java:78) 	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:176) 	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:108) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1108) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:992) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:137) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:600) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: java.lang.IllegalArgumentException: Comparison method violates its general contract! 	at java.util.TimSort.mergeHi(TimSort.java:868) 	at java.util.TimSort.mergeAt(TimSort.java:485) 	at java.util.TimSort.mergeForceCollapse(TimSort.java:426) 	at java.util.TimSort.sort(TimSort.java:223) 	at java.util.TimSort.sort(TimSort.java:173) 	at java.util.Arrays.sort(Arrays.java:659) 	at java.util.Collections.sort(Collections.java:217) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250) 	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134) 	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455) 	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41) 	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) Root exception: java.lang.IllegalArgumentException: Comparison method violates its general contract! 	at java.util.TimSort.mergeHi(TimSort.java:868) 	at java.util.TimSort.mergeAt(TimSort.java:485) 	at java.util.TimSort.mergeForceCollapse(TimSort.java:426) 	at java.util.TimSort.sort(TimSort.java:223) 	at java.util.TimSort.sort(TimSort.java:173) 	at java.util.Arrays.sort(Arrays.java:659) 	at java.util.Collections.sort(Collections.java:217) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250) 	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134) 	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455) 	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41) 	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)"
And this results in problems, especially while processing annotations. Refer to bug 386901 for more details. The cause and the possible fix are discussed from bug 386901, comment #27 on.
Verified in I20130512-2000.  It misses the services and instead has the schemas in it. Plus, it has other useless/unexpected stuff in it.  Test Case: compare it with 3.8.2.
I20130512-2000.  ECJ download misses legal file (about.html).  This should be fixed for RC1 or RC2 at latest.
We need to add support for Java 8.  A starting point: http://mail.openjdk.java.net/mailman/listinfo/enhanced-metadata-spec-discuss
"Consider the following having lambda expressions: Class X and Interface I2. We get exception or incorrect refactoring by performing ""Extract Method"" refactoring on the lines with comments.  It should be possible to extract methods from a lambda expression, which would be created in its enclosing type.  @FunctionalInterface public interface I1 { 	int foo(int a); }  // Error: Extracted to m1() and placed in enclosing type.  // But replaced with ""m1();"" instead of ""int b= m1();"" class X { 	I1 i1= (int a) -> { 		int b= 10; // Error 		return a + b; 	}; 	 	class Y { 		I1 i1= (int a) -> { 			int b= 10; // Error 			return a + b; 		}; 	} 	 	void foo() { 		I1 i1= (int a) -> { 			int b= 10; // Error 			return a + b; 		}; 	} 	 	void bar() { 		Runnable r= new Runnable() { 			I1 i1= (int a) -> { 				int b= 10; // Error 				return a + b; 			}; 			 			@Override 			public void run() { 				I1 i1= (int a) -> { 					int b= 10; // Error 					return a + b; 				};				 			} 		}; 	} }  // see bug 406786 for Extract Method from lambda expr in interfaces interface I2 {	 	I1 i1= (int a) -> { 		int b= 10; // Exception on extracting to method 		return a + b; 	};	 }"
"Consider the example below:  @FunctionalInterface public interface I1 { 	int foo(int a); }  class X {	 	void foo() {	 		I1 i1= (int a) -> {return 10;}; // Extract lambda expr 		 		I1 i2= (a) -> {return 10;}; // Extract lambda expr 		bar(a -> 10); // Extract lambda expr 	} 	 	void bar(I1 i) { 	}  	// expected method after extraction 	I1 m() { 		return (int a) -> {return 10;}; 	} }  Try to extract only the lambda expr from the lines with comments to a method using Alt+Shift+M.   We get different error messages in above cases and it is not possible to extract the lambda expr to a method as shown in the expected method above."
"The erasure of a signature of a method has no type parameters. For example, if the following method declarations are added in a class a compiler error is generated. public <T>  String setArrayList(ArrayList<T> arrayList); 	public   String setArrayList(ArrayList arrayList);  The compiler error message, listed below, is not accurate: Method setArrayList(ArrayList) has the same erasure setArrayList(ArrayList<E>) as another method  Erasure of a method has no type parameters yet in the compiler error message the type parameter E is specified. The erasure of the first method is   public   String setArrayList(ArrayList arrayList);  The erasure of the second method is the same as the method declaration."
A common pattern when using proxies to serialize an object, is to place the "Externalize" class in a static inner class. For example:  private static final class ReceiptV1 extends Externalize {   public ReceiptV1(){}   public ReceiptV1(Receipt r){...} }  The externalization process requires a public no argument constructor. But the JDT complains that the public constructor is unused. You are then forced to add @SuppressWarnings("unused") to get rid of the warning.  The JDT should be doing the opposite when the class extends Externalize. It should give you a warning if the public no argument constructor is missing.
Created attachment 230978 [details] proposed fix  While looking at how the search works for bug 408059 I found that the search query checks twice to see if the wrapper class exists, when it should probably be testing if the properties file exists in the second check.
Version: 4.3.0 Build id: I20130513-2000  While scanning org.eclipse.jface I got the following during the search:  Undefined keys in: MenuManager.java - org.eclipse.jface.action (2 matches)  One of the matches is: ExternalActionManager.ICallback callback = ExternalActionManager.getInstance().getCallback();  with ExternalActionManager.ICallback highlighted. There are 17 of these flagged for all of jface.
"Since a lambda expression is like a method, it should be possible to extract local variables within its body.  Consider the following example and try to extract a local variable from the lines with comments, we get different error messages:  @FunctionalInterface interface FI { 	int foo(int a); }  public class TestExtractLocalVariable { 	FI fi1= (a) -> a + 10;	// Error 	 	FI fi2= (int a) -> {	 		int b= a + 10; // Error 		return b; 	}; 	 	void bar(FI fi) { 	     FI fi1= (a) -> a + 10; // Error, not extracted within lambda body 		 	     FI fi2= (a) -> {	 		    int b= a + 10; // Works here 		    return b; 	     };		 	}	 }"
"Perform Refactor > Extract Class... on the following example:  // comment public class Test { 	int i; }  We get this exception: java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) ... Caused by: java.lang.ClassCastException: org.eclipse.jdt.core.dom.CompilationUnit cannot be cast to org.eclipse.jdt.core.dom.TypeDeclaration 	at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractClassRefactoring.createParameterObject(ExtractClassRefactoring.java:479)"
When autocompleting for a method in a class, I am given the option to create a "Default constructor". However, this is incorrect. A default constructor is not something that a developer can create; per the JLS it's emitted solely by the compiler if one isn't provided in the source. The label should be "No-arg constructor" or "Empty constructor".
"Consider the following example and hover on ""a"" as mentioned in the comments:  public class C1 {	 	FI i1= (a) -> a++; // [1] Hover on ""a"" in ""a++"" 	void foo() { 		FI i2= (a) -> { 			return a; // [2] Hover on ""a"" 		}; 	} } interface FI { 	int f1(int a); }  We get these exceptions: [1] java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.util.Util.typeSignature(Util.java:2685) 	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:454) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1229)  [2] java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:187) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594)"
"Select foo() in the following example and open the Javadoc view:  public class Test { 	private void foo() {} }  Now, delete the method:  private void foo() {}  An error is logged in the Error Log view on deletion:  Java Model Exception: Java Model Status [foo() [in Test [in [Working copy] Test.java [in test.bugs.var [in src [in com.bugs.test]]]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:498) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:532) ... at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:600) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:495) 	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.getJavadocHtml(JavadocView.java:1097) 	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.computeInput(JavadocView.java:908)"
"public class Test {  }  Right click and select 'Refactor > Extract Interface' for the above class. Give some name for interface and click ""Preview"". Use down arrow button i.e. ""Select Next Change"".     It expands the 1st change node and ""Add super interface"" is selected. No input in the details page. Error is logged in the Error Log view:  org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.ltk.core.refactoring.TextChange.getCurrentContent(TextChange.java:334) 	at org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer.setInput(TextEditChangePreviewViewer.java:192) ..."
"import java.util.Arrays; import java.util.List;   public class TypeMistmatchIssue { 	static interface A { 	} 	static class B implements A { 	} 	static class C implements A { 	} 	static class D implements A { 	} 	 	void illustrate() { 		List<Class<? extends A>> no1= Arrays.asList(B.class, A.class);						// compiles 		List<Class<? extends A>> no2= Arrays.asList(C.class, B.class, A.class);				// compiles 		List<Class<? extends A>> no3= Arrays.asList(D.class, B.class, A.class);				// compiles 		 		List<Class<? extends A>> no4= Arrays.asList(D.class, C.class, B.class, A.class);	// cannot convert error !!!  		List<Class<? extends A>> no5= Arrays.asList(A.class, B.class, C.class, D.class);	// compiles 		List<Class<? extends A>> no6= Arrays.asList(A.class, D.class, C.class, B.class);	// compiles 	} }"
After checking a "compiler log" message tonight, to make sure the RC1 version was being used, I saw:   <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="bundle_qualifier, 3.9.0">  So, 1) copyright needs to be updated to include 2013, and   2) appears "bundle_qualifier" has broken, moving to Tycho build, I assume, but appears it was correct for M6 ... oh, maybe then we were still using "old" compiler, produced by PDE M5a?   log from M6 says  <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="v20130129-050623, 3.9.0">   a log from SM5a says:   <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="v20121208-144805, 3.9.0">
http://download.eclipse.org/eclipse/downloads/drops4/I20130518-1500/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html
Update JDT T&T document with relevant items from Kepler N&N documents.
Created attachment 231289 [details] Proposed ecj manpage  Many distributions package JDT core libraries, with an independent executable for ecj. Each of these must currently maintain a manpage, if they want one. Since it is unlikely that the documentation for ecj would differ widely across distributions, it would be great if this could instead be maintained upstream. Attached is proposed first cut, based on most current debian release but updated to reflect the output of -help (ie usage message) from eclipse compiler as of 4.2.1.
Created attachment 231292 [details] Shows the incorrect label text  In any "select documentation" dialog for Javadocs, the "file://" example only contains one forward slash ("file:/"), which is incorrect.  See similar bug 191965 (not a duplicate).  For convenience I have also included a screenshot.  JDT is 3.8.2 Eclipse Platform 4.2.1
Bug 331649 introduced the warning option JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS which is not yet supported at the command line of the batch compiler.
"Consider the following example and try to rename the variables mentioned in comments using ""Alt+Shift+R"":  @FunctionalInterface interface I { 	int foo (int x); }  public class C1 { 	I i= (int x) -> { // Unable to Rename ""x"" 		int p= 10; // Unable to Rename ""p"" 		I ii= (int a) -> a+100; // Unable to Rename ""ii"", ""a"" 		return ii.foo(x) + p; 	};  	void foo() { 		I i= (int x) -> x; // works here 	}	 }  We get the error, ""Only local variables declared in methods and initializers can be renamed"".   However, it should be possible to rename variables in any type of lambda expr also."
"Consider the following example and perform Refactor > Inline as per the comments:  @FunctionalInterface interface I1 { 	int foo(int x);	 }  public class X { 	public static final I1 a= (int x) -> x; 	 	void fun1() { 		int n = a.foo(0); // [1] Inline ""a"" => AFE	 		 		I1 i= (int x) -> { return x; }; // [2] Inline ""i"" 		I1 i1= x -> i.foo(x); // => Invalid inlining of ""i"" 		fun2(i); // => Valid inlining of ""i"" 	} 	 	void fun2(I1 i) {} }  [1] =>  java.lang.reflect.InvocationTargetException ... Caused by: org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.setFragment(ASTFragmentFactory.java:194) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.visit(ASTFragmentFactory.java:133) 	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:547) 	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:566) 	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:149) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2718) 	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:215) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.createFragment(ASTFragmentFactory.java:186) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.createFragmentFor(ASTFragmentFactory.java:115) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory.createFragmentForFullSubtree(ASTFragmentFactory.java:56) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitializer(InlineConstantRefactoring.java:789) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitialConditions(InlineConstantRefactoring.java:736) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83) ...   [2] => Results in: I1 i1= x -> (int x) -> { return x; }.foo(x); // => Invalid inlining of ""i"" fun2((int x) -> { return x; }); // => Valid inlining of ""i"""
"Consider the following example and apply the quick fix ""Add return statement"" on the lines with comments:  @FunctionalInterface interface I { 	int foo(int x);	 }  public class A { 	void fun1() { 		I i= (int x) -> { // [1] NPE on applying quick fix 			x++; 		};		 	} 	 	void fun2() { 		I i= (int x) -> { // [2] Incorrect result from quick fix 			x++; 		}; 		 		fun1(); 	} }  [1] => java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:132) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.evaluateReturnExpressions(MissingReturnTypeCorrectionProposal.java:154) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.getRewrite(MissingReturnTypeCorrectionProposal.java:113) 	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234) ...   [2] => Adds return statement to method fun2() instead of the lambda expression. Results in: 	void fun2() { 		I i= (int x) -> {  			x++; 		}; 		 		return fun1(); // Incorrect result 	}"
"Created attachment 231493 [details] fix  FUP to bug 403475, if you have a local type defined that executes a method with the same name as the enclosing method, HCR drops to the enclosing method.  Run the following snippet, add a change to LocalClass#run, save and notice two frames are popped. We shold be popping the top frame annd be back in LocalClass#run, instead we end up in TestHCR#run (the enclosing method).  package a.b.c;  public class TestHCR { 	 	public void run() { 		System.out.println(""LocalHCR#run()""); 		 		class LocalClass { 			public void run() { 				System.out.println(""LocalClass#run()""); //BP here 			} 		} 		new LocalClass().run(); 	}  	static class InnerClass { 		public void run() { 			System.out.println(""InnerClass#run()""); 			new TestHCR().run(); 		} 	}  	public static void main(String[] args) { 		System.out.println(""TestHCR#main()""); 		new InnerClass().run(); 	} }"
BETA_JAVA8:  This will be the umbrella bug for the code generation effort for JSR308. Please don't post patches here, high level discussions can be here, low level ER/CR specific discussion should be on the individual bugs.
BETA_JAVA8:  "If the compiler eliminates an annotated cast, it is required to retain the  annotations on the cast in the class file (if the annotation type has at least  RetentionPolicy.CLASS retention). When a cast is removed, the compiler may need  to adjust (the locations of) the annotations, to account for the relationship between the expression’s type and the casted-to type. Consider:" ...  At the moment ECJ is not in compliance here.
BETA_JAVA8:  This bug will be used to cover the loose ends discovered in code review of the core implementation of JSR308 code generation.  (1) Should TypeAnnotationCodeStream.invoke(byte, MethodBinding, TypeBinding,  TypeReference[]) be checking for ASTNode.HasTypeAnnotations ?  (2) Is ExtendedAnnotation violating javadoc of  IExtendedAnnotation.getLocalVariableTable() ?  (3)  CodeStream(s): Is the method CodeStream.newArray(TypeReference,  ArrayBinding) needed ?   (4) ClassFile.addFieldAttributes: Needs a relook. When a field declaration  carries a type annotation (or for that matter when a type annotation occurs in  any place where a Java SE5 annotation can occur, we leave it annotating the  declared entity - i.e the type annotation is not moved to the type.) So code  fragments like if (fieldType.bits & ASTNode.HasTypeAnnotations) != 0) may not  get executed at all. Until the resolve phase, we don't know whether an  annotation is a type declaration and so the HasTypeAnnotations bit cannot be set  in these places.  For concern 4, Andy's initial response is available at  https://bugs.eclipse.org/bugs/show_bug.cgi?id=383624#c54  I feel the suggestion to set the bit only during resolution is a good one.
Created attachment 231612 [details] Screenshot - 'default' in Extract Method dialog  As per JSR 335 Part H and bug 401223: "To avoid confusion with the default modifier, the access level given implicitly to unmodified declarations in classes is now referred to as package access rather than default access;"  The access modifier 'default' used in different dialogs related to methods (like Extract Method, Change Method Signature), could now be changed to 'package-access' or something else to avoid confusion with the modifier 'default' used to declare a default method.
This is a special consideration in the area of bug 390889:  Try to compile this class     public abstract class Foo<E> implements java.util.List<E> { }  using ECJ 4.3 against early access JRE 1.8 (b90). Result is:    Duplicate methods named spliterator with the parameters () and () are inherited from the types List<E> and Collection<E>  While Oracle says that this situation isn't and shouldn't be supported, Andy Clement has the details why this *is* an important use case for Eclipse.   I was surprised to learn that this works just fine using ECJ 4.3 M6 but produces the above error since M7. I had hoped to find a bug in one of the commits of M7, but my analysis is this:  The change is caused by the fix for bug 395681, but its impossible to pin point a particular problem in that fix because parts of the relevant method MethodVerifier15.checkMethods() have been essentially re-written, so direct code  comparison doesn't help much.  However, I see a simple and safe way of fixing the issue for now. I have a one-line patch in testing that simply prevents the application of one particular check against unexpected non-abstract methods in interfaces. Looking at MethodVerifyTest this already reduces the number of failures (when running on JRE 1.8), I'm currently looking for a way to make this test run green even on JRE 1.8.  I'll post a proposed patch in a little while.
BETA_JAVA8 and master  The "Add unimplemented methods" quick fix should not create stubs for default methods.  public class MyString implements CharSequence { }  => When compiling against a 1.8 JRE, the quick fix also adds stubs for chars() and codePoints(), which are new default methods in CharSequence.  "Source > Override/Implement Methods" already looks good (only selects abstract methods).
"According to Lambda specification ""Any local variable used but not declared in a lambda body must be definitely assigned  before the lambda body."" http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/B.html  Eclipse 4.3 permits assigning a local variable before a lambda expression within the lambda expression.  public class Sample{  interface Int { 		void setInt(int[] i);  	} public static void main(String[] args) {    int j; 		  		Int int1 = (int... i) -> { 			j=10; 		};  }  }"
Up to Java 7, every reference to a type had the same ITypeBinding, and the annotations could only come from the type's declaration. Now, reference type bindings can carry different TYPE_USE annotations, but this is not reflected in the ITypeBinding API.  We need to find the right solution to identify TYPE_USE annotation from ITypeBinding.
MoveInnerToTopLevelTests.test25 throws error during tearDown because it can't delete some resource.  test26 then probably fails due to this.   http://download.eclipse.org/eclipse/downloads/drops4/I20130602-2000/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html   Problems encountered while deleting resources.  Java Model Exception: Core Exception [code 566] Problems encountered while deleting resources. at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:175) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.PackageFragment.delete(PackageFragment.java:158) at org.eclipse.jdt.ui.tests.refactoring.RefactoringTest.tearDown(RefactoringTest.java:141) at org.eclipse.jdt.ui.tests.refactoring.MoveInnerToTopLevelTests.tearDown(MoveInnerToTopLevelTests.java:85) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Workspace.delete(Workspace.java:1441) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResources(JavaModelOperation.java:345) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.deletePackageFragment(DeleteResourceElementsOperation.java:53) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:110) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Workspace.delete(Workspace.java:1441) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResources(JavaModelOperation.java:345) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.deletePackageFragment(DeleteResourceElementsOperation.java:53) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:110) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.PackageFragment.delete(PackageFragment.java:158) at org.eclipse.jdt.ui.tests.refactoring.RefactoringTest.tearDown(RefactoringTest.java:141) at org.eclipse.jdt.ui.tests.refactoring.MoveInnerToTopLevelTests.tearDown(MoveInnerToTopLevelTests.java:85) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Contains: Could not delete '/TestProject1370245265306/src/A.java'. Contains: Could not delete 'C:\hb\workspace\ep4-unit-win32\workarea\I20130602-2000\eclipse-testing\test-eclipse\eclipse\refactoring_folder\TestProject1370245265306\src\A.java'.
IntroduceIndirectionTests.test31 fails with an error while deleting resources.  http://download.eclipse.org/eclipse/downloads/drops4/I20130602-2000/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html   Problems encountered while deleting resources.  Java Model Exception: Core Exception [code 273] Problems encountered while deleting resources. at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:175) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.CompilationUnit.delete(CompilationUnit.java:471) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helper(IntroduceIndirectionTests.java:122) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helperPass(IntroduceIndirectionTests.java:127) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.test31(IntroduceIndirectionTests.java:306) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Resource.delete(Resource.java:816) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResource(JavaModelOperation.java:331) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:107) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Resource.delete(Resource.java:816) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResource(JavaModelOperation.java:331) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:107) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.CompilationUnit.delete(CompilationUnit.java:471) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helper(IntroduceIndirectionTests.java:122) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helperPass(IntroduceIndirectionTests.java:127) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.test31(IntroduceIndirectionTests.java:306) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Contains: Could not delete 'C:\hb\workspace\ep4-unit-win32\workarea\I20130602-2000\eclipse-testing\test-eclipse\eclipse\refactoring_folder\TestProject1370245576152\src\p\Test.java'.
I20130531-2000.  PropertiesFileQuickAssistTest.testRemoveProperty3 and testRemoveProperty4 failed.  http://download.eclipse.org/eclipse/downloads/drops4/I20130531-2000/testresults/html/org.eclipse.jdt.ui.tests_macosx.cocoa.x86_5.0.html   nls file expected:<... static String Test_[]2; } > but was:<... static String Test_[1; public static String Test_]2; } >  junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]2; } > but was:<... static String Test_[1; public static String Test_]2; } > at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty3(PropertiesFileQuickAssistTest.java:641) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)   nls file expected:<... static String Test_[]5; public static...> but was:<... static String Test_[3; public static String Test_4; public static String Test_]5; public static...>  junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]5; public static...> but was:<... static String Test_[3; public static String Test_4; public static String Test_]5; public static...> at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty4(PropertiesFileQuickAssistTest.java:709) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
The Javadoc in javax.lang.model's package-info.java (in attached source) contains: "{@linkplain javax.annotation.processing annotation processing}"  The parsing of this link fails in JavaElementLinks#parseURI(URI) because the "if (element instanceof IPackageFragment)" branch only resolves types, but not packages. We should use the same code as in "if (element instanceof IType)" to resolve a link to package as well.  Also need to check whether the Javadoc tool supports links to members. If it does, then reuse that part of "if (element instanceof IType)" as well.  And last but not least, Javadocs of JavaElementLinks need to tell that refTypeName can also refer to a package.
Created attachment 231869 [details] Screenshot  In Refactoring wizards like Change Method Signature and Introduce Parameter Object, the Method signature preview for default methods does not show the default modifier. Attached the screenshot.
"Created attachment 231871 [details] Screenshot  Refactor > Introduce Indirection on default and static methods in an interface gives the error ""Cannot place new method on an interface."" as shown in the attached screenshot.  Expected result for the default method is shown below:   public interface I {  	public static void foo(I i) { 		i.foo(); 	}  	default void foo() {  	} }"
"Extracting Javadoc from Java-SE-7-style generated doc doesn't work reliably.   In some cases, only parts of the main description are shown (classes, enums, interfaces). In some cases (annotations, methods), there are unnecessary bullets.  Example:  package p;  import java.util.ArrayList; import java.util.List; import javax.annotation.Generated;  public class P { 	@Generated(value = { ""meee"" }) 	ArrayList<Integer> f = new ArrayList<>((List<Integer>) null); 	@Deprecated 	Thread.State s; 	{ 		s.equals(f); 	} }"
Created attachment 231928 [details] Video of the problem with autocompletion  If you have a method signature like this: StringTools.concatenateWithSeparator(String sep, String... input) Typing "," as seperator will not work as expected.  When you have typed ",  it will not write the comma out, but jump to next field. It also happens if you first type "" and then later want to add comma inside the String. It will not write comma out but jump to next field.  However sometimes when you try it the second time, it seems to work.  I have attached video of the problem  What it should do: When you are inside String delimiters, do not jump to next field on comma
"Created attachment 231968 [details] Screenshot  Consider the following example:  public interface I {  }  class X { 	static int get() { // Move 'get' 		return 0; 	} }  Refactor > Move on get(). We get Move Static Members wizard.  Select Destination type for get() as the interface I. Click Preview -> Error is shown as in the attached screenshot. Click Continue and then OK. Refactoring is completed without any compilation error.  The error in the Preview should not be shown."
Created attachment 232033 [details] Fix  schema.css is missing in /org.eclipse.jdt.doc.isv/build.properties since bug 396098. This makes the rendering of all JDT extension point docs ugly.
"public interface I {         default void foo(XYZ xyz) {	 	} }  class XYZ {}  Refactor > Move on method ""foo(XYZ)"". It brings up the ""Textual Move"" wizard.  Moving a default method is like moving an instance method, so Move Instance Method refactoring should be adjusted to handle it.  Default methods can be with/without a valid target type and we will have to retain or remove 'default' depending on the target type."
Created attachment 232043 [details] Fix  4.3.0.I20130605-2000, spawned from bug 409765  Some Javadoc extracted from generated html is rendered with bullets that don't make sense. The problem is the new Javadoc tool/stylesheet that is used since JDK 7. It generates <ul> tags that are set to "list-style:none;" via CSS.  I think the best fix is to include these CSS tweaks in our CSS.  The bullets are visible at the beginning of extracted methods, constructors, and fields, and at the end of class/interface Javadocs.
"BETA_JAVA8  CCE when trying to parse method reference expression with inappropriate type arguments:  //--------------------- package jsr335;  import java.io.Serializable; import java.util.concurrent.Callable;  public class MethodReference {     class Inner<E> {      }      void foo() {         Callable<Inner<String>> fi = MethodReference.Inner::<Serializable> new;     } } //---------------------  Note that the example doesn't make sense, and I didn't try to make it ""right"". Similar exceptions happen when I remove the <Serializable> or add type arguments after MethodReference.Inner.   java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:119) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.generateCode(LocalDeclaration.java:143) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:304) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:249) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:367) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1213) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
"interface I { 	private static void foo() { // Error [1] 	} 	 	private default void bar() { // Error [2] 	}	 }  [1]  'Remove invalid modifier' quick fix removes 'static' modifier also along with 'private'.   [2]  No quick fix is available.  The quick fix should be updated to handle static and default interface methods at ModifierCorrectionSubProcessor.addRemoveInvalidModifiersProposal(..)."
"public interface I1 { 	default void foo(int i) { // quick assist on 'i' [1] 		System.out.println(i); 	} 	 	static void bar(int i) {  // quick assist on 'i' [2] 		System.out.println(i); 	} }  Quick assist 'Assign parameter to new field' on 'i' as shown above, creates the following:  [1] private int i; default void foo(int i) { 	this.i = i; 	System.out.println(i); }  [2] private static int i; static void bar(int i) { 	I1.i = i; 	System.out.println(i); }  The modifier 'private' on newly created fields is incorrect. Also, fields in an interface are 'final' and cannot be assigned again in the method.  This leads to compilation errors."
Created attachment 232112 [details] Reduced Test Case  I know there other bugs related to this message (ie. 239639, 320965, 391528) but this issue deals with backward compatibility with JDK 1.4 'built' jars.  Steps to reproduce the problem:  1. Import the two projects from the attached zip J14 (1.4 level) J16 (1.6 level) 2. Export J14 as a jar 3. Bring up the properties for J16 and add the jar to its Java build path. 4. Open the Main class in J16 using the Java Editor --> You will see the errror message 5. If you run the Main class as a Java Application, it works as expected. This shows backward compatibility of 1.4 level jars.    The error message is misleading because the type/class is actually present in the jar.
"Created attachment 232173 [details] Class that compiles to different override behaviors between javac and eclipse (4.3RC3)  When compiling the attached java file using javac and eclipse 4.2, no compilation errors occur. Using Eclipse 4.3RC3 (4.3M6 also has this issue) gives a compilation error:  The type Main.SubSub must implement the inherited abstract method Main.Base<Main.F3>.foo(Main.F3)	Main.java(42)  Removing the 'abstract' keyword from the Main#Sub class also removes the compilation error, as does implementing a `foo(F3 f)` method. The Eclipse generated byte code results in different runtime behavior when compared to the output generated by the javac compiler.  An implementation of the foo(F3) method in the SubSub type (with the Sub type remaining abstract):   	@Override 	public void foo(F3 bar) { 		System.out.println(getClass().getSimpleName() + "": F3 + "" 				+ bar.getClass().getSimpleName()); 		bar.bar(); 	}  The expected result as given by javac/java      SubSub: F3 + F3     bar in F3     SubSub: F3 + F3     bar in F3     SubSub: F3 + F3     bar in F3     SubSub: F2 + F2  The result as given by the eclipse compiler:      SubSub: F3 + F3     bar in F3     SubSub: F2 + F3     SubSub: F3 + F3     bar in F3     SubSub: F2 + F2  As you can see the call to 'sub2.foo(f3);' performed in Main#main(), line 11 gives a strange result, whereas the call in line 12 does call the correct function (giving the expected result when compared to javac)  Commandline java version:  java version ""1.7.0_21"" Java(TM) SE Runtime Environment (build 1.7.0_21-b12) Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)"
Created attachment 232190 [details] Fix  4.3 RC4  In BETA_JAVA8 in org.eclipse.jdt.core.dom.ASTConverter, I tried to generalize a type reference "org.eclipse.jdt.internal.compiler.ast.LambdaExpression" to "org.eclipse.jdt.internal.compiler.ast.Expression".  The refactoring added an import for "Expression", although a homonym from the enclosing package org.eclipse.jdt.core.dom was already in use.
4.3 RC4.
4.3 RC4.
"The closing bracket hover after an ""else if"" should include all preceding ifs.  Example:  		if (i == 1) { 			int i1; 			int i2; 			int i3; 			int i4; 		} else if (i == 2) { 			new I1(); 			new I2(); 			new I3(); 			new I4(); 		} else {         // hover on ""}"" only shows one if, not both 			test1(); 			test2(); 			test3(); 			test4(); 		}                // hover on ""}"" shows all ifs     After bug 377141, the hover on the ""}"" of an ""else"" branch now shows all preceding ""if"" expressions. The same should be implemented for the ""}"" of an ""else if"" branch in the same ""if"" (... ""else if"")+ (... ""else"")? structure."
In Java source editors, the argument of an {@code *} or {@literal *} tag in Javadoc should not use "HTML markup" coloring.  E.g. "<String>" is not an HTML tag and should be rendered the same as "Set" here:   * {@code Set<String>}
- Create a package com.p1 and add the following annotation type in it:  package com.p1;  import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; i
http://download.eclipse.org/eclipse/downloads/drops4/I20130618-0800/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html  Although there is another failure reported with the same test via bug 399351, this failure is quite different from the previously reported one.  Stack trace:  zip file closed  java.lang.IllegalStateException: zip file closed at java.util.zip.ZipFile.ensureOpen(ZipFile.java:632) at java.util.zip.ZipFile.getInputStream(ZipFile.java:345) at java.util.jar.JarFile.getInputStream(JarFile.java:403) at org.eclipse.jdt.internal.core.index.JarIndexLocation.getInputStream(JarIndexLocation.java:89) at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:623) at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:199) at org.eclipse.jdt.internal.core.index.Index.query(Index.java:143) at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:310) at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2297) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:269) at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:109) at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:65) at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:277) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:214) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:844) at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:832) at org.eclipse.jdt.core.tests.model.JavaIndexTests.testPlatformJarIndexFile(JavaIndexTests.java:840) ...
The following code complains that the FileInputStream may leak. It is inside a try-with-resource statement therefore as far as I can tell this warning is erroneous.  ------------------------------------------ import java.io.FileInputStream;  class Bug {   void a(boolean b) throws Exception {     try(FileInputStream in = b ? new FileInputStream("a") : null){}   } }  --------------- Version: 4.3.0 Build id: I20130516-2200
We need to update the parent poms from 4.3.0-SNAPSHOT to 4.4.0-SNAPSHOT  PW
Created attachment 232557 [details] eclipse.jdt  We need to update the parent poms from 4.3.0-SNAPSHOT to 4.4.0-SNAPSHOT  PW
"import java.util.function.Function;  public class TestMethodRef {  	public static void main(String[] args) { 		Function<String, Integer> f = Integer::new; 	}  }  This is accepted by javac(of course, 8) but throw an error in my onw built BETA_JAVA8. From the semantics of lambda, it should be ok. Note, BETA_JAVA8 is a method ref, but not a method invocation.  This is so common, but we forget to implement it? Or, may I have a wrong build for BETA_JAVA8?  Anywhere, team, good work in these months!   thanks,  Jin"
In a project with 12000 jars in the classpath, resolveClasspath is taking more than 8 secs and in that more than 90% of time is spent on checking whether each library entry and it's source attachment is a file or directory.  Here is the call tree I captured with jProfiler.  8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath  8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath   8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath    8,548 ms org.eclipse.jdt.internal.core.JavaProject.addToResult     8,195 ms org.eclipse.jdt.internal.core.ExternalFoldersManager.isExternalFolderPath      7,548 ms java.io.File.isFile       7,548 ms java.io.UnixFileSystem.getBooleanAttributes        7,141 ms java.io.UnixFileSystem.getBooleanAttributes0  It's hitting us very badly, because we also use a classpath container to hold our jars and container classpath is resolved 8 to 10 times on UI thread while constructing the package explorer tree.  I am working on a patch to cache the external archives list (similar to nonChaineedJars) in JavaModelManager to avoid this repetitive I/O in resolve classpath and will soon attach it to the bug.
"package p; public class A { 	protected void m(){} }   package p; public class B { 	public void n(q.C c, A a) { 		a.m(); 	} }  package q; public class C {  }  When p.B.n(q.C, A) is moved to q.C, Eclipse move-refactoring pops up a warning message:  ""The visibility of method `p.A.m()' will be changed to public.""  When I click the `continue' button to finish the refactoring, p.A.m() is still `protected' (no changes).  That is an error."
If i do ctrl-shift-u on a identifier i get a list of lines in the search view where those are found. But the line numbers that are reported are 1 off. It does jump to the right line but it is funny to see that the search view reports "203:" and the actual code is according to the line of the ruler is on  204  It seems that the search view reports 0 based but the line number ruler starts with 1    Eclipse SDK  Version: 4.3.0 Build id: I20130605-2000
"With the save action ""Convert 'for' loops to enhanced 'for' loops"" enabled,  the conversion to enhanced loop might introduce a logical error.  Lets suppose you have an object ""s"" with a class implementing java.lang.Iterable and this class has also another method named ""iterator"", also with an ""Iterator"" return type, BUT with a __non empty signature__.  for (Iterator<Object> it = s.iterator(42) ; it.hasNext(); ) { 	Object obj = it.next(); 	// ... }  The save action will convert it to an enhanced loop assuming the use of ""s.iterator()"" instead of ""s.iterator(42)"" !  for (Object obj : s) {  	// ...		  }  (The bug exists also in 3.7.2 and probably in all releases until Kepler)"
"When JDT/Core will move up to 3.10.0 one of the regular expressions in export-ecj.xml will no longer work, see this snippet:  	<condition property=""bundleVersionOK""> 		<matches pattern=""\d\.\d\.\d.*"" string=""${bundleVersion}""/> 	</condition> 	<fail message=""bundleVersion variable had unexpected format. Should be digit.digit.digit,ANY but was ${bundleVersion}"" unless=""bundleVersionOK""/> 	<script language=""javascript""> 		var bundleVersion = project.getProperty(""bundleVersion""); 		var pattern = new RegExp(/^(\d+)\.(\d+)\.(\d+)\.(.*)$/);  the final pattern will work for 3.10.0, too, but the former will not, since it lacks the '+' tokens. Also the fail message could use improvement at that time.  BTW: when are we going to bump it up to 3.10.0?"
Created attachment 232751 [details] Stack trace  I noticed that when I saved a Java file, the UI would be come unresponsive for about 5 seconds.  I did a stack trace (attached) and noticed that the main thread seemed to be hung up somewhere in the project explorer.  When I unchecked "Link With Editor" this delay went away.  I tried doing the same action on the exact same workspace in Indigo and did not notice the same delay.  My workspace is very large (100+ projects, maybe 50-100K files).  I'm using: Version: 4.3.0 Build id: I20130605-2000
"If you are typing a floating point number say 3.14 then content assist window pops up after typing '.', e.g. in this situation below 	void bar() { 		System.out.println(3.); 	}  Tried this with 4.3 RC4. (Likely a consequence of changes for showing Template and keyword proposals without prefix)"
This is pretty similar to bug 380896 but the test case is slightly different -- the enum is declared in a separate file.   // file TestEnum.java enum TestEnum { FOO; }  // file NullTest.java public class NullTest {   public static TestEnum bla() {     @javax.annotation.Nonnull final TestEnum t = TestEnum.FOO; // Null type safety: The expression of type TestEnum needs unchecked conversion to conform to '@Nonnull TestEnum'     return t;   } }  Eclipse is configured to use 'javax.annotation.CheckForNull' for 'Nullable' annotation, 'javax.annotation.Nonnull' for 'NonNull' and the 'NonNullByDefault' is left unchanged. The annotations are as downloaded from http://code.google.com/p/jsr-305/ SVN.  Strangely enough, moving TestEnum to the same file as NullTest (as in the test case in bug 380896) makes the issue go away.  Eclipse SDK Version: 4.3.0 Build id: I20130605-2000
When I rerun a test by selecting "Run" from the JUnit test results view context menu the test launch is happening on the UI thread. When build before launch is enabled the project build is invoked on UI thread on Eclipse is frozen during the test launch process.  I am working on a patch to avoid it by delegating the rerun config launching to DebugUITools.launch() and will attach it to the bug soon.  A sample stack trace captured during the freeze is ...  java.io.UnixFileSystem.createDirectory(Native Method)                 java.io.File.mkdir(File.java:1239)                 java.io.File.mkdirs(File.java:1266)                 org.eclipse.core.internal.filesystem.local.LocalFile.mkdir(LocalFile.java:286)                 org.eclipse.core.internal.localstore.FileSystemResourceManager.write(FileSystemResourceManager.java:1132)                 org.eclipse.core.internal.resources.Folder.internalCreate(Folder.java:180)                 org.eclipse.core.internal.resources.Folder.create(Folder.java:107)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.createFolder(AbstractImageBuilder.java:470)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder$1.visit(AbstractImageBuilder.java:254)                 org.eclipse.core.internal.resources.Resource$1.visitElement(Resource.java:85)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:82)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.iterate(ElementTreeIterator.java:127)                 org.eclipse.core.internal.resources.Resource.accept(Resource.java:95)                 org.eclipse.core.internal.resources.Resource.accept(Resource.java:52)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.addAllSourceFiles(AbstractImageBuilder.java:219)                 org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:51)                 org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)                 org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)                 org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)                 org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)                 org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)                 org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:256)                 org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:394)                 org.eclipse.core.internal.resources.Project$1.run(Project.java:618)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)                 org.eclipse.core.internal.resources.Project.internalBuild(Project.java:597)                 org.eclipse.core.internal.resources.Project.build(Project.java:114)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate$1.run(LaunchConfigurationDelegate.java:423)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2326)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildProjects(LaunchConfigurationDelegate.java:430)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildForLaunch(LaunchConfigurationDelegate.java:126)                 org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:823)                 org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:704)                 org.eclipse.jdt.internal.junit.model.TestRunSession.rerunTest(TestRunSession.java:485)                 org.eclipse.jdt.internal.junit.ui.TestRunnerViewPart.rerunTest(TestRunnerViewPart.java:2062)                 org.eclipse.jdt.internal.junit.ui.RerunAction.run(RerunAction.java:52)                 org.eclipse.jface.action.Action.runWithEvent(Action.java:498)                 org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)                 org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)                 org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)                 org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)                 org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1276)                 org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3554)                 org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3179)
In JSE7 we have no way to figure out the nullness of a foreach element variable. Using type annotations this becomes (easily) possible, it just needs special treatment in the compiler since we don't have the AST that assigns the element variable.  See also this TODO in ForeachStatement.analyseCode():  " once we have JSR 308 fetch nullStatus from the collection element type   and feed the result into the above check (instead of FlowInfo.UNKNOWN)"
We get an compiler error with the following code (one file for each interface / class):  @NonNullByDefault public interface Foo<V> {   V bar(String... values); }  @NonNullByDefault public class FooImpl implements Foo<String> {   @Override   public String bar(final String... values) {     return ("");   } }  The compiler reports the following error for the class: "Illegal redefinition of parameter values, inherited method from Foo<String> does not constrain this parameter".  Adding a @NonNull to the "values" parameter in Foo helps, but generates a warning because of a redundant annotation.  In 4.2.2 it works fine.
I would like to be able to make it a warning if the throwable that is caught, is not used in the surrounding block.  e.g. This would be a warning try {     somethingDangerous(); } catch(Exception e) {    throw new RuntimeException(); }  but this would not try {     somethingDangerous(); } catch(Exception e) {    throw new RuntimeException(e); }  I have encountered many instances where they fail to pass in the exception as a cause, or fail to log it appropriately which makes debugging a headache.  If it were an optional warning, I would certainly have it enabled.
Links in Javadoc hover/view headers don't resolve fully-qualified types correctly.  Many examples can be found in org.eclipse.jdt.core.dom.ASTConverter, e.g. recordNodes(ASTNode node, org.eclipse.jdt.internal.compiler.ast.ASTNode oldASTNode).  The Javadoc tool generates title attributes like "class or interface in org.eclipse.jdt.internal.compiler.ast" for links to types. We could also generate titles, but we better just use "in <package>" syntax.
When an annotation is repeated, it should be emitted as part of its container annotation.
If the annotation processing supports it, enable accessing the decoded method parameter names during processing of annotations.
If a Repeatable annotation is present on an annotation declaration (T), semantics must be checked: Informally:  - The collections type's (TC) declaration must have a array of Ts as its value()  - The @Retention meta-annotation of TC must at least include the retention of T  - TC's @Targets, if specified, must be a subset or the same as T's @Targets  - If T is @Documented, then TC should also TC be Documented  - If T is @Inherited, then TC should also TC be @Inherited
The current check for duplicated annotations need a going over. If an annotation T is repeated at its use, it should be allowed, if:  - If the annotation declaration T has a Repeatable meta-annotation mentioning TC as the container  - if TC is allowed as the target where T is repeated  If T and TC is both used in the same context, it is an error (even if neither T nor TC is repeated)  Further, if TC is deprecated, a deprecation warning should be issued, even if T is not deprecated.  We should have a configurable warning if the multiple T's aren't contiguous.
Created attachment 233006 [details] Two classes that reproduce the bug  Please refer to the attached java files to reproduce this:  When calling a method with a @Deprecated annotation from within a lambda method, the JDT core crashes with the following Exception:  eclipse.buildId=4.4.0.I20130630-1602 java.version=1.7.0_25 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Command-line arguments:  -os linux -ws gtk -arch x86_64   Error Tue Jul 02 16:11:10 PDT 2013 Error in JDT Core during AST creation  java.lang.ClassCastException   Please note that this only happens if the deprecated method belongs to a different class than the one that contains the lambda.
"Created attachment 233034 [details] Source Code  Build 20130614-0229  Create a new project with the attached source code and enable the annotation based null analysis and suppress optional errors with @SuppressWarnings. IllegalArgumentException is thrown in ""XYZManagementDialog"" (both in incremental and clean build).  Disabling the null analysis or removing one of the instance fields resolves the error. I have other dialogs with the same hierarchy and more or less the same design where the problem does not occur so it may be caused by some sprecific field pattern.  Stacktrace: !ENTRY org.eclipse.jdt.ui 4 2 2013-07-03 14:45:58.710 !MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". !STACK 0 java.lang.IllegalArgumentException: info cannot be null 	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81) 	at org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:4561) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:3375) 	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1190) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:296) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:228) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:562) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:631) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:360) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1206) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:685) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1181) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Inspect all casts to and instance of checks for AbstractMethodDeclaration to eliminate potential CCEs" (when the operand of cast/instanceof is MethodScope.referenceContext)  This is a follow up of bug 412155 comment 3
Created attachment 233126 [details] Fix  While working on a regression test for bug 410207 I was puzzled why my test fails when I set compliance to 1.5 (expected without fix for bug 410207) but then surprisingly passes without any problem when I set compliance to 1.6. It turned out that "1.6" is not correctly transformed into compiler options inside AbstractJavaModelTests.createJavaProject(*). Unless there is a reason to ignore "1.6", it seems that all tests that use these helper methods with compliance "1.6" are tested with bad compiler options.
"Get git://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git BETA_JAVA8 and git://git.eclipse.org/gitroot/jdt/eclipse.jdt.ui.git master into Eclipse  Open new workspace Clone https://github.com/nurkiewicz/LazySeq. I used the CLI as I did not have then maven plugin at this time.  run mvn eclipse:eclipse compile (with the Java 8 EA) Create the library M2_REPO, point to ~/.m2/repository  Here is the tail of the stack trace  	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:75) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:100) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:75) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:100) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85)"
40 failures in Rename* tests.  Failed on a N-build [1] and on latest M-Build [2].   [1]http://download.eclipse.org/eclipse/downloads/drops4/N20130706-1500/testresults/html/org.eclipse.jdt.debug.tests_win32.win32.x86_7.0.html  [2] http://download.eclipse.org/eclipse/downloads/drops4/M20130703-0800/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html
N20130709-2000.  ResourceLeakTests.testBug381445_1b failed.  http://download.eclipse.org/eclipse/downloads/drops4/N20130709-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_linux.gtk.x86_6.0.html   Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in Bug381445.java (at line 8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed\n ----------\n ------------ but was ------------ ----------\n 1. ERROR in Bug381445.java (at line 15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type\n ----------\n --------- Difference is ---------- expected:<...81445.java (at line [8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed]\n ----------\n > but was:<...81445.java (at line [15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type]\n ----------\n >  junit.framework.ComparisonFailure: Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in Bug381445.java (at line 8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed\n ----------\n  ------------ but was ------------ ----------\n 1. ERROR in Bug381445.java (at line 15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type\n ----------\n  --------- Difference is ---------- expected:<...81445.java (at line [8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed]\n ----------\n > but was:<...81445.java (at line [15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type]\n ----------\n > at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:238) at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:214) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:873) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2285) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2120) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:1922) at org.eclipse.jdt.core.tests.compiler.regression.ResourceLeakTests.testBug381445_1b(ResourceLeakTests.java:4098) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
While compiling the Project mentioned in bug 412453 description. Will extract a small test case soon.
I believe there is an internal implementation for this - org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isFunctionalInterface(Scope)  See also bug 403749.
On the JREs preference page the only way you can tell if a JRE is contributed is if you select it and the 'Delete' button disables or you noticed the '(locked)' text in the label - which should probably be changed to '(contributed)'.   We should colour it the same way we do on other pages that show items that have been contributed - for example entries on the Classpath Variable page.
During the classpath validation first all the classpath entries are validated and then the validation status is not reported for the optional entries. Due to that when large number of optional entries existed on classpath a majority of portion is spent on their validation which is of no use.  In a project with 12000+ optional library jars, setRawclaasspath is spending  more than 90% of time on this unnecessary validation. Here is the call tree captured with a profiler ...  - 21,925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath  - 21,925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath   - 21,925 ms org.eclipse.jdt.internal.core.JavaModelOperation.runOperation    - 21,675 ms org.eclipse.core.internal.resources.Workspace.run     - 21,675 ms org.eclipse.jdt.internal.core.JavaModelOperation.run      - 21,675 ms org.eclipse.jdt.internal.core.SetClasspathOperation.executeOperation       - 20,500 ms org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged        - 20,376 ms org.eclipse.jdt.internal.core.ClasspathValidation.validate         - 20,214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry          - 20,214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry           - 19,978 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryEntry            - 13,461 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryContents             - 13,461 ms org.eclipse.jdt.internal.core.JavaModelManager.verifyArchiveContent              - 12,023 ms org.eclipse.jdt.internal.core.JavaModelManager.getZipFile               - 12,006 ms java.util.zip.ZipFile.<init>                - 5,511 µs org.eclipse.core.internal.resources.Workspace.getRoot                 - 5,439 µs org.eclipse.core.runtime.Path.toFile                  - 1,438 ms org.eclipse.jdt.internal.core.JavaModelManager.closeZipFile  I am working on a patch to avoid this unncessery validation and will send it across soon.
When I enable the conditional breakpoint checkbox, I often use the "Debugging by writing to console" trick from the JDT Tips & Tricks:    System.out.println("some info");   return false;  It would save some typing if the line    return false;  would already appear by default. This would also be a nice hint for new users that they should modify that expressions, since "return false;" is probably not the condition they actually need.
See bug 413067.
There is no (more) way "to create a Run/Debug Configuration for a Java  Project which contains "empty" Program Parameters." under windows.  From the commandline/shell (windows/linux) the parameter '""' would be parsed into an empty string as expected. Using the same argument in a Run/Debug Configuration (under Windows) you now get two double-quotes.  Maybe this bug(fix):  https://bugs.eclipse.org/bugs/show_bug.cgi?id=387504  ... reintroduced two old bugs:  https://bugs.eclipse.org/bugs/show_bug.cgi?id=24260 https://bugs.eclipse.org/bugs/show_bug.cgi?id=70955
N20130721-2000.  http://download.eclipse.org/eclipse/downloads/drops4/N20130721-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_linux.gtk.x86_6.0.html   Unexpected error output for invocation with arguments ["/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java" -extdirs "" -1.5 -g -preserveAllLocals -proceedOnError -referenceInfo -d "/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression" ]. ----------- Expected ------------ ----------\n 1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error) ------------ but was ------------ ----------\n 1. ERROR in /opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n --------- Difference is ---------- expected:<...-----\n 1. ERROR in [---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)]> but was:<...-----\n 1. ERROR in [/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n ]>  junit.framework.ComparisonFailure: Unexpected error output for invocation with arguments ["/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java" -extdirs "" -1.5 -g -preserveAllLocals -proceedOnError -referenceInfo -d "/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression" ]. ----------- Expected ------------ ----------\n 1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error) ------------ but was ------------ ----------\n 1. ERROR in /opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n  --------- Difference is ---------- expected:<...-----\n 1. ERROR in [---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)]> but was:<...-----\n 1. ERROR in [/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n ]> at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:238) at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:214) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runTest(BatchCompilerTest.java:635) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runNegativeTest(BatchCompilerTest.java:463) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.test024(BatchCompilerTest.java:2550) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
4.3.  When having the jdt.debug tests installed, VMInstallTests destroys error reporting because AbstractDebugTest sets ErrorDialog.AUTOMATED_MODE = true when the library location resolvers is loaded.
"REPRODUCING THE PROBLEM: Create a workspace with two java projects. In the Java-Compiler ""Errors/Warning"" -settings turn on ""enabled annotation-based null-analysis"".  Put the following Class into the first project:  import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class Class2 { 	public Class2(String nonNullArg) { 		assert nonNullArg != null; 	}  	public static Class2 create(String nonNullArg) { 		return new Class2(nonNullArg); 	} }  Now create this class in the other project, configure the build path settings.  public class Class1 { 	public static Class2 works() { 		return Class2.create(null); 	}  	public static Class2 bug() { 		return new Class2(null); 	} }  Do a clean build.  PROBLEM: If you open Class1 in the editors, you will see two warnings, but in the problems view, there will be only one warning for ""works"", but no warning in ""bug"".  ANALYSIS: When compiling for the editor, Class2 is accessed via a SourceTypeBinding, and org.eclipse.jdt.internal.compiler.lookup.MethodBinding.parameterNonNullness is initialized in both cases. The compilation for the ""problems view"" accesses Class2 as BinaryTypeBinding.  In BinaryTypeBinding, there is code to inherit the nullness-settings in  org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanFieldForNullAnnotation(IBinaryField, FieldBinding) and org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanTypeForNullDefaultAnnotation(IBinaryType, PackageBinding, BinaryTypeBinding), but not for methods in org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanMethodForNullAnnotation(IBinaryMethod, MethodBinding).  It still works for the ""Class2#create"" invocation from ""Class1#works"", because org.eclipse.jdt.internal.compiler.lookup.MethodBinding.parameterNonNullness is initialized in org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(BlockScope) with ImplicitNullAnnotationVerifier. The corresponding code in org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(BlockScope) seems to be missing. Adding it like in the following patch makes the warnings appear in the problems view.   diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java index 2f4b127..5319d9e 100644 --- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java +++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java @@ -28,6 +28,7 @@  import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;  import org.eclipse.jdt.internal.compiler.codegen.*;  import org.eclipse.jdt.internal.compiler.flow.*; +import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;  import org.eclipse.jdt.internal.compiler.impl.Constant;  import org.eclipse.jdt.internal.compiler.lookup.*;  import org.eclipse.jdt.internal.compiler.problem.ProblemReporter; @@ -435,6 +436,11 @@  	if (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {   		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);   	} +	final CompilerOptions compilerOptions = scope.compilerOptions(); +	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) { +		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations) +				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope); +	}  	return allocationType;  }"
"The AST for a multi-dimensional array type with annotations on the array dimensions is not well-formed. The problem is that for ArrayType nodes, the linearization of the AST (i.e. the source order of AST nodes) doesn't correspond to the language model. This is a new problem, not bug 403834 or bug 391894 comment 4.  Example:  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented @interface A { 	int value() default 0; }  public class TestArrayAnnotations { 	@A(3) String @A(1)[] @A(2)[] arr = 			new @A(3) String @A(1)[11] @A(2)[12]; }  The AST node for the type of field 'arr' is:  ASTNode type/property  Source range ---------------------  --------------------------------- ArrayType              String @A(1)[] @A(2)[] +annotations                          @A(2) +componentType         String @A(1)[]  +annotations                 @A(1)  +componentType        String   +name                String  The problem is that this componentType is just a parsing artifact, but it doesn't make sense from a semantic point of view. As http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#array-syntax explains, the type nesting in the language model is actually going like this:  ArrayType        @A(3) String @A(1)[] @A(2)[] +annotations                  @A(1) +componentType   @A(3) String         @A(2)[]  +annotations                         @A(2)  +componentType  @A(3) String   +annotations   @A(3)   +name                String  As long as nobody could actually distinguish the different array brackets, we could live with that. I.e. it usually doesn't matter whether the component type of String[][] is String[] with the first or with the second set of brackets.  But as soon as we add annotations, the picture changes. With the current AST node structure, it's e.g. impossible to implement bug 409586 correctly, because the top-level ArrayType's annotation is ""@A(2)"", but the binding of the top-level ArrayType must have annotation ""@A(1)"", because that's the annotation on the outermost array brackets.  The type ""String @A(1)[]"" doesn't exist from a language point of view, because the annotation ""@A(1)"" annotates the type String[][], not a String[].  The only way I see how we could reconcile AST nodes and bindings would be to replace the nestable ArrayType by a FlatArrayType node with these properties: +componentType: Type (cannot be another FlatArrayType) +dimensions: List<ExtraDimension>  Then, the binding of the FlatArrayType would be identical to the binding of the leftmost dimension."
Bug 366014 added support for automatically configuring projects for the use of null annotations. For plug-in projects it inserts an additional.bundles stanza into build.properties.  I never fully understood the effect, but today I ran my first headless PDE-build on a bundle with null annotations, which failed due to bug 354724. If I understand that bug correctly, it is actually a "works-as-designed":    "The fact that PDE Build does not consider the additional.bundles property can lead     to a slightly different issue.  The property is not intended to add anything to the    build classpath, but instead allow the workspace to build when there are indirect    dependencies.  Another bundle should be adding the additional bundle as a real    (manifest) dependency."  Thus I propose to change the mechanism from bug 366014 (and the documentation) to use an optional import instead (I tried Require-Bundle, which worked, not sure if Import-Package would work and be more appropriate, or not).  As an extra data point I may want to check if/how tycho interprets these settings ...
"On extracting a default method in an interface [WIP, bug 406786], the new extracted default method is not formatted.	  For example, selecting ""return 0;"" and extracting it to a method:  interface A_test1 { 	default int foo() { 		return 0; // extract to method 	} }  Results in:  interface A_test1 { 	default int foo() { 		return extracted(); // extract to method 	}  	default int extracted(){return 0;} } -------------------------------------------  However, standalone formatting (Ctrl+Shift+F) of the above created default method works properly. Select ""default int extracted(){return 0;}"". Pressing Ctrl+Shift+F, results in:  	default int extracted() { 			return 0; 	} ------------------------------------------  On debugging, it was found that the 'kind' passed to DefaultCodeFormatter.format(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator) is K_COMPILATION_UNIT in stand-alone case (via org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format()).   And, the 'kind' is K_CLASS_BODY_DECLARATIONS (for MethodDeclaration via ASTRewriteFormatter.formatNode(ASTNode node, String str, int indentationLevel)) where it does not work. 	 In the latter case, in DefaultCodeFormatter#formatClassBodyDeclarations(..), parseClassBodyDeclarations(..) returns null. So it could be that parser encounters some error and hence further formatting is not done."
http://www.eclipse.org/jdt/apt/introToAPT.php  Follow the instructions in the given page to create a test project with annotation processing enabled. Use the demo APT provided in the same page and create the following test file:  import demo.DemoAnnotation; @DemoAnnotation(what = "spam") public class DemoAnnotationTest { }  With APT enabled, spam" should be reported by the APT and it is reported when the project's compliance level is set to 1.7. However, the same behavior can't be seen when the compliance of the project is set to 1.8. At this point, I don't know what is causing this and whether or not the APT is kicked of at all. Log file shows nothing.
APT currently handles only SE7 annotations and new code has to be added for annotations in SE8 locations, such as receiver, type use etc.  I believe AnnotationDiscoveryVisitor should be updated to provide support for new annotatable AST nodes. This needs further investigation, though.
N20130727-1500.  Error and Failure in HcrTests.  http://download.eclipse.org/eclipse/downloads/drops4/N20130727-1500/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html
The ASTParser has various problems where it generates wrong source ranges with nontrivial annotations. While investigating these problems I found the problem with the wrong nesting of ArrayType nodes (bug 413569).  The problem is that various ASTConverter#retrieve*(..) methods make wrong assumptions about the possible form of annotations. E.g. retrieveExtraDimension(..) and retrieveEndOfElementTypeNamePosition(..) assume they can just skip "@AnnotationName", but that strategy fails as soon as the annotation has arguments. retrieveProperRightBracketPosition(..) and its callers also use a similarly doomed strategy in trying to find the brackets of an array type starting from the beginning of the array type.  The loops in the retrieve*(..) methods should only skip over TokenNameCOMMENT_* tokens, and otherwise give up when they encounter an unknown token id.  The strategy should not be to scan over annotations, but to use the annotation nodes' source ranges to update the start position and then only scan for the brackets after the annotation node.   Test case with all kinds of problems (but syntactically correct):  public class ArrayTypeAnnotations extends @NonNull(int[].class) Object {     Object field = new ArrayList< @NonEmpty(Bla) int @NonNull(Bla) [] @NonEmpty(Blu) [ ]>() ;          int[][] xxx;     ArrayList<int[]> [][] yyy; // source ranges already broken in AST.JLS4     ArrayList<int[][]> [][][][] zzz;     ArrayList<Float> [][][] zzz2;     Object a = new ArrayList< @TakeType(int[].class) int @TakeType(float.class) [] @TakeType(double.class) []>() ;     Object b = new @NonNull(Math.PI) ArrayList< >() ;     Object c = new ArrayList<@NonNull(Math.PI) Object[]>() ;      void foo(int i) {         for (String tab@TakeType(int[].class) [] = null;; ++i) { break; }         for (@Deprecated String tab@TakeType(int[].class) [][]  = null;; ++i) {}     } }
"The overridden function icopy() is not able to convert to the extended Generic type.This however compiles clean in Indigo. Description	Resource	Path	Location	Type Type mismatch: cannot convert from ReadOnlyWrapper<TestA,TestB> to WritableWrapper<TestA,TestB>	TestGenerics.java	/TestGenerics/src	line 8	Java Problem  ------- public class ReadOnlyWrapper<A extends TestA, B extends TestB> {      protected A a;     protected B b;      public ReadOnlyWrapper(A ax,B bx){         this.a = ax;         this.b = bx;     }      public <X extends ReadOnlyWrapper<A,B>> X copy() {         return (X) new ReadOnlyWrapper<A,B>(a,b);     }      public <TA extends TestA,TB extends TestB,X extends ReadOnlyWrapper<TA,TB>> X icopy() {         return (X) new ReadOnlyWrapper<A,B>(a,b);     }       public A getA() {         return this.a;     }     public B getB() {         return this.b;     }  }  ---------   public class WritableWrapper<A extends TestA, B extends TestB> extends ReadOnlyWrapper<A, B> {        public WritableWrapper(A ax,B bx){         super(ax,bx);     }      @Override     public <X extends ReadOnlyWrapper<A,B>> X copy() {         return (X) new WritableWrapper<A, B>(a,b);     }      @Override     public <TA extends TestA,TB extends TestB,X extends ReadOnlyWrapper<TA,TB>> X icopy() {         // Works in Indigo, Fails in Kepler         return (X) new WritableWrapper<A,B>(a,b);     }      public void setA(A ax) {         this.a = ax;     }     public void setB(B bx) {         this.b = bx;     }  } --------    public class TestGenerics {     public static void main(String [] args) {          final WritableWrapper<TestA, TestB> v1 = new WritableWrapper<TestA, TestB>(new TestA(), new TestB());         final WritableWrapper<TestA,TestB> v2 = v1.copy();         final WritableWrapper<TestA,TestB> v3 = v1.icopy(); // does not compile in kepler, compiles in Indigo,Intellij...      }  }"
With the changes in bug 352626 the launch config API has been generified and JDT debug uses some of it.  This bug is to make sure I update to use it.
Somewhere during the implementation of bug 322817, the very important restriction "due to raw APIs" went missing from the documentation: The API name, API Javadoc, UI option name, and parts of the help documents at most mention raw types as part of an example. "Due to raw APIs" needs to be added as a necessary restriction of "unavoidable".  The goal of this option is not to suppress all generic type problems that can happen because the Java language has erasure-based generics. Users should still have to add @SuppressWarnings("unchecked") where type safety is at risk and cannot be checked locally.  The option was added to help in the transition phase where 1.5 projects refer to pre-1.5 APIs. The goal is to avoid a flood of @SuppressWarnings("unchecked") annotations that have to be removed as soon as raw APIs get generified (i.e. type arguments are added to raw types).  Problems are only considered "unavoidable" if they will disappear as soon as the raw API is generified. At that point, the reference will either: - not produce an "unchecked" warning any more (expected case), or - produce a compile error because the client's guess about the correct type arguments was wrong (not expected)  A compiler option that suppresses more problems than that would be unsafe and would go against the spirit of the mandatory "unchecked" warning (JLS7 5.1.9).
"Created attachment 233952 [details] Test case to reproduce the issue  Stack Trace:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.Annotation$TypeUseBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.FieldBinding 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:713) 	at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:281) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1474) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:775) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:753) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:757) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"While running the test suite on Windows on I20130730-0800 I got the following exception in the console:  java.util.ConcurrentModificationException 	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:819) 	at java.util.ArrayList$Itr.next(ArrayList.java:791) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.removeAllBreakpoints(JDIDebugTarget.java:1567) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.cleanup(JDIDebugTarget.java:1526) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.terminated(JDIDebugTarget.java:1493) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.handleVMDeath(JDIDebugTarget.java:1001) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:158) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Consider the below code: 	interface test{ 		public void m1(){ 	} For m1(), currently user is provided with a single Quick Fix proposal which will remove the body of the method. Ideally from Java 1.8, the method can be either default or static, hence we need to provide 2 new proposals here. The Quick Fix proposals will be: 1. Remove method body 2. Add 'default' modifier 3. Add 'static' modifier"
"interface A_test109 { 	int i = foo(); // Error 	default int foo() {} }  The quick fix: ""Change modifier of 'foo()' to 'static'"" in the above example for compilation error: ""Cannot make a static reference to the non-static method foo() from the type A_test109"", produces the following result:  interface A_test109 { 	int i = foo(); 	default static int foo() {} }  The 'default' modifier should be replaced with 'static'."
"interface A_test109 { 	int i = foo(); // Error 	default int foo() { 		return 0; 	} }  Add a breakpoint in method: org.eclipse.jdt.internal.ui.text.correction.ModifierCorrectionSubProcessor#addNonAccessibleReferenceProposal(..)  Hover on the error in the above example.  The method binding for 'selectedNode' (case: ASTNode.SIMPLE_NAME) contains 'abstract' modifier instead of 'default'."
"public interface A_test1 { // creates default methods without body 	int i= aaa();  	 	default void defaultM() { 		int a= bbb(); 	} 	 	static void staticM() { 		int x= ccc(); 	} }  interface A_test2 { // creates static method without body 	int i = foo1(); 	static int foo() {return 0;} }  interface A_test3 { // creates abstract method 	int i = foo2(); } ------------------------------------------------------------- In the above example, 'Create method' quick fix creates incorrect methods as given below:  public interface A_test1 {	// creates default methods without body 	int i= aaa();  	 	default void defaultM() { 		int a= bbb(); 	} 	 	default int bbb();  	default int aaa();  	static void staticM() { 		int x= ccc(); 	}  	default int ccc(); }  interface A_test2 { // creates static method without body 	int i = foo1(); 	static int foo() {return 0;} 	static int foo1(); }  interface A_test3 { // creates abstract method 	int i = foo2();  	int foo2(); } ------------------------------------------------------------- It should not create an abstract method in any case. Also, we should check if a default or a static method has to be created and create the correct method with body accordingly."
"On a system with large RAM, the following error is logged when I start a 64-bit Eclipse using a 64-bit JRE and open the ""Plug-in development"" perspective. > Error > Fri Aug 02 10:44:03 CEST 2013 > Failed to retrieve default libraries for /proj/CoolTools/app/JRE/jre-7u25-linux-x64  This error is logged by org.eclipse.jdt.internal.launching.StandardVMType.generateLibraryInfo method, which starts a native process in order to obtain JVM properties. Using strace I was able to find out that it runs the following command: > /proj/CoolTools/app/JRE/jre64/bin/java -classpath /home/ekalmik/.eclipse/org.eclipse.platform_4.3.0_1947859192_linux_gtk_x86_64/configuration/org.eclipse.osgi/bundles/262/1/.cp/lib/launchingsupport.jar org.eclipse.jdt.internal.launching.support.LibraryDetector ... and gets the following results: > Error occurred during initialization of VM > Could not reserve enough space for object heap > Error: Could not create the Java Virtual Machine. > Error: A fatal exception has occurred. Program will exit.  Indeed, when I run the same command in shell, I observe the same behaviour. However, if I add -Xmx64m directly after the name of executable, I get correct data. > 1.7.0_25|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/resources.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/rt.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/sunrsasign.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jsse.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jce.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/charsets.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jfr.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/classes|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/ext:/usr/java/packages/lib/ext|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/endorsed  I've also verified that if I start the same Eclipse using a 32-bit JRE on the same system, no errors are printed. Of course, running the command above using a 32-bit JRE without specifying -Xmx works fine too.  According to [1], a 64-bit server-class JRE would allocate 1/4th of physical RAM if no -Xmx is given. The system I'm on has 250GB of RAM, and according to strace java has tried allocating 30GB of RAM in order to run LibraryDetector, which is ridiculous. -> cat /proc/meminfo | grep Mem MemTotal:       264118168 kB MemFree:        173739052 kB  A temporary workaround I employed is to set _JAVA_OPTIONS environment variable to -Xmx384m. Unfortunately, this trick overrides vmargs provided to Eclipse, and therefore I cannot set it lower. A proper solution would be to always specify -Xmx when starting a JVM in a subprocess. I've tried LibraryDetector with -Xmx2m, and it worked fine.   * References * [1] http://docs.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html   * System info * -> lsb_release -d Description:	Red Hat Enterprise Linux Server release 6.2 (Santiago) -> cat /proc/cpuinfo | grep processor | wc -l 32 -> cat /proc/meminfo | grep MemTotal MemTotal:       264118168 kB -> /proj/CoolTools/app/JRE/jre32/bin/java -version java version ""1.7.0_25"" Java(TM) SE Runtime Environment (build 1.7.0_25-b15) Java HotSpot(TM) Server VM (build 23.25-b01, mixed mode) -> /proj/CoolTools/app/JRE/jre64/bin/java -Xmx2m -version java version ""1.7.0_25"" Java(TM) SE Runtime Environment (build 1.7.0_25-b15) Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)   * Eclipse info * BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Command-line arguments:  -os linux -ws gtk -arch x86_64 The installation I've used to get above info with was created with p2 director from Kepler repository and based on SR0. > org.eclipse.platform_4.3.0_1947859193_linux_gtk_x86_64 > org.eclipse.jdt.debug_3.8.0.v20130514-0841 > org.eclipse.jdt.launching_3.7.0.v20130515-1451.jar However, I've also verified that the same error is present in another installation created from Juno repository and based on SR2."
N20130801-2000.  JDT Debug and Ant tests DNF on all platforms.
Trying to find the token and sourcePosition that correspond to QNR#binding I wanted to use QNR#indexOfFirstFieldBinding but observed that this field is reassigned for *every* field in the chain.  So either the name or the usage of this field is wrong.  In bug 392384 I'm temporarily adding another field indexOfFirstFirstFieldBinding so I can test that errors are reported at the desired location. That change may need to be reverted via this bug.
Given the following class:  package p; import org.foo.*; // here we have type annotations for nullity public abstract class X1 {     public class Inner {}     public void nesting(@NonNull Inner i1, @NonNull X1.@Nullable Inner i2) { } }  This currently generates the following byte code:    public void nesting(p.X1$Inner, p.X1$Inner);    ...    RuntimeInvisibleTypeAnnotations:       0: #19(): METHOD_FORMAL_PARAMETER, param_index=0       1: #19(): METHOD_FORMAL_PARAMETER, param_index=1       2: #27(): METHOD_FORMAL_PARAMETER, param_index=1, location=[INNER_TYPE]   ...  AFAICS the first annotation is wrong, it should have the same shape as the last one.  In 3.4 the spec says: "The type path that is stored in the class file is with respect to the full type, not the source code representation. ..." ... and goes on explaining.  The full type of the first formal parameter is correctly rendered as p.X1$Inner (see  the method signature), accordingly the type annotation for Inner should be marked with "location=[INNER_TYPE]", no?
Following the discussion in bug 394539 the bundle org.eclipse.jdt.annotation will be bumped up to 2.0.0 to require a BREE of 1.8 and change our annotations for target TYPE_USE.  At the same time we don't want to loose the ability to run our tests in 1.7 mode. I'm currently trying how the tests could automatically switch between both versions of this bundle.
org.eclipse.jdt.core.tests.compiler has a wrong bundle version.  It was changed from 3.8.2 to 3.8.3 which is wrong. It must either be 3.9.0 or 3.8.100. I recommend the former.  NOTES: 1) please also check all other projects where you changed the version 2) the version (3.8.3) in the maintenance branch is correct
There are API changes in APT in Java 8 and JDT's implementation must support the changes. In essence, we must provide implementation for the following interface methods:  Note: '->' stands for "must implement"  ElementsImpl -> Elements.isFunctionalInterface(TypeElement) ExecutableElementImpl -> ExecutableElement.isDefault()  ExecutableTypeImpl -> ExecutableType.getReceiverType() ExecutableElementImpl -> ExecutableElement.getReceiverType()  Following types must implement AnnotatedConstruct.getAnnotationsByType(Class<A>) :      TypeElementImpl     TypeParameterElementImpl     PackageElementImpl     VariableElementImpl     TypeMirrorImpl     ExecutableElementImpl      NoTypeImpl  Following types must implement AnnotatedConstruct.getAnnotation(Class<A>) and AnnotatedConstruct.getAnnotationMirrors():      TypeMirrorImpl     NoTypeImpl
"When I run RunJDTCoreTest locally, most the time I get one random failure in SwitchTest, re-running that particular test always passes.  By instrumenting VerifyTests I see the following pattern:  - VM is launched for testMarysLamb() - this test runs fine, socket is working - the log file created for this VM reports only this one test.  - next VM is launched for testNestedSwitches() - between testMarysLamb() and testNestedSwitches() we have two tests:   - testBreakOut() -> pass   - testMultipleSwitches() -> fail, unexpectedly empty output   Why are those missing from the log?  In the console I find:  java.io.EOFException 	at java.io.DataInputStream.readBoolean(DataInputStream.java:244) 	at org.eclipse.jdt.core.tests.util.TestVerifier.loadAndRun(TestVerifier.java:583) 	at org.eclipse.jdt.core.tests.util.TestVerifier.verifyClassFiles(TestVerifier.java:643) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2516) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2317) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1361) 	at org.eclipse.jdt.core.tests.compiler.regression.SwitchTest.testBreakOut(SwitchTest.java:1859)  I see this for several tests incl. both ""missing"" tests, but *not* for testMarysLamb()  My guess that the socket was unexpectedly closed has not yet been confirmed by logging. I may need to do more flushing to see if the missing log output is lost pending in some buffer."
I20130807-2000.  The label of the new JUnit view font is wrong. It should be "JUnit failure trace font".
"I think there’s a bug in the code that infers nullnes. It’s supposed to complain if you use a @Nullable value in a @NonNull context, unless it can deduce that it can’t be null, e.g. because you just tested it.  But this analysis has a bug in the particular case where the @Nullable value comes from a field rather than a local variable (e.g., this.maybenull). If you test that the field is not null, then it deduces correctly that it can’t be null. However, if you test if it is null, then on the “else” branch of the test it’s still considered nullable.   I’ve added a small class below that tests several of these cases. Compare first methods testIfThenBranch and  testIfElseBranch below. The first is accepted and the second fails, although logically they should be equivalent. Compare also with testIfElseBranchLocal, which shows that the same inference works if a local variable is involved instead of a field. I’ve also added some other similar cases, including a weird one where a similar test works in a “while” statement only if it is preceded by an “if”, even though the while is outside the if.   /* Start example: */      import javax.annotation.Nonnull;     import javax.annotation.Nullable;          public class Tests {       @Nullable       Object prop;              void test(@Nonnull Object param){         assert param != null;       }              void testIfThenBranch(){         if(this.prop != null) {           test(this.prop); // OK         }       }              void testIfElseBranch(){         if(this.prop == null) {           // ignore         } else {           test(this.prop); // FAILS!         }       }              void testIfThenReturn(){         if(this.prop == null) {           return;         }           test(this.prop); // FAILS!       }        void testIfElseBranchLocal(){         @Nullable Object local = this.prop; 		         if(local == null) {           // ignore         } else {           test(local); // OK         }       }              void testWhileAfterIf(){         if(this.prop != null) {           test(this.prop); // OK         }                  while(this.prop != null) {           test(this.prop); // OK         }       }              void testWhileAlone(){         while(this.prop != null) {           test(this.prop); // FAILS!         }       }     }  /* End example */   Exact version of JDT according to Eclipse’s about menu:  Eclipse Java Development Tools 3.9.0.v20130605-2000 org.eclipse.jdt.feature.group  In Eclipse’s preferences, in the compiler errors/warnings page, I have activated everything in the “Null analysis” section."
"4.4 M1.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.launching.EEVMType.validateInstallLocation(EEVMType.java:176) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$5.run(EEVMPage.java:198) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage.validateDefinitionFile(EEVMPage.java:206) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage.access$4(EEVMPage.java:184) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$2.modifyText(EEVMPage.java:140) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:179) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1082) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063) 	at org.eclipse.swt.widgets.Text.wmCommandChild(Text.java:2974) 	at org.eclipse.swt.widgets.Control.WM_COMMAND(Control.java:4752) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4614) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method) 	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443) 	at org.eclipse.swt.widgets.Text.callWindowProc(Text.java:260) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4706) 	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2597) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.SetWindowTextW(Native Method) 	at org.eclipse.swt.internal.win32.OS.SetWindowText(OS.java:3473) 	at org.eclipse.swt.widgets.Text.setText(Text.java:2252) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$3.widgetSelected(EEVMPage.java:159) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) 	at org.eclipse.jface.window.Window.open(Window.java:803) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock.addVM(InstalledJREsBlock.java:710) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock.access$9(InstalledJREsBlock.java:707) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock$8.handleEvent(InstalledJREsBlock.java:462) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) 	at org.eclipse.jface.window.Window.open(Window.java:803) 	at org.eclipse.ui.internal.dialogs.WorkbenchPreferenceDialog.open(WorkbenchPreferenceDialog.java:215) 	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:65) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:588) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:505) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:415) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:613) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
In Kepler there's a new feature, that also completes the trailing semicolon for method calls without parameters. That's nice. The caret jumps behind the trailing semicolon. Then for a short moment the enter key is blocked. That's not nice, because I used the enter key for code completion and now want to proceed to the next line.  Could you remove the enter key from blocked keys for this feature?
I20130813-1330 and N20130813-2000.  http://download.eclipse.org/eclipse/downloads/drops4/I20130813-1330/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html   N/A  java.lang.NullPointerException at org.eclipse.jdt.debug.tests.core.JavaLibraryPathTests.testMultiVMArgsForRequiredProjectExplicitPath(JavaLibraryPathTests.java:155) at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2405) at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:55) at java.lang.Thread.run(Thread.java:662)   N/A  java.lang.NullPointerException at org.eclipse.jdt.debug.tests.core.JavaLibraryPathTests.testVMArgsForRequiredProjectExplicitPath(JavaLibraryPathTests.java:130) at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2405) at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:55) at java.lang.Thread.run(Thread.java:662)
Once bug 392099 has resolved the bulk of the work for null type annotations, the following list of TODOs must be investigated:  (1) Check para in Annotation.resolveType() starting   if ((annotationType.tagBits & TagBits.AnnotationTargetMASK) == TagBits.AnnotationForTypeUse) { -> Needed? When, why introduced? Overlap with 1.8 treatment below??  (2) ConditionalExpression: FIXME: we need t1 == t2 comparison, but don't yet handle mixed scenarios of types with nullTagBits + arguments -> also use unannotated() instead of original()!!  (3) ReturnStatement:  more detailed checking (incomp. due to annot on type detail) -> use findNullTypeAnnotationMismatch() & write more tests -> this method still needs to descend into type parameters  (4) Statement.findNullTypeAnnotationMismatch(..) - maybe int return can be replaced with boolean (isDefiniteConflict) - if so, maybe the method can actually do less for non-definite cases  (5) TypeDeclaration: -> Need to check if synth default constructors need treatment for JSR308  (6) LookupEnvironment.createAnnotatedType: + handle PolyTypeBinding  (7) SourceTypeBinding.resolveTypeFor() - here we translate NonNullByDefault into type annotation after the fact.   should we use different strategies up-front?  (8) ReferenceBinding.nullAnnotatedReadableName(..) - respect annotatable enclosing type  (9) NullTypeAnnotationTest: expect (and implement) more error messages   (individually marked "FIXME").
"It is when you used parser outside IDE and does not have got access to JavaProject. You will provide properly all data to parser but it fails on case like:  File A: ------- public class A  { } class B  {} -------  File C: ------- public class C extends B  {} -------  Goal: We want createAST() for file C.  It is caused that method findType() is broken in NameEnvironmentWithProgress  See: class CompilationUnitResolver method 	public static void resolve(...)  line: environment = new NameEnvironmentWithProgress(allEntries, null, monitor);  Method findType in this NameEnvironmentWithProgress could better support this case.  In findType going down few steps NameEnvironmentAnswer.findClass() this is place where is a bug in this case:  If class is on the class path then it is ok but in our case. Both classes are on one file with source code and second class is not in classpath and you have not got binaries. You do not want build it. You just want create AST then this aproach where you are searching for binary .class file names are completely fails. This will back you class not found and compile error when everything is fine.  Quick fix could be looks something like that:      @Override     public NameEnvironmentAnswer findType(final char[] aTypeName, final char[][] aaPackageName)     {         NameEnvironmentAnswer findType = super.findType(aTypeName, aaPackageName); // invoked actual version of findType()         if ((findType == null) && (_packagePrivateClasses != null) && CharOperation.equals(aaPackageName, _sOriginalPackage)) {             // if we could not find this type it means that could be package private type declared in another .java file. We should inspect all .java files in this             // package to discover it             final String string = getContainingJavaFileForType(CharOperation.charToString(aTypeName));             if (UString.isNonEmptyString(string)) {                 findType = super.findType(string.toCharArray(), aaPackageName);             }          }         return findType;     }  If you need more details to reproduce this bug on for ideas how to fix it please do not hesitate to contact me :)"
"REPRODUCING THE PROBLEM: 1) Create a workspace with one java project. In the Java-Compiler ""Errors/Warning"" -settings turn on ""enabled annotation-based null-analysis"".  2) Add the following two classes:  --- ClassA.java: import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class ClassA { 	public interface InterfaceA { 		public void method(Object arg); 	} } --- ClassB.java: import org.eclipse.jdt.annotation.NonNull;  public class ClassB { 	public static class ImplA implements ClassA.InterfaceA { 		@Override 		public void method(@NonNull Object arg) { 		} 	} }  3) Now close all Editor windows. 4) Chose Project > Clean ... > Clean all projects:  THE PROBLEM: The following error appears in the problems view: ""Illegal redefinition of parameter arg, inherited method from ClassA.InterfaceA does not constrain this parameter"", ClassB.java, line 6  ANALYSIS: In SourceTypeBinding.java, the field defaultNullness is accessed in the method hasNonNullDefault(), but was not initialized for some of the involved classed. (There is another reference to it in checkRedundantNullnessDefaultOne, which is not resposible for the bug in the example, but looks suspicous too) Invoking initializeNullDefault() before accessing defaultNullness fixes the problem. I will attach a patch which does that in both locations."
With type annotations for null analysis, more patterns of incompatibility arise which deserve specific analysis and reporting.  Consider:   List<@NonNull String> nonNullStrings;   List<@NonNull String> nullableStrings;   List<String> strings;  (A) Incompatible:   nonNullStrings = nullableStrings;   nullableStrings = nonNullStrings;  (B) Lossy (but safe) conversions:   strings = nonNullStrings;   strings = nullableStrings;  (C) Unchecked, unsafe conversions:   nonNullStrings = strings;   nullableStrings = strings;   Current status:  (A) is mostly implemented, exception:  - array content, nullable to nonnull incompatibility is not reported Currently, this kind of incompatibility influences overload resolution, which is wrong.  (B) works for array details, but not for type parameters.  (C) works for type parameters but not all situations involving array details   Note, that all checking for the above happens during resolve, no flow  analysis involved.
BETA_JAVA8: ----------  JSR308 2.1.2 states: Static member accesses are preceded by a type name, but  that type name may not be annotated:  @Illegal Outer.StaticNestedClass // illegal! @Illegal Outer.staticField // illegal!  While we reject the latter snippet, we silently accept the former.
"BETA_JAVA8:   From the spec:   ""An annotation on a wildcard type argument appears before the wildcard, as in  MyClass<@Immutable ? extends Comparable<MyClass>>""  However, when the following program is compiled, the annotations are accepted, but don't seem to make it to the class file:  // --- import java.lang.annotation.*; import java.util.List; import static java.lang.annotation.ElementType.*;  @Target(TYPE_USE) @interface Immutable {} class X { 	List<@Immutable ? extends Comparable<X>> x; }  // ----  javac 8b100 emits:  RuntimeInvisibleTypeAnnotations:       0: #9(): FIELD, location=[TYPE_ARGUMENT(0)]"
"BETA_JAVA8:  Given the following program:  // --- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target(TYPE_USE) @interface Immutable {} class Document {} class X { 	@Immutable X() { 	} } // ---  The annotation @Immutable does not make it to the class file.  8b100 emits:    X();     descriptor: ()V     flags:      Code:       stack=1, locals=1, args_size=1          0: aload_0                 1: invokespecial #1                  // Method java/lang/Object.""<init>"":()V          4: return               LineNumberTable:         line 7: 0         line 8: 4     RuntimeInvisibleTypeAnnotations:       0: #9(): METHOD_RETURN"
"REPRODUCING THE BUG: import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class ClassF { 	public interface X { 		@Nullable 		Object provideNullable(); 	}  	public static void needNonNull(@NonNull Object o) { 		o.hashCode(); 	}  	public void method(X x) { 		for (int j = 0; j < 1; j++) { 			try { 				this.hashCode(); 			} finally { 				for (int i = 0; i < 1; i++) { 					Object o = x.provideNullable(); 					needNonNull(o); 				} 			} 		} 	} } THE BUG: The compiler throws a NullPointerException in FinallyFlowContext.java:108, inside the ""if""-statement:  case ASSIGN_TO_NONNULL: 	int nullStatus = flowInfo.nullStatus(this.nullLocals[i]); 	if (nullStatus != FlowInfo.NON_NULL) { 		this.parent.recordNullityMismatch(scope, (Expression) location, 		this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus); 	} 	break;  ANALYSIS: It is assumed, that whenever the value ASSIGN_TO_NULL is used, then this.providedExpectedTypes is initalized.  This is wrong in one case: The value ASSIGN_TO_NULL may be passed from LoopingFlowContext, Line 290:  if (!(this.nullCheckTypes[i] == MAY_NULL &&  upstreamCopy.isDefinitelyNonNull(local))) { 	this.parent.recordUsingNullReference(scope, local, location,  			this.nullCheckTypes[i], flowInfo);  } to the implementation of recordUsingNullReference in FinallyFlowContext, at the end which in line 420, it invokes  recordNullReference(local, location, checkType); without invoking   recordProvidedExpectedTypes(providedType, expectedType, this.nullCount);  POSSIBLE FIX: diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java index 2befb45..7afdf13 100644 --- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java +++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java @@ -287,8 +287,10 @@  			// https://bugs.eclipse.org/376263: avoid further deferring if the upstream info  			// already has definite information (which might get lost for deferred checking).  			if (!(this.nullCheckTypes[i] == MAY_NULL && upstreamCopy.isDefinitelyNonNull(local))) { -				this.parent.recordUsingNullReference(scope, local, location, -						this.nullCheckTypes[i], flowInfo); +				if((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) != ASSIGN_TO_NONNULL) { +					this.parent.recordUsingNullReference(scope, local, location, +							this.nullCheckTypes[i], flowInfo); +				}  			}  		}  	}"
BETA_JAVA8:  When the following program is compiled:  // -- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;   @Target({TYPE_USE}) @interface TypeAnnotation { }  @Target({TYPE}) @interface Annotation { }  @Annotation @TypeAnnotation class X { }  // --  @TypeAnnotation does not seem to make it to the class file.  JSR308, section 2.3 expressly allows such usage. Excerpt:  "A type annotation (one meta-annotated with @Target(ElementType.TYPE USE))  is permitted to be written anywhere @Target(ElementType.TYPE) or  @Target(ElementType.TYPE PARAMETER) would permit—that is, on a class, interface, or enum declaration, or on a type parameter declaration. Strictly  speaking, these are declaration sites, not uses of a type. However, it is  convenient to write a type annotation at a type declaration, as shorthand for applying it at all uses. For example, @Interned class MyClass { ... } could  indicate that all uses of MyClass are interned, even though for other classes  some instances may be interned and other instances not interned."
"BETA_JAVA8:  From the spec:  ""Type annotations in the body of an initializer appear with the code that  performs the initialization, not on the field that is being initialized.  Type annotations in the body of instance initializer appear on on all initial constructors, and type annotations in the body of a class initializer  appear on the clinit symbol""  for the following program:  // ---  import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target({TYPE_USE}) @interface NonNull { } class X {  	static { 		new @NonNull Object(); 	} 	{ 		new @NonNull Object(); 	} 	X() { 		 	} 	X (int x) { 		 	} }   we generate the following code:  ""// Compiled from X.java (version 1.8 : 52.0, super bit)\n"" +  		""class X {\n"" +  		""  Constant pool:\n"" +  		""    constant #1 class: #2 X\n"" +  		""    constant #2 utf8: \""X\""\n"" +  		""    constant #3 class: #4 java/lang/Object\n"" +  		""    constant #4 utf8: \""java/lang/Object\""\n"" +  		""    constant #5 utf8: \""<clinit>\""\n"" +  		""    constant #6 utf8: \""()V\""\n"" +  		""    constant #7 utf8: \""Code\""\n"" +  		""    constant #8 method_ref: #3.#9 java/lang/Object.<init> ()V\n"" +  		""    constant #9 name_and_type: #10.#6 <init> ()V\n"" +  		""    constant #10 utf8: \""<init>\""\n"" +  		""    constant #11 utf8: \""LineNumberTable\""\n"" +  		""    constant #12 utf8: \""LocalVariableTable\""\n"" +  		""    constant #13 utf8: \""this\""\n"" +  		""    constant #14 utf8: \""LX;\""\n"" +  		""    constant #15 utf8: \""RuntimeInvisibleTypeAnnotations\""\n"" +  		""    constant #16 utf8: \""LNonNull;\""\n"" +  		""    constant #17 utf8: \""(I)V\""\n"" +  		""    constant #18 utf8: \""x\""\n"" +  		""    constant #19 utf8: \""I\""\n"" +  		""    constant #20 utf8: \""SourceFile\""\n"" +  		""    constant #21 utf8: \""X.java\""\n"" +  		""  \n"" +  		""  // Method descriptor #6 ()V\n"" +  		""  // Stack: 2, Locals: 1\n"" +  		""  static {};\n"" +  		""    0  new java.lang.Object [3]\n"" +  		""    3  dup\n"" +  		""    4  invokespecial java.lang.Object() [8]\n"" +  		""    7  astore_0\n"" +  		""    8  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 6]\n"" +  		""        [pc: 8, line: 7]\n"" +  		""  \n"" +  		""  // Method descriptor #6 ()V\n"" +  		""  // Stack: 1, Locals: 1\n"" +  		""  X();\n"" +  		""     0  aload_0 [this]\n"" +  		""     1  invokespecial java.lang.Object() [8]\n"" +  		""     4  new java.lang.Object [3]\n"" +  		""     7  invokespecial java.lang.Object() [8]\n"" +  		""    10  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 11]\n"" +  		""        [pc: 4, line: 9]\n"" +  		""        [pc: 10, line: 12]\n"" +  		""      Local variable table:\n"" +  		""        [pc: 0, pc: 11] local: this index: 0 type: X\n"" +  		""    RuntimeInvisibleTypeAnnotations: \n"" +  		""      #16 @NonNull(\n"" +  		""        target type = 0x44 NEW\n"" +  		""        offset = 4\n"" +  		""      )\n"" +  		""  \n"" +  		""  // Method descriptor #17 (I)V\n"" +  		""  // Stack: 1, Locals: 2\n"" +  		""  X(int x);\n"" +  		""     0  aload_0 [this]\n"" +  		""     1  invokespecial java.lang.Object() [8]\n"" +  		""     4  new java.lang.Object [3]\n"" +  		""     7  invokespecial java.lang.Object() [8]\n"" +  		""    10  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 13]\n"" +  		""        [pc: 4, line: 9]\n"" +  		""        [pc: 10, line: 14]\n"" +  		""      Local variable table:\n"" +  		""        [pc: 0, pc: 11] local: this index: 0 type: X\n"" +  		""        [pc: 0, pc: 11] local: x index: 1 type: int\n"" +  		""    RuntimeInvisibleTypeAnnotations: \n"" +  		""      #16 @NonNull(\n"" +  		""        target type = 0x44 NEW\n"" +  		""        offset = 4\n"" +  		""      )\n"" +  		""}""  //---------------- This shows two problems in code generation:  (1) Static class initializer code is missing the type annotations attributes. (2) Checkcast instruction is not emitted - so the fix for bug 409244 may not be fully effective."
"BETA_JAVA8: ----------  From the spec:  ""When the annotation’s target is a bound of a type parameter of a class or  method, target info contains one type parameter bound target:   type_parameter_bound_target {     u1 type_parameter_index;     u1 bound_index; };  type parameter index specifies the index of the type parameter, while bound  index specifies the index of the bound. Indexes start at 0. Bound index 0 is always a class, not interface, type. If the programmer-supplied upper bound  of the type variable is an interface, it is treated as the second bound, and  the implicit first bound is java.lang.Object.  // ---  Given that, given the following program:  // --- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target({TYPE_USE}) @interface NonNull { }  class X <T extends @NonNull Comparable> { 	 } // --  we generate bad code:  ""  RuntimeInvisibleTypeAnnotations: \n"" +  				""    #21 @NonNull(\n"" +  				""      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n"" +  				""      type parameter index = 0 type parameter bound index = 0\n"" +  				""    )\n"" +  				""}""  javac 8b100 generates:    RuntimeInvisibleTypeAnnotations:     0: #13(): CLASS_TYPE_PARAMETER_BOUND, param_index=0, bound_index=1  which is correct."
As I'm trying to run tests along with platform build using surefire, I noticed that bundle org.eclipse.jdt.core.tests.compiler has for packaging type "eclipse-plugin". Shouldn't it be an "eclipse-test-plugin" so surefire would run tests?
I'm getting incorrect potential resource leaks in a for loop, with the close inside a try/catch. Let me show examples:      public void example1() throws IOException {         for (final File file : new File[] { new File("/") }) {             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 reader.close();             }         }     }  example1() has no problems.      public void example2() throws IOException {         for (final File file : new File[] { new File("/") }) {             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 try {                     reader.close();                 }                 catch (IOException e) {                 }             }         }     }  example2() shows the warning on variable "reader" - the difference between this and example1() is the try/catch around reader.close().      public void example3() throws IOException {         final File file = new File("/");          BufferedReader reader = null;         try {             reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));         }         finally {             try {                 reader.close();             }             catch (IOException e) {             }         }     }  example3() does NOT give me the warning - it is the same as example2() with the the for loop removed.      public void example4() throws IOException {         final File[] files = new File[] { new File("/") };          for (int i = 0; i < files.length; i++) {             File file = files[i];             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 try {                     reader.close();                 }                 catch (IOException e) {                 }             }         }     }  example4() is an equivalent of example2(), with a regular for loop instead of enhanced-for loop. This showed a warning also.  All I can conclude is potential resource leak is not working with for loop (of either type) and a try/catch around the close.  I was compiling with Compiler compliance level of 1.6.
BETA_JAVA8: ----------  Per discussions in the EG list, the spec is being amended to require a target_type=CLASS_EXTENDS type annotation for the following case: This is apart from the target_type=NEW type annotation which we already emit.  Note that the reference compiler already emits the CLASS_EXTENDS type annotation, but not the NEW target type annotation, a bug has been raised against javac for this purpose.  // --- @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) @interface X {}  class C { void m() { new @X Foo() {}; } } // --  From the EG discussion:  ...  The wording for target_type=CLASS_EXTENDS (0x10) refers to a "type in  extends clause of class or interface declaration" so it's not clear that  the @X annotation should be stored this way. To clarify, the wording for  target_type=CLASS_EXTENDS should say:  "type in extends clause of class or interface declaration (including the  direct superclass of an anonymous class declaration), ..."  ...
"Testcase :  public class Sample{  interface Int { 		void setInt(int i);  	} public static void main(String[] args) {    		final int j; 		  		Int int1 = (int i) -> { 			j=10; 		};  }  }    Gives following error with javac :  Sample.java:14: error: cannot assign a value to final variable j                         j=10;                         ^ 1 error    Does not give error in eclipse."
BETA_JAVA8:  JEP 118 provides for storing of method parameter names, flags and such in a new attribute called MethodParameters. This is to be generated only when a programmer opts in for it.  https://bugs.eclipse.org/bugs/show_bug.cgi?id=407297 has implemented the Core changes for this option. See the javadoc for org.eclipse.jdt.core.JavaCore.COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR  ECJ implements -parameters command line option for this purpose.  We need support in the UI for enabling this. TIA.
As a big test to catch potential regressions caused by null analysis using type annotations, I ran all JDT/Core tests at 1.8 with null annotations enabled.  Currently this produces 124 errors and 37 failures.  I'm going to work through these regressions and provide patches via this bug.
We have the following code in EclipseCompiler.java, which is our implementation of JavaCompiler:    eclipseCompiler2.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);   eclipseCompiler2.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);   eclipseCompiler2.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);  There has to be a way clients, at least, JDT core tests that use this, can pass a different compliance level than this.  This is affecting the new tests I am planning to add as part of bug 414627.
"BETA_JAVA8:  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface Marker { }  public class X { 	@Marker 	foo(String s) {  	} }   This snippet triggers an NPE on HEAD."
Set 'code.ignoredWarnings' for test bundles in order to use the global build settings and reduce the discouraged access warnings in the official build.  The easiest way to do this is:  1. in the repository root add a folder 'tests-pom' 2. into the new folder add the following pom.xml:      http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/plain/tests-pom/pom.xml 3. adjust the parent group and artifact id in that file 4. in each test bundle modify the pom.xml as follows:    a) replace the parent artifact id with "tests-pom"    b) add this to the parent declaration:       <relativePath>../tests-pom/</relativePath>  As a template you can use e.g. http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/
"The following code: public class Bug { 	public static void main(String[] args) throws Exception { 		System.out.println(ParseExpr11()); 	}  	static final public Object ParseExpr11() throws Exception { 		Object expr; 		Object op = null; 		expr = ParseVarExpr(); 		if (op == null) { 			if (true) 				return expr; 		} 		{ 			throw new Exception(""++/-- not supported in TUD Bantam Java.""); 		} 	}  	private static Object ParseVarExpr() { 		// TODO Auto-generated method stub 		return ""test""; 	} }  throws  Exception in thread ""main"" java.lang.VerifyError: Expecting a stackmap frame at branch target 12 in method Bug.ParseExpr11()Ljava/lang/Object; at offset 7 	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2451) 	at java.lang.Class.getMethod0(Class.java:2694) 	at java.lang.Class.getMethod(Class.java:1622) 	at sun.launcher.LauncherHelper.getMainMethod(LauncherHelper.java:494) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:486)   Expected: ""test""   It is generated by JavaCC, which is why the formatting/syntax sucks. Works fine with javac.  -- Configuration Details -- Product: Eclipse 1.5.2.20130110-1126 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.8.2.v20130116-090414-8-8nFu3FNOfwKLRuqgXKIy9z0I83"
"Consider this code fed to the APT:  @TypeUseAnnotation(""class"") @Deprecated public class TypeAnnotationTest extends @TypeUseAnnotation(""super"") Object {}  And the following code in AnnotationDiscoveryVisitor:  private void resolveAnnotations( 		BlockScope scope, 		Annotation[] annotations, 		Binding currentBinding) { 	ASTNode.resolveAnnotations(scope, annotations, currentBinding); 	 	for (Annotation annotation : annotations) { 		AnnotationBinding binding = annotation.getCompilerAnnotation(); 		if (binding != null) { 			TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType());  			Element element = _factory.newElement(currentBinding); 			_annoToElement.put(anno, element); 		} 	} }  Looks like the new element instance created for the currentBinding is just not necessary."
Update the preference UI to support Java 1.8 target platform.  Jay, kindly update the Javadoc for JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM.
Performed code formatting at project level containing more than 100 Java files.  Expected: The code must be formatted as per the template. Actual: The formatter threw exception saying: Some characters cannot be mapped using "Cp1252" character encoding. Either change the encoding or remove the characters which are not supported by the "Cp1252" character encoding.  There are two problems here: 1) The root cause for the exception 2) The exception details are not enough - it doesn't state in which file the exception occurred. Now I have to dig through all the files one by one.  -- Configuration Details -- Product: Eclipse 2.0.0.20130613-0530 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.9.0.v20130605-2000
The compile side of work for JEP118 (Runtime method parameter name access) was accomplished via bug 406966 and its children. APT should respond to the model API changes mandated by the JEP.  The current bug is to track that.
Failed at http://download.eclipse.org/eclipse/downloads/drops4/I20130828-1800/testresults/html/org.eclipse.jdt.core.tests.model_linux.gtk.x86_6.0.html
"public class A { 	class B { 		interface I { // Error			 		} 	} } ------------------------- public class A { 	class B { 		@interface I { // Error			 		} 	} } ------------------------- The error message says: ""The member interface/annotation I can *only* be defined inside a top-level class or interface"". However, these can also be defined inside a static member type, which is not reflected in the error message."
"// -- following program does not compile: good;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	class Y {} 	@NonNull String  foo(X.@NonNull Y xy) { 		return """"; 	} }  class Z extends X { 	String  foo(X.Y xy) { 		return null; 	} }  // -- following program does compile: bad; import org.eclipse.jdt.annotation.NonNull;  public class X { 	class Y {} 	X.@NonNull Y  foo(X.@NonNull Y xy) { 		return new X().new Y(); 	} }  class Z extends X { 	X.@NonNull Y  foo(X.Y xy) { 		return null; 	} }"
"// -- import java.util.List;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	void  foo(List<X> lx) { 	} }  class Z extends X { 	void  foo(List<@NonNull X> xy) { 	} }  results in a name clash error:   ""Name clash: The method foo(List<X>) of type Z has the same erasure as foo(List<X>) of type X but does not override it"""
"// --  import java.util.ArrayList; import java.util.List;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	public static void main(String[] args) { 		List<@NonNull ? extends @NonNull String> ls = new ArrayList<String>(); 		ls.add(null); 		@NonNull String s = ls.get(0); 	} } // triggers an NPE."
"// -- import org.eclipse.jdt.annotation.NonNull;  public class X<@NonNull T> { 	T foo(T t) { 		return t; 	} }   // ---  produces a stack overflow error. Probably due to a missing unannotated() implementation in TVB."
"// --- Expect two errors, but got one  import org.eclipse.jdt.annotation.NonNull;  public class X<T> { 	class Y { 		 	} 	 	X<String>.@NonNull Y y = null; // no error here, bad. 	 	@NonNull Y y2 = null; // error here. Good. }"
"// -- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class X<T> { 	T foo(@NonNull T t) { 		return t; 	} 	public static void main(String[] args) { 		X<@Nullable String> xs = new X<String>(); 		xs.foo(null); 	} 	 }  // -- 1. Allowing X<@Nullable String> creates contradiction for X#foo which we don't complain about.  2. The unchecked conversion message reads strange. Target type @Nullable, we should probably be just silent as it is always a safe conversion."
"// -- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class X<T> { 	T foo(@NonNull T t) { 		return t; 	} 	public static void main(String[] args) { 		X<String> xs = new X<String>(); 		xs.foo(""""); 	} 	 }   // without null analysis enabled, compiles ok."
See NullTypeAnnotationTest#testBug416174() for a situation that is not yet detected. Here the incompatibility is only by an annotation on a type parameter.
"Here is the code snippet before applying inline refactoring:  public class A { 	public static int i;  	public static int getI() {         // APPLY INLINE HERE 		return i; 	} }  public enum B { 	m(A.getI()); 	 	B(int j){		 	} }  Applying inline refactoring to getI() cannot update A.getI() that is a parameter of enum constructor call:  public class A { 	public static int i; }  public enum B { 	m(A.getI());             // ERROR 	 	B(int j){		 	} }"
"Using Eclipse SDK Version: 4.4.0 Build id: I20130829-2000  I'm not sure exactly what code triggers the NPE but it seems it's when I hover on certain methods that override other methods. I'll try to isolate the code.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:274) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:970) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:510) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:265) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:469) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1185) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1295) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:561) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:789) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:592) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:115) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:135) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:300) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1267) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:739) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:691) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:96) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getTypeHierarchy(JavadocContentAccess2.java:432) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getInheritedDescription(JavadocContentAccess2.java:386) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getInheritedMainDescription(JavadocContentAccess2.java:302) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.toHTML(JavadocContentAccess2.java:831) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.javadoc2HTML(JavadocContentAccess2.java:682) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:604) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:495) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:694) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:612) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:604) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
"In this snipped:  // === import java.util.Map;  import org.eclipse.jdt.annotation.*;  abstract public class X<Y> implements Map<@NonNull String,Y> { 	void foo(X<Object> x) { 		Map<@NonNull String, Object> m1 = x; // OK 		Map<@Nullable String, Object> m2 = x; // NOK 	} } // ===  we should see one error at (NOK), but the compiler fails to see that X specifies type parameter Map.K as @NonNull."
BETA_JAVA8:  org.eclipse.jdt.internal.compiler.lookup.TypeIds.T_JavaLangFunctionalInterface & org.eclipse.jdt.internal.compiler.lookup.TypeIds.T_JunitFrameworkAssert  both have the same type id 69 :)  Possibly other cases too. Please sort and eliminate duplicates and reassign suitable values.
"I was day dreaming along these lines (see bug 416304):    <N extends Annotation> @N B f(@N A a)  Much to my surprise ecj didn't call me nuts but simply answered:  	<N extends Annotation> @N B f(@N A a) 	                       ^^ 	Syntax error, type annotations are illegal here  Oops, this seems to be derived from (JSR 308 draft):    MethodOrFieldDecl: 	UnannType Identifier MethodOrFieldRest  where in fact these original rule should apply:    GenericMethodOrConstructorDecl: 	TypeParameters GenericMethodOrConstructorRest    GenericMethodOrConstructorRest: 	(Type | void) Identifier MethodDeclaratorRest 	Identifier ConstructorDeclaratorRest  in the second rule, unchanged for JSR 308, the NT Type now expands to    [Annotations] UnannType  Ergo: the above syntax should be accepted, leaving the question *why* the above snippet is illegal as an exercise for the reader :)   As an aside, this implies that the following is legal though totally crazy:    @NonNull <T> @Nullable String foo() { return null; }  Bonus question: Can @NonNull in this example still be interpreted as a type annotation?"
Consider this example:    import java.lang.annotation.*;   ...   <T extends Annotation> String foo(@T String s) { return null; }  ecj will answer:    <T extends Annotation> String foo(@T String s) { return null; }                                      ^   Type mismatch: cannot convert from T to Annotation  Mh, that's the wrong error to show, T *is* compatible to Annotation.  Looking at JLS 9.6:    "A consequence of the fact that an annotation type cannot explicitly declare a    superclass or superinterface is that a subclass or subinterface of an annotation type    is never itself an annotation type."  subtyping isn't actually the issue we're interested in.  The thing *must be an annotation type*, and that's what ecj should complain about (and its how the check is already implemented ...)  Not marking [1.8] since the problem already exists in master,  although this is even more fun with JSR 308 :)
Found that 'Inline finally blocks' option is enabled incorrectly: 1. In the compiler preference page, select 'Configure Project Specific Settings' and choose a Java 1.4 project. Select the 'Java Build Path' and modify the EE to J2SE-1.5. Use the back button or directly click on the Java Compiler to come back to the previous page where the project specific setting was being modified. See that the 'Inline finally blocks' is enabled for Java-1.5, which is wrong.  2. In the compiler preference page, select 1.4 compliance level. Now uncheck 'Inline finally blocks' option. Now change the compliance level to 1.5 and then change to 1.6 and now change it back to 1.4, the checkbox is now checked. This also looks wrong.
Created attachment 235123 [details] SneakyCaster.java  To reproduce, compile (and then run) the attached SneakyCaster.java using both javac and ECJ.  ECJ misses the checkcast instruction at the end of the cast() method. This allows assignment of an Object to a Runnable variable. Eventually, the JVM throws an IncompatibleClassChangeError, but clearly, as there is only one .class file, that's not right.  javac correctly includes the checkcast instruction, and a ClassCastException is thrown before the invalid assignment could ever be made.
The IVariableBinding for a LambdaExpression parameter has a non-unique key:      IntPredicate f = (i) -> i == 1;     IntPredicate g = (i) -> i != 2;  Key for both variables 'i' is just '#i'. Should be prefixed with the LambdaExpression's method binding key.
"Created attachment 235166 [details] Screenshot  package misc.test;  interface FI { 	int foo(int s1, int s2); }  class Test { 	FI fi= /*a*/ (int n1, int n2) -> n1 * n2; } -------------------------- Steps: 1. To get the JLS8 AST, set org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.SHARED_AST_LEVEL to AST.JLS8. 2. Add a breakpoint in org.eclipse.jdt.internal.core.CompilationUnit.reconcile(int astLevel, int reconcileFlags, WorkingCopyOwner workingCopyOwner, IProgressMonitor monitor). 3. Paste the above example in package explorer of the runtime workbench. 4. Edit the file and check the AST created in #reconcile(..) for the lambda parameter ""int n1"".  The startPosition and length are wrong as shown in the attached screenshot. (Example: length is 13 instead of 6. It includes the comment /*a*/ also along with ""int n1"")"
The MANIFEST.MF holds:  org.eclipse.jdt.annotation;bundle-version="[1.1.0,2.0.0)", org.eclipse.jdt.annotation;bundle-version="[2.0.0,3.0.0)"  which looks strange to me why not directly setting   org.eclipse.jdt.annotation;bundle-version="[1.1.0,3.0.0)"  the CBI builds fails with the current definition
While generifying API tools I came across some use of TagElement#fragments and while trying to update our code I realized IDocElement is not an API (or even visible) class - which is mentioned in the API docs as the list type:  * @return the live list of doc elements in this tag element * (element type: {@link IDocElement}) */ public List fragments() { ... }  The doc does mention what kinds of nodes (implementations of IDocElement) can appear in the list, but it does not make sense to mention a private class in the API docs.   Consumers basically have to do the following:  List<ASTNode> fragments = tagelement.fragments();  when they are expecting to be able to do (according to the docs):  List<IDocElement> fragments = tagelement.fragments();
Looks like the M-build needs to be touched.
The CHKPII rule is: Messages that contain {0} etc. must use '' as single quote, but messages without any placeholders must use a single ' .
Shouldn't we update http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties?h=R4_3_maintenance to say 3.9.1 in compiler.version?
"Created attachment 235330 [details] Test case to reproduce the issue  Exception in thread ""main"" java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at X.main(X.java:4) Caused by: java.lang.NoSuchMethodException: no such method: java.lang.invoke.LambdaMetafactory.metaFactory(Lookup,String,MethodType,MethodHandle,MethodHandle,MethodType)CallSite/invokeStatic 	at java.lang.invoke.MemberName.makeAccessException(MemberName.java:765) 	at java.lang.invoke.MemberName$Factory.resolveOrFail(MemberName.java:882) 	at java.lang.invoke.MethodHandles$Lookup.resolveOrFail(MethodHandles.java:1019) 	at java.lang.invoke.MethodHandles$Lookup.linkMethodHandleConstant(MethodHandles.java:1284) 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:381) 	... 1 more Caused by: java.lang.NoSuchMethodError: java.lang.invoke.LambdaMetafactory.metaFactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; 	at java.lang.invoke.MethodHandleNatives.resolve(Native Method) 	at java.lang.invoke.MemberName$Factory.resolve(MemberName.java:854) 	at java.lang.invoke.MemberName$Factory.resolveOrFail(MemberName.java:879) 	... 4 more  Use b104 build on windows for JRE 1.8 to reproduce the issue As a follow up for bug 413913  Also see http://dev.eclipse.org/mhonarc/lists/jdt-core-dev/msg02324.html"
BETA_JAVA8:  This test asserts in the last line:   assertEquals("Wrong qualified name", "test404489.bug.X.Y", binding.getQualifiedName())  The bindings qualified name is actually test404489.bug.X.  I have disabled this line. Please reenable after fix.
+++ This bug was initially created as a clone of Bug #416904 +++  In order to lower entry barrier for contribution and execution of unit tests, it would be quite helpful to make it possible to run tests with tycho-surefire-plugin and a simple "mvn clean v
"The quick assist (Convert to 'if-!-return') is not offered in a lambda body at valid 'if' locations. Examples:  package misc.test;  @FunctionalInterface interface A { 	void run(int n); }  @FunctionalInterface interface B { 	A foo(int x); }  public class Test { 	A fi0 = (n) -> { 		if (n == 0) {	// [1] 			System.out.println(n); 			return; 		} 	}; 	 	int fun1(int a, int b) { 		A fi2 = (n) -> { 			if (a == b) {	// [2] 				System.out.println(n); 				return; 			} 		}; 		return a + b; 	}  	A fun2(int a, int b) { 		return (n) -> { 			if (a == b) {	// [3] 				System.out.println(n); 				return; 			} 		}; 	}  	int fun3(int a, int b) { 		B fi3 = (x) -> (n) -> { 			if (a == b) {	// [4] 				System.out.println(a); 				return; 			} 		}; 		return a + b; 	} }"
After ASTNodes#getType(VariableDeclaration) method is updated to return 'null' for a type inferred lambda parameter, callers of the method need to be fixed iff there's a possibility that the given VariableDeclaration is a type inferred lambda parameter.  Patch to update ASTNodes#getType(VariableDeclaration) to return 'null' is attached in bug 407985 comment #3.
I20130810  The fix for bug 338350 uncovered lots of new "unchecked cast" warnings in my code (core.resources). No quick fix is proposed in this case. It would be useful to have a quick fix to resolve these new problems.
"--------------------------- package test.bugs;  @FunctionalInterface interface FI { 	int foo1(int a); }  class FI_1 { 	void fun(int a) { 		FI i1 = x1-> x1; 		FI i2 = xxx-> { 			i1.foo1(a); 			return xxx; 		}; 	} } --------------------------- Steps: 1. To "
4.3 and 4.3.1.  Currently the 'compiler.version' in  /org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties has to be updated manually when the version changes. Only the qualifier is a variable. This can lead to mismatches (see e.g. bug 416780). We should use (create if not yet there) bundle_version instead, i.e. compiler.version = bundle_version
"BETA_JAVA8:  Eclispe compiler has trouble with the following code:  package p; public class XX { 	public @Marker(""1"") String foo(int @Marker @Marker2 ... args) { 	      return null; 	} }  The following is compiled with no issues:  package p; public class XX { 	public @Marker(""1"") String foo(int @Marker @Marker2 [] args) { 	      return null; 	} }"
"While reviewing bug 409586, follow-up items start to pile up. Using this bug to collect and track those even though the original bug is not yet resolved so as to allow the main portion to be released soon.  From bug 409586 comment 65: (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.  (2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.  (3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.  (4) Error messages in testBug416175() 1.: mixing short and long names 2.: I like ""required \'@NonNull ? extends String\'"" better than ""required \'@NonNull capture#\'"" when it's clear we're not interested in compatibility of the capture itself, only in null safety.  From bug 409586 comment 83: (5) Investigate new locations throwing IllegalStateException to see if we can convince ourselves that these are ""impossible to reach"" :)   New items: (6) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous. Any client expecting this to show per-use null annotation tagbits will fail. Currently there appear to be no such clients, but ...  (7) Investigate: To challenge whether delegation to prototype is OK in STB#memberTypes(): will annotated reference to member type @TA Outer.Inner see its Outer as @TA (at the binding level)?  (8) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits! 'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:   @NonNullByDefault class AllAreNonNull { 	String s3 = """"; // leaving this uninitialized would be detected 	void test() { 		this.s3 = null; // this goes unnoticed!!! 	}   } Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+   (9) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:   this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});   this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()}); Seeing these as marked TODO could indicate there's more to this??  (10) BinaryTB#toString() needs update for instantiations similar to STB."
"BETA_JAVA8:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd released on behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=417113 needs some tweaking/massaging in the type annotated null analysis support. These were captured during review of the mentioned patch and the present CR is being opened to track such tasks.  From bug 409586 comment 65: (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.  (2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.  (3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.  (4) Error messages in testBug416175() 1.: mixing short and long names 2.: I like ""required \'@NonNull ? extends String\'"" better than ""required \'@NonNull capture#\'"" when it's clear we're not interested in compatibility of the capture itself, only in null safety.   (5) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits! 'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:   @NonNullByDefault class AllAreNonNull { 	String s3 = """"; // leaving this uninitialized would be detected 	void test() { 		this.s3 = null; // this goes unnoticed!!! 	}   } Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+   (6) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:   this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});   this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()}); Seeing these as marked TODO could indicate there's more to this??  [No, I didn't know env.getNonNullAnnotation() was available]  (7) BinaryTB#scanFieldForNullAnnotation had an initial stanza which served two purposes for the 1.8+ case: - apply a @NonNullByDefault to the field's type binding - shortcut everything else that is needed only for 1.7-  Frankly, I don't understand this change. The first aspect may partly be covered by VariableBinding#isNonNull() which checks tagBits at the FieldBinding AND at its type, but this is probably not sufficient/safe.  [Sorry, I may have been guilty of over-pruning here and in a few other places]"
"Here is a simple code:  class X { 	public void foo(@Marker int p) {} }  Now, for parameter 'p', Argument#type#resolvedType (which is a BaseTypeBinding)doesn't contain the type use annotations. Interestingly, Argument#binding#type (which is also a BaseTypeBinding) contains the annotations correctly. Ideally, they should be referencing the same object."
Following tests fail when the following debug options are on:  org.eclipse.jdt.core/debug/dom/ast=true org.eclipse.jdt.core/debug/dom/ast/throw= true org.eclipse.jdt.core/debug/dom/ast/rewrite = true  The failures are listed below:  TypeAnnotationsConverterTests : test0003, test0004, test0005, test0008. ASTConverter18Test : test0004, test0006, test0015, test399794. ASTRewritingMethodDeclTest: testListInserts(JLS8), TestMethodReturnTypeChanges2_only_2( JLS2),TestMethodReturnTypeChanges_only_2 (JLS2). ASTRewritingTypeAnnotationsTest: testClassInheritenceAnnotations(JLS8). ASTRewritingReferenceExpressionsTest: 4 failures testRE_test00{1,3,4,5}_since_8   This may be converted to an umbrella bug for better tracking if the patches are grouped for particular sets.
Created attachment 235645 [details] Test code to reproduce the issue  ArrayTypeReference generated for argument is incorrect.  Expected: int [] @TakeType(int[].class) []  Actual: int @TakeType(int[][].class) []  (only 1 dimension shown in actual, while the 2nd dimension is shown as part of annotations).
"Use the ASTView on the following code and get an error dialog about 'Bad AST Node structure.  package p; public class X  {     public static void main(String [] args) {     	W w = (@Marker W<String>) null;     } } class W<T> { } @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE) @interface Marker {}  The problem appears that in this particular case the AnnotatableType (@Marker W<String>) doesn't include the annotation in it's source range."
"BETA_JAVA8:  // --  import org.eclipse.jdt.annotation.NonNull;  public class X<T> {     	public static void main(String[] args) { 		@NonNull String @NonNull [] s = new @NonNull String [] { null }; 		if (s != null && s[0] != null) { 			System.out.println(""Not null""); 		} 		System.out.println(""Length = "" + s[0].length()); 	} }  // ---  Program generates an NPE. The warnings about redundant null check from previous  lines give false assurance, since we don't warn at the array creation site, where a null sneaks in."
"BETA_JAVA8:  Following program causes the compiler to cause an NPE:  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  import org.eclipse.jdt.annotation.NonNull;  @Target(ElementType.TYPE_USE) @interface TypeAnnotation { 	 } public class X<T> {    class Y {} 	void foo(@NonNull X<@NonNull ?> l) {  	}	 	public static void main(String[] args) { 		X<String> s = new X<>();                 s.foo(s);  	} }"
Eclipse Kepler  There appears to be a case where NewJavaProjectWizardPageTwo causes an SWT Invalid Thread Access when using Bndtools.  This problem has been reproduced by others.  To reproduce, create a new workspace, switch to the Bndtools perspective, create a new Bndtools OSGi project.  You should get the Invalid Thread Access.  The workaround is to delete the project you just created and create it again.  I believe the key here is that you have a brand new workspace.  Here is the stack trace.  org.eclipse.swt.SWTException: Invalid thread access    at org.eclipse.swt.SWT.error(SWT.java:4397)    at org.eclipse.swt.SWT.error(SWT.java:4312)    at org.eclipse.swt.SWT.error(SWT.java:4283)    at org.eclipse.swt.widgets.Display.error(Display.java:1204)    at org.eclipse.swt.widgets.Display.checkDevice(Display.java:759)    at org.eclipse.swt.widgets.Display.disposeExec(Display.java:1181)    at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.hookDisplay(ImageDescriptorRegistry.java:77)    at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.<init>(ImageDescriptorRegistry.java:40)    at org.eclipse.jdt.internal.ui.JavaPlugin.internalGetImageDescriptorRegistry(JavaPlugin.java:954)    at org.eclipse.jdt.internal.ui.JavaPlugin.getImageDescriptorRegistry(JavaPlugin.java:347)    at org.eclipse.jdt.internal.ui.wizards.buildpaths.CPListLabelProvider.<init>(CPListLabelProvider.java:68)    at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.<init>(BuildPathsBlock.java:189)    at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.getBuildPathsBlock(JavaCapabilityConfigurationPage.java:95)    at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.init(JavaCapabilityConfigurationPage.java:151)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.initializeBuildPath(NewJavaProjectWizardPageTwo.java:318)    at bndtools.wizards.project.NewBndProjectWizardPageTwo.initializeBuildPath(NewBndProjectWizardPageTwo.java:106)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:252)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.performFinish(NewJavaProjectWizardPageTwo.java:484)    at org.eclipse.jdt.internal.ui.wizards.JavaProjectWizard.finishPage(JavaProjectWizard.java:82)    at org.eclipse.jdt.internal.ui.wizards.NewElementWizard$2.run(NewElementWizard.java:118)    at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)    at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)    at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345)    at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5331)    at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)    at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
A quick assist can be added to infer lambda parameters in a lambda expression which has type inferred (type-less) parameters.   It would be useful to know the types of the lambda parameters explicitly, in cases where the functional interface is not in the same class or project.  Example: Invoking infer lambda parameters quick assist on the lambda expression:   Button button = new Button(); button.addActionListener(e -> foo());  should result in:  Button button = new Button(); button.addActionListener((ActionEvent e) -> foo());
BETA_JAVA8:   With the deep encoding of type annotations, most subsystems of the compiler should stop using == and != for binding comparisons and use TypeBinding.equalsEquals and its counterpart.  We need an automated way to catch these places. I propose that we build a special build environment compiler that would warn on type binding comparisons.  Once it is operational, we may want to allow a mechanism to tolerate == and != comparisons on specially tagged situations like the FALL-THROUGH tag for switch cases without breaks.
In the ArrayType implementation specify the white space requirements  Ref bug 413569 comment 18 last two items (reproduced below)  - ASTRewritingStatementsTest file, testBug400568_a_since_8 has two additional white spaced after removal of annotations on dimensions. To be changed?  - TypeAnnotationsConverterTest -  String [] [] [] [] - do we need these spaces if there are no annotations on dimensions?
"import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator;  public class Snippet {  	void foo() { 		Collections.sort(new ArrayList<String>(Arrays.asList(""c"", ""b"", ""a"")), 				new Comparator<String>() { 					@Override 					public int compare(String o1, String o2) { 						return o1.compareTo(o2); //[1] 					} 				});  		Collections.sort(new ArrayList<String>(Arrays.asList(""c"", ""b"", ""a"")), 				(String o1, String o2) -> o1.compareTo(o2)); //[2] 	} } -------------------------  Hover over #compareTo at the specified locations [1] and [2]. Javadoc is shown on hover only at [1] and not at [2]."
Consider the below method: public void foo(java.io.@TypeUse FileNotFoundException arg, A type){ } When 'move' refactoring is invoked on #foo: ImportRewrite#addImport(ITypeBinding binding, AST ast, ImportRewriteContext context) is invoked with the VariableBinding corresponding to <java.io.@TypeUse FileNotFoundException arg>, where it is expected to return a PackageQualifiedType which contains the TYPE_USE annotation details as well. This is not currently handled in #addImport(...)and the method returns a SimpleType and the TYPE_USE annotation details are missing.
We must support the extension to the language model API - specifically javax.lang.model.AnnotatedConstruct.getAnnotationsByType(Class<A>) - in order to support annotation processing of repeated annotations.
"package org.eclipse.jdt.demo;  class Math { 	public static int max(int a, int b) { 		if (a > b) return a; 		return b; 	} 	public static int min(int a, int b) { 		if (a < b) return a; 		return b; 	} 	// ... }  interface BinaryOperator<T> { 	T evaluate(T left, T right); }  class Calc { 	BinaryOperator<Integer> max1 = (a, b) -> Math.max(a, b); 	BinaryOperator<Integer> max1 = Math.max| }  Ctrl+Space at the specified location ""|"" after Math.max results in NPE:  org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63) ... ... Caused by: org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:125) ... ... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.util.ObjectVector.contains(ObjectVector.java:75) 	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.computeVisibleElementBindings(InternalExtendedCompletionContext.java:224) 	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.getVisibleElements(InternalExtendedCompletionContext.java:376) 	at org.eclipse.jdt.internal.codeassist.InternalCompletionContext.getVisibleElements(InternalCompletionContext.java:324) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.getAssignableElements(ParameterGuessingProposal.java:113) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.guessParameters(ParameterGuessingProposal.java:322) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeGuessingCompletion(ParameterGuessingProposal.java:254) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeReplacementString(ParameterGuessingProposal.java:220) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getReplacementString(LazyJavaCompletionProposal.java:331) ..."
"package com.test_a.t1;  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.List;   @Target(ElementType.TYPE_USE) @interface Readonly { }  class UnmodifiableList<T> implements @Readonly List<@Readonly T> { }  ---------------------------- Edit the file. We get multiple exceptions in the error log view:  Error in JDT Core during AST creation  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.constantPoolName(TypeVariableBinding.java:303) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.signature(ReferenceBinding.java:1651) 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.signature(MethodBinding.java:1142) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateMethodInfoHeader(ClassFile.java:3282) 	at org.eclipse.jdt.internal.compiler.ClassFile.addMissingAbstractProblemMethod(ClassFile.java:584) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateMissingAbstractMethods(ClassFile.java:3342) 	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:853) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:573) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:367) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1213) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) ..."
"Fresh install of Eclipse 4.3 with a new workspace. Create a new maven based projects based on the quickstart archetype. Add a dependency on org.jooq:jooq:3.1 (http://www.jooq.org/) Create a new class with a main method. In the method type:     DSLContext ctx=DSL.using(SQLDialect.ORACLE);     ctx.  <- autocompletion pops up here Press 's' (to look for 'select' method)  Autocompletion stops working and the following exception is logged in the error.log: Message: Unhandled event loop exception Stack trace: org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.ArrayIndexOutOfBoundsException: 1) 	at org.eclipse.swt.SWT.error(SWT.java:4397) 	at org.eclipse.swt.SWT.error(SWT.java:4312) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3366) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: java.lang.ArrayIndexOutOfBoundsException: 1 	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findMethodParameterNames(InternalCompletionProposal.java:314) 	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findParameterNames(InternalCompletionProposal.java:1440) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.appendUnboundedParameterList(CompletionProposalLabelProvider.java:113) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createMethodProposalLabel(CompletionProposalLabelProvider.java:272) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createStyledLabel(CompletionProposalLabelProvider.java:570) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.computeDisplayString(LazyJavaCompletionProposal.java:263) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getDisplayString(LazyJavaCompletionProposal.java:246) 	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.isValidPrefix(AbstractJavaCompletionProposal.java:802) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.isValidPrefix(LazyJavaCompletionProposal.java:378) 	at org.eclipse.jdt.internal.ui.text.java.JavaMethodCompletionProposal.isValidPrefix(JavaMethodCompletionProposal.java:289) 	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.validate(AbstractJavaCompletionProposal.java:754) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1486) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1449) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:375) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	... 24 more  Googling for a solution I've also found the same issue reported in the following bug report on a different library: https://code.google.com/p/projectlombok/issues/detail?id=545  Session data: eclipse.buildId=4.3.0.I20130605-2000 java.version=1.7.0_25 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=it_IT Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product"
"BETA_JAVA8:  We just ran into this testing APT changes for JSR308.  Given:  // --- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;   public class X { 	int @Nullable [] f @NonNull [] = null;  } // ----   on the compiler side, when incorrectly fold the extra dimensions into total  dimensions and end up with   int @Nullable [] @NonNull [] f;  It should be   int @NonNull [] @Nullable[] f;  Since in a C style array declaration, the extra dimension should bind more readily with the field than any type components preceding it.  While the compiler side story is easy to fix, it will break DOM/AST encoding unless care it taken: some original dimensions could start showing up as extra dimensions and vice versa !  I think it is not hard to fix cleanly end to end. I'll see what can be done."
"Created attachment 235915 [details] Project  Tested on Eclipse 4.3  Steps to reproduce: 1 _ download and install attached project 2 _ notice the nullness error on doSomething which is correct 3 _ check doSomethingGeneric method. It is declared the same way as doSomething, expect it uses generic. However no error is reported  Expect behavior: An error should be reported for the generic type as well  Tested code:  public interface GenericInterface<T> { 	T doSomethingGeneric(T o); }  public interface Interface { 	Object doSomething(Object o); }  @ParametersAreNonnullByDefault public class Implementation implements GenericInterface<Object>, Interface {  	@Override 	public Object doSomethingGeneric(Object o) { // <-- this error is not reported 		return o; 	}  	@Override 	public Object doSomething(Object o) { // <-- this error is correctly reported 		return o; 	} }"
"BETA_JAVA8:  // --- class Outer<K>  { 	class Inner<P> { 	} 	public @T(1) Outer<@T(2) String>.@T(3) Inner<@T(4) Integer> @T(5) [] omi @T(6) []; } @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE) @interface T { 	int value(); } // --  Given the above, ECJ generates only 5 annotations. There should be 6. The one with the type path: FIELD, location=[ARRAY, ARRAY, INNER_TYPE] is absconding.  AST and bindings look correct.   While debugging, you may notice that the extended dimensions would appear ahead  of the base dimension. This is the right behavior. See bug 418096."
Version: 4.2.0  Build id: I20120608-1400  Tests below started to fail from JDK8 b108 in org.eclipse.ltk.core.refactoring.tests package: testReadDescriptor4 testReadDescriptor5   Expected refactoring descriptor is not equal to actual one: expected:<... comment,arguments={[arg1=value 1, version=1.0]},flags=1]> but was:<... comment,arguments={[version=1.0, arg1=value 1]},flags=1]>  junit.framework.ComparisonFailure: Expected refactoring descriptor is not equal to actual one: expected:<... comment,arguments={[arg1=value 1, version=1.0]},flags=1]> but was:<... comment,arguments={[version=1.0, arg1=value 1]},flags=1]> at org.eclipse.ltk.core.refactoring.tests.history.RefactoringHistorySerializationTests.compareReadHistory(RefactoringHistorySerializationTests.java:65) at org.eclipse.ltk.core.refactoring.tests.history.RefactoringHistorySerializationTests.testReadDescriptor4(RefactoringHistorySerializationTests.java:216) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:501) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:259) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3529) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3182) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1022) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:916) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:585) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:540) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) at org.eclipse.equinox.launcher.Main.run(Main.java:1438) at org.eclipse.equinox.launcher.Main.main(Main.java:1414) at org.eclipse.core.launcher.Main.main(Main.java:34)  Steps to Reproduce: Use eclipse-Automated-Tests-4.2 to run automated tests with jdk8. 1. Install jdk8 (b108 or b109) from http://jdk8.java.net/download.html  2. Run ltkcorerefactoringtests   The failures are reproducible on solaris & windows (32-bit)
"The following NPE ensures I don't get any work done.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getEnclosingReferenceTypeName(JavaBreakpoint.java:242) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.createRequests(JavaBreakpoint.java:595) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.addToTarget(JavaBreakpoint.java:584) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.addToTarget(JavaLineBreakpoint.java:172) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointAdded(JDIDebugTarget.java:1287) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initializeBreakpoints(JDIDebugTarget.java:522) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initialize(JDIDebugTarget.java:448) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.<init>(JDIDebugTarget.java:315) 	at org.eclipse.jdt.debug.core.JDIDebugModel$1.run(JDIDebugModel.java:183) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:187) 	at org.eclipse.jdt.internal.launching.StandardVMDebugger.createDebugTarget(StandardVMDebugger.java:471) 	at org.eclipse.jdt.internal.launching.StandardVMDebugger.run(StandardVMDebugger.java:347) 	at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.launch(JUnitLaunchConfigurationDelegate.java:174) 	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:858) 	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:707) 	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1018) 	at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1222) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
BETA_JAVA8:  There is some set up issue in TypeBindingTests308.java - when run by itself the tests testAnnotatedBinaryType* pass. When run as part of RunAllJava8Tests they fail. I fixed one issue to with picking up wrong JCL libraries, but that does not seem to be all there is to it. Now the tests are failing with "Outer cannot be found" which tells me that the library got added to the wrong project - i.e the working copy from which an AST is built is from a different project than the one to which the library was addeded.
We have gone back and forth with a few different attempts at this, but no satisfactory solution so far.  NTAT:_testConditional2 is the disabled test.  I would recommend we explore an option that does not modify the routines invoked by scope.lowerUpperBound and keep all machinery to support this outside if possible.  -- We don't have an issue if types are == -- We likely don't have an issue if lowerUpperBound returns an intersection type as is (is this true ?) -- We have an issue when the disparately annotated types collapse into one of the constituents.  Perhaps we can write a method ConditionalExpression#lowerUpperBound that would call scope.scope.lowerUpperBound and trap the case where the latter returns a single type and come up with a solution that would reannotate  appropriately. This would leave the JLS routines untouched. I think some incarnations of this may have existed earlier and I may have pruned it believing a simpler solution could be come up with - sorry if this is the case.  We need to see if the same issue rears it heads with multi catch blocks. Jay, please write an annotation processor that would query the type of a catch parameter - I believe local variables annotations are exposed.  We want to see what the binding that corresponds to the UTC contains when the constituent type references are equally type annotated and unequally type annotated.
##### Bug explanation #####  Usage of  ASTParser.createASTs(String[] sourceFilePaths, String[] encodings, String[] bindingKeys, FileASTRequestor requestor, IProgressMonitor monitor) with option ASTParser.setResolveBindings( true ) produce many org.eclipse.jdt.core.dom.CompilationUnit objects. Each of them contains its own AST object,  with own DefaultBindingResolver object,  which shares SINGLE DefaultBindingResolver.BindingTables with every other DefaultBindingResolver (and so AST,  and CompilationUnit objects) created during  single "createASTs" batch parsing call.  DefaultBindinResolver Javadoc says: "* IMPORTANT: The methods on this class are synchronized. This is required  * because there may be multiple clients in separate threads concurrently  * reading an AST and asking for bindings for its nodes. These requests all  * end up invoking instance methods on this class. There are various internal  * tables and caches which are built and maintained in the course of looking  * up bindings. To ensure that they remain coherent in the presence of multiple  * threads, the methods are synchronized on the DefaultBindingResolver instance."  Unfortunately parsing (performed as described above) creates many  DefaultBindingResolvers with shared single BindingTables object so all those synchronisations on methods do nothing to prevent asynchronous modifications of this maps. Such events do happen during any of various "resolveBinding()"-like method calls performed by multiple threads.  ######## Errors the bug causes ########  In case of our project the bug often cause a damage of DefaultBindingResolver.BindingTables.compilerBindingsToASTBindings HashMap, which makes our threads constantly running on HashMap.getEntry on  INFINITE LOOP, which looks like following:  java.lang.Thread.State: RUNNABLE at java.util.HashMap.getEntry(HashMap.java:446) at java.util.HashMap.get(HashMap.java:405) at org.eclipse.jdt.core.dom.DefaultBindingResolver.getTypeBinding (DefaultBindingResolver.java:526) - locked <0x00000000b6da8bb0>  (a org.eclipse.jdt.core.dom.DefaultBindingResolver) at org.eclipse.jdt.core.dom.MethodBinding.getDeclaringClass (MethodBinding.java:131) ...  We use ASTParser.createASTs(..) instead of multiple ASTParser.createAST(..)  because the amount of used memory drop is quite significant (we had to store part of IBinding objects in memory).   ######## Proposed solution ########  The solution may be as simple as using ConcurrentHashMap in  DefaultBindingResolver.BindingTables.
http://download.eclipse.org/eclipse/downloads/drops4/N20131002-2000/testResults.php
Created attachment 236121 [details] the semicolon makes the difference  The result of detecting so called 'additional occurences' depends on whether or not the selection includes the semicolon.  See Screenshot.
NullTypeAnnotationTest.testWildcardCapture3() shows an example where a @Nullable type is successfully passed to a @NonNull parameter.  The expected type has contradictory annotations and I think we look at @Nullable first and allow it to pass through.  I think it may in general be a good idea to check for @NonNull first since violating it unsafe.
"BETA_JAVA8:  In LookupEnvironment::LookupEnvironment, we have this code:  boolean stillTesting = true; if (this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && (stillTesting || this.globalOptions.storeAnnotations)) { 		this.typeSystem = new AnnotatableTypeSystem(this); 	} else { 		this.typeSystem = new UnannotatedTypeSystem(this); 	}  At some suitable point, we should remove the boolean and let the other gating conditions decide whether bindings should carry annotations or not.  Raising this defect so we don't drop this ball."
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=413613#c24:  That leaves us with 3 old failures. These are in two buckets:  (1) testTypesWithSystemCompiler and testTypesWithEclipseCompiler are due to the same problem. In JRE8, the class HashMap#HashIterator is not generic. I believe it was previously generic (JRE7 ?)  I suspect this class is not standard API since it is missing in IBM JREs (See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=258906)  Tests should be rewritten to avoid using non-standard classes.  (2) The other bug is due to as Jay mentioned how the javadoc is differently formatted. I see this comment in ElementsImpl#formatJavadoc:  /** 	 * Strip the comment characters from a javadoc comment. Assume the comment is already 	 * missing its closing delimiter. 	 * 	 * Javac's behavior with regard to tab expansion and trimming of whitespace and 	 * asterisks is bizarre and undocumented.  We do our best here to emulate it. 	 */  So the tests should be rewritten to convert all tabs to spaces, strip out all non-significant white spaces before comparing."
BETA_JAVA8:   We presently copy, but we should move the SE8 annotations that feature in SE7  locations so the field, local, parameter, method does not reflect this binding.  See org.eclipse.jdt.internal.compiler.ast.ASTNode.copySE8AnnotationsToType(BlockScope, Binding, Annotation[])
ASTRewrite should allow removing the left and right operands of an infix expression. We need this for a clean fix for bug 406347. Fix is already ready.  <rant>The design of InfixExpression is flawed. We should not have created separate properties for the first two operands. We can't change that now, but we should keep this in mind for future AST nodes.</rant>
Created attachment 236249 [details] Test case to reproduce the issue  Outer1. @Marker1 Inner is represented as a SimpleType of QualifiedName where the anotations sit on SimpleType, while QN includes Outer1 and Inner but not the annotation. Need to alter the representation. [follow up of bug 417659]
JDT Core: 3.9.1.v20131009-0108-BETA_JAVA8  The following code is flagged as incorrect:           // Person: one of its methods is public String getLast() {...}         List<Person> roster = ...;                  Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         p -> p.getLast(), [1]                         p -> p            [2]                     ));  The BETA_8 JDT shows these 2 error message:  [1] The method getLast() is undefined for the type T [2] Type mismatch: cannot convert from T to U  If expressed as follows:           Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         Person::getLast,     [3]                         Function.identity()                     ));  The BETA_8 JDT now shows this error:  [3] The type Person does not define getLast(T) that is applicable here  Even the following has a problem:           Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         new Function<Person, String>() {    [4]                             public String apply(Person p) {                                  return p.getLast();                              }                          },                         Function.identity()                     ));  [4] Type mismatch: cannot convert from Map<String,Object> to Map<String,Person>  There actually seems to be a regression with the most recent nightly build compared to some from a few weeks ago: in the earlier one, problem #[4] did not occur.   For contrast, Netbeans nightly build (201310070001) handles all these just fine, and it actually makes suggestions for refactoring from the anonymous class to a lambda, and more.   Eclipse can be seen to be lagging a good bit behind here, I'm sorry to say.
"master and BETA_JAVA8  ITypeBinding#getModifiers() misses the implicit ""static"" modifier for member interfaces of a class:  public class C { 	interface IC {} // implicitly static, see JLS7 8.5.1 }  (If you wonder about the reference to JLS7 8.5.1, then you may have an old version of JLS7 that contains a section 8.5.2 and a bogus 8.5.1 that said IC would be implicitly public -- that part has been removed again)."
BETA_JAVA8:  From https://bugs.eclipse.org/bugs/show_bug.cgi?id=417113#c63:  // -- Working on type inference I discovered: - an InferenceVariable (subclass of TypeVariableBinding) appeared twice as a key in a HashMap, assumably caused by: - TypeBinding.hashCode relies on stability of TypeBinding.id - UnannotatedTypeSystem lazily assigns ids, which violates stability  In that particular case I can workaround by either of: - eagerly registering with UTS - overriding hashCode() and equals()  Raising this issue here, because: - the problem could potentially affect other subclasses of TypeBinding? - the lone hashCode() looks strange without a matching equals()  @Srikanth, do you have reasons at hand, why the existing code is safe, or should I file a new bug?  // --  No, the existing code is not safe as your HashMap experience shows. The id assignment is safe from the pov of UTS + ATS, but that is not good enough.  I'll work on resolving this asap. Thanks for catching this.
The spec says:  It is a compile-time error if a declaration is annotated with any annotations of a repeatable annotation type T and more than one annotation of the containing annotation type of T.  Assuming FooContainer is itself a repeatable annotation type with a containing annotation type of FooContainerContainer, one might expect the following code to be legal:  @Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)}) class A {}  But this code is allowed by eclipse compiler.
The implementation of JavaCorePreferenceModifyListener#preApply may cause unexpected removal of Java preferences. The issue was reported initially in bug 418046 and this bug will focus on changes required to fix the jdt.core part.  The node passed as an argument to the preApply method is always an IExportedPreferences node which means it is a "delta" that will be applied to the global hierarchy. If a listener modifies this delta by creating an empty node, then all preferences of this node will be removed in the global hierarchy.  Reproducible scenario: 1. Download the plugin from https://bugs.eclipse.org/bugs/attachment.cgi?id=235817 2. Import it to your workspace. 3. Start self-hosted Eclipse. 4. Modify one of Java preferences in Window > Preferences > Java > Compiler, e.g. change compiler compliance to "1.3". Click OK. 5. Restart the inner Eclipse. => Check that compiler compliance is set back to the default and our "1.3" is lost.
In my current understanding of JSR 335 spec 0.6.3, type inference needs the following bits of information, which should probably be computed and stored during overload resolution:  - strict / loose / variable-arity invocation  - "pertinent to applicability"  Both are   produced by: 15.12.2.2-4   consumed by: 18.5.1 (and .2)
The features 'all references' and 'all instances' may not work properly and throw NPE in Eclipse.  Cause: JDIDebugTarget.getJavaTypes(String) returns null if requested object was not loaded. The JDI Model implementation assumes that java.lang.Object[] is loaded whenever 'all references' or 'all instances' features are executed.  Fix suggestion: Check for a null value in constructors JDIReferenceListValue.<init>(IJavaObject) and JDIAllInstancesValue.<init>(JDIDebugTarget, JDIReferenceType). The null value can be returned by JDIDebugTarget.getJavaTypes(String) method.   I must admit I cannot proof what exactly is in accordance with the JVM Specification but I am deeply convinced the Object[] is not guaranteed to be loaded before the main method of the application is entered.   How to reproduce this bug: Use a VM that doesn't load java.lang.Object[] by default such as Java PathFinder (http://babelfish.arc.nasa.gov/trac/jpf).   I will create a pull request on Github to fix this bug.   Thanks, Stepan
BETA_JAVA8:  The following program fails to compile. We get: Type mismatch: cannot convert from Class<TC> to Class<? extends Annotation>  // -- import java.lang.annotation.Annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @R(TC.class) @Target(ElementType.TYPE_PARAMETER) @interface T { }  interface I<@T K> { }  @Deprecated @interface TC {  }  @Target(ElementType.ANNOTATION_TYPE) @interface R {     Class<? extends Annotation> value(); }  I have released a test TypeAnnotationTest.testForwardReference() encoding the wrong behavior - The test needs to fixed along with the problem.
Created attachment 236449 [details] Patch changing the ordering of boot and endorsed libs  The org.eclipse.jdt.internal.compiler.batch.Main used in a standalone environment has problems with initializing the classpath in the correct ordering. The relevant elements are: * The bootclasspaths containing the JVM libraries * The endorsedDirClasspaths containing the endorsed libs (http://docs.oracle.com/javase/6/docs/technotes/guides/standards/)  The endorsed libs need to overrule the JVM bootclasspath to fulfill it's purpose. In the current implementation the bootclasspath is added first and the endorsed are added later. This causes, that the compiler loads the JVM classes prior the classes contained in endorsed directory, which makes them useless.  The wrong ordering is initialized in the setPaths(..) method of the org.eclipse.jdt.internal.compiler.batch.Main class. In line 4533 the assembling of the final classpath starts with the bootclasspaths and adds the endorsedDirClasspaths in the first step, which causes the wrong ordering. A attached a patch which corrects the ordering.
"BETA_JAVA8:  The following program results in a class file in which the method foo() is annotated with @T. This is incorrect and needs to be fixed:  // --- import java.lang.annotation.ElementType; import java.lang.annotation.Target;   @Target({ElementType.TYPE_USE, ElementType.FIELD}) @interface T { 	 } public class X {     @T  	int foo() {  	   return 0;    } }"
"I see 3 POM version tool failures in my BETA_JAVA8 workspace:  Description	Resource	Path	Location	Type POM artifact version 3.3.401 does not match bundle version 3.3.400	pom.xml	/org.eclipse.jdt.apt.tests	line 22	POM Version Problem POM artifact version 3.9.0 does not match bundle version 3.8.2	pom.xml	/org.eclipse.jdt.core.tests.model	line 22	POM Version Problem POM artifact version 3.9.0 does not match bundle version 3.8.3	pom.xml	/org.eclipse.jdt.core.tests.compiler	line 22	POM Version Problem"
"I faced a NPE thrown in my runtime Eclipse. In this Eclipse instance I had no JRE's configured.  When now the project settings dialog is opened and selecting    Java Build Path / Libraries and selecting an unbound JRE System Library and pressing now the ""Edit"" button, a NPE is thrown.  I debugged that JavaRuntime#getDefaultVMInstall() returns null.  Inspecting this method I see that JavaRuntime#getDefaultVMId() returns ""52,org.eclipse.jdt.internal.launching.macosx.MacOSXType24,com.oracle.java.7u21.jdk"". getVMFromCompositeId() returns null for this identifier in my setup.  The error is caused by a misconfiguration in a rather unlikely scenario. However, BuildJREDescriptor#getDescription() should be more defensive for the case that no default VM is configured.   ---STACKTRACE-------------------------------------------- java.lang.NullPointerException 	at org.eclipse.jdt.internal.debug.ui.jres.BuildJREDescriptor.getDescription(BuildJREDescriptor.java:26) 	at org.eclipse.jdt.internal.debug.ui.jres.JREsComboBlock.createDefaultJREControls(JREsComboBlock.java:274) 	at org.eclipse.jdt.internal.debug.ui.jres.JREsComboBlock.createControl(JREsComboBlock.java:185) 	at org.eclipse.jdt.internal.debug.ui.jres.JREContainerWizardPage.createControl(JREContainerWizardPage.java:100) 	at org.eclipse.jface.wizard.Wizard.createPageControls(Wizard.java:174) 	at org.eclipse.jface.wizard.WizardDialog.createPageControls(WizardDialog.java:736) 	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:608) 	at org.eclipse.jface.window.Window.create(Window.java:431) 	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1089) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.ClasspathContainerWizard.openWizard(ClasspathContainerWizard.java:229) 	at org.eclipse.jdt.ui.wizards.BuildPathDialogAccess.configureContainerEntry(BuildPathDialogAccess.java:269) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.openContainerSelectionDialog(LibrariesWorkbookPage.java:888) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.editElementEntry(LibrariesWorkbookPage.java:564) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.editEntry(LibrariesWorkbookPage.java:477) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.libaryPageCustomButtonPressed(LibrariesWorkbookPage.java:272) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.access$0(LibrariesWorkbookPage.java:250) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage$LibrariesAdapter.customButtonPressed(LibrariesWorkbookPage.java:199) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.buttonPressed(TreeListDialogField.java:171) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.doButtonSelected(TreeListDialogField.java:400) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.access$2(TreeListDialogField.java:396) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField$2.widgetSelected(TreeListDialogField.java:361) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4136) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1458) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1481) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1271) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3982) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3621) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:158) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:468) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:885) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:567) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:508) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:123) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1074) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4135) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1458) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1481) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Control.traverse(Control.java:4789) 	at org.eclipse.swt.widgets.Control.translateTraversal(Control.java:4573) 	at org.eclipse.swt.widgets.Control.keyDown(Control.java:2369) 	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:600) 	at org.eclipse.swt.widgets.Tree.keyDown(Tree.java:1966) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5497) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2102) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2299) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5559) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5004) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5153) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3618) 	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701) 	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665) 	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499) 	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1414)"
BETA_JAVA8:  (1)  org.eclipse.jdt.internal.compiler.apt.model.Factory.getAnnotationsByType(AnnotationBinding[], Class<A>) returns an Annotation[] - this is wrong. It should return an A[].  (2) We should make a best case effort to match up AnnotationMirror#toString() output with javac, so that testing can be easy
This bug was reported in bug 402983 comment 21 https://bugs.eclipse.org/bugs/show_bug.cgi?id=402983#c21
"MethodDeclaration's receiverType cannot be an AnnotatableType, since ParameterizedType is not an AnnotatableType. Example:   package jsr335.invalid;  public class C {     class A<T> {         class Inner {              public Inner(A<T> A.this) { }         }     } }  java.lang.ClassCastException: org.eclipse.jdt.core.dom.ParameterizedType cannot be cast to org.eclipse.jdt.core.dom.AnnotatableType 	at org.eclipse.jdt.core.dom.ASTConverter.convertAndSetReceiver(ASTConverter.java:888) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:543) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
Hello,  at http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/Filer.html it is suggested to inherit from classes generated by annotation processors:  "Instead of modifying a class directly, the class is designed so that either its superclass is generated by annotation processing or ..."  I tried that approach and regognized the following: Eclipse APT seems to "forget" any error messages, that are reported by an annotation processor, as soon as the user creates a subclass of a generated class.  To reproduce, I have created a very simple processor, the always creates an error message and a single class called GeneratedClass. At first, the error message is shown as expected (for annotated class called "ExampleAnnotatedClass"). As soon as a subclass of GeneratedClass is added , the error message disappears. With maven , the error message is shown in both cases.  Steps to reproduce:  1.) unzip attachement 2.) for project eclipse-bug-processor, call "mvn install" to create the processor 3.) import project "eclipse-bug-test" as maven project into eclipse 4.) Either install the m2e-apt connector as suggested. (if not done before) Make sure, the m2e-option "Automatically configure JDT APT is selected" 5.) There is no APT error reported! 6.) Delete the class test.InheritedClass which extends GeneratedClass  7.) Clean / build the project 8.) Now, the error "Some Error Message" appears for ExampleAnnotatedClass.  (Note: I just use m2e-apt for easier configuration of the project. The bug also is there without maven... I have also attached the jar of the annotation processor. So, you don't have to use maven at all to reproduce.)
This looks the result of fix made in bug 416911.  http://download.eclipse.org/eclipse/downloads/drops4/N20131016-2000/testresults/html/org.eclipse.jdt.compiler.apt.tests_win32.win32.x86_7.0.html  And here:  http://download.eclipse.org/eclipse/downloads/drops4/N20131016-2000/testresults/html/org.eclipse.jdt.apt.tests_win32.win32.x86_7.0.html
"The code:  @Target({ElementType.TYPE_USE}) @Repeatable(FooContainer.class) @interface Foo {} @Target({ElementType.TYPE, ElementType.TYPE_USE}) @interface FooContainer { 	Foo[] value(); }   Produces an error: The container annotation type @FooContainer is allowed at targets where the repeatable annotation type @Foo is not: TYPE   The spec seems to mention something in the lines:  ""If Foo has an @Target meta-annotation, then in the judgment of the designers of the Java programming language, FooContainer must be declared with knowledge of the Foo's applicability. Specifically, the kind of program element where FooContainer may appear must be the same as, or a subset of, Foo's kinds.""  But not very specific. This bug is to discuss this further and take it to the EG if required.  Also note that the following code is allowed after removing TYPE from @Target of FooContainer:  @FooContainer({@Foo, @Foo}) public class X { }"
"Consider the below testcase:  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface TypeUse {  	int value(); }  public class Shape {  }  public class Square extends @TypeUse(1) Shape implements java.awt.@TypeUse Shape{ 	 }  In Square there will be 2 compiler errors. First resolve ""Add unimplemented methods"".  After this go to the second error, place the cursor just before <|>Shape{ press backspace so now there is no space between @TypeUse and Shape{, wait for a millisecond and now the Error Log will have few NPE's.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.copySE8AnnotationsToType(ASTNode.java:982) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1903) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1448) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:836) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)   Java Model Exception: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:248) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at"
M2: (This is probably a platform bug but ...)  Normally the JUnit view updates each test with a pass/fail decoration as the tests progress.  With M2 I am quite frequently seeing that some of the icon decoration updates have got lost. For instance I can open a test suite that reports that it and its predecessors are still to do, but discover that the tests have actually run (the per-test decorations are correct).  The "Runs" counts seem to update correctly, so the problem seems to be just one of decorator refresh.
BETA_JAVA8:  BinaryTypeBinding:655 reads:  // Note(stephan): currently the compiler is not interested in retrieving receiver annotations, here is how we would do it: // IBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor();  Apart from this action, we also need to create an annotated type instance for the declaring class and store it in org.eclipse.jdt.internal.compiler.lookup.MethodBinding.receiver.  javax.lang.model.element.ExecutableElement.getReceiverType() and javax.lang.model.type.ExecutableType.getReceiverType() should answer the annotated type.
BETA_JAVA8:  Element.getAnnotation() should return the annotations present on an element.  An annotation A is present on a construct C if either: ◆ A is directly present on C; or ◆ No annotation of A's type is directly present on C, and C is a class,  and A's type is inheritable (§9.6.3.3), and A is present on the superclass of C.  Element.getAnnotationsByType() should return all annotations associated with an element:  An annotation A is associated with a construct C if either: ◆ A is directly or indirectly present on C; or ◆ No annotation of A's type is directly or indirectly present on C, and  C is a class, and A's type is inheritable (§9.6.3.3), and A is associated  with the superclass of C.
A recent commit that addressed the need for hashCode and equals method to be defined for AnnotationBinding is causing a failure in this test which has been temporarily disabled.  org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test._test0276  The state is restored somewhat to what it was before https://bugs.eclipse.org/bugs/show_bug.cgi?id=192774.  Needs investigation.
BETA_JAVA8:  When calling getAnnotations() on an annotation type, I don't see TYPE_USE and TYPE_PARAMETER targets being restored properly.  Patch will follow shortly.
"BETA_JAVA8:  The following program is tolerated by javac 8b108;  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;   @Target(ElementType.TYPE_USE) @interface T { }  public class X { 	public static void main(String[] args) { 		Class<?> c = int @T [].class;  	} }   I believe oracle compiler is definitely at fault - this issue has been reported to them  until we hear confirmtion, we should turn our error into warning for now."
"1. Have an annotation and it's container as below in a project, let's say A:  @Deprecated public @interface FooContainer { 	Foo[] value(); }  @Repeatable(FooContainer.class) public @interface Foo { }  2. In the same project have this in another unit:  @FooContainer({@Foo(), @Foo()}) public class Main { }  You see the deprecated warning about FooContainer.  3. Create another project whose build path includes the bin folder of project 'A' 4. Create a similar class in the new project as step 2. 5. Notice no warning about FooContainer being deprecated."
"This code produces compilation errors:  public abstract class TestClass extends ParentClass { }  interface TestInterface { 	default int intMethod(){return 1;} }  class SuperParentClass { 	public int intMethod(){return 1;} }  abstract class ParentClass extends SuperParentClass implements TestInterface { 	abstract void parentMethod(String s); }  The reported errors (twice) being:  ""Duplicate methods named intMethod with the parameters () and () are inherited from the types SuperParentClass and TestInterface"""
"This is already allowed for static method imports from classes and the same should be allowed from interfaces too. Consider these two units:  -------------------- package a.b;  public interface J { 	static int foo(){return 0;} }  --------------------  package a;  import static a.b.J.foo; public interface I { 	static int call() { 		return foo(); 	} }  --------------------  Invocation of foo() is rejected with the following error but should not be:       This static method of interface J can only be accessed as J.foo"
Preparing to speak about JSR 308 at ECE I see that "Add implemented methods" nicely copies old annotations, but ignores type annotations.  While the implementation looks straight-forward, I'm not sure what's the plan regarding ASTProvider.SHARED_AST_LEVEL. Is it still at JLS4 because some operations are still used that only exist below JLS8?
org.eclipse.jdt.internal.corext.dom.Bindings.containsTypeVariables(ITypeBinding type)  This method consists of 6 if statements in a row. The 1st and 5th if statement are the same. Therefore the 5th one is never going to get executed because the first on returns.
BETA_JAVA8  package pack; import java.io.Serializable; import java.util.List; class C {     void foo(List<Integer> l) {         Integer i = (Integer & Serializable) l.get(0);     } }  On "l.get(0)", I get a wrong compile error: "The type Integer & Serializable is not visible".
"!ENTRY org.eclipse.jdt.core 4 4 2013-10-24 16:35:49.414 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr308.myex;  import java.io.Serializable; import java.util.List;  class En {     void foo(Object o) {         Integer i = (Integer & Serializable) o;         List<@NonNull Integer> l;     } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:269) 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:299) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:349) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:266) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:951) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:894) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveAnnotations(TypeReference.java:588) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:495) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:546) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument(TypeReference.java:554) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:238) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:359) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:191) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:568) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
"BETA_JAVA8  Bad AST recovery with a type annotation in a ParameterizedType and an unrelated syntax error in a secondary type.  The method En#bar() is missing a ; or a {}. This syntax error in the secondary class apparently turns the @NonNull annotation into a modifier of the FieldDeclaration for MyExamples#list2.   !ENTRY org.eclipse.jdt.core 4 4 2013-10-24 21:18:29.919 !MESSAGE Bad AST node structure: - parent [52, 80] org.eclipse.jdt.core.dom.FieldDeclaration    previous [57, 65] org.eclipse.jdt.core.dom.MarkerAnnotation    type [52, 73] org.eclipse.jdt.core.dom.ParameterizedType  ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr308.myex;  public class MyExamples { 	List<@NonNull String> list2; } class En {     void bar()     void foo() { } }   ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException: Bad AST node structure 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)"
Missing: org.eclipse.jdt.core.tests.dom,
BETA_JAVA8  AST#newArrayType(Type, int) should allow to create zero-dimension arrays. Otherwise, a client who already has Dimension nodes has to remove the auto-created first dimension.
Caused by fix for bug 416911.  Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131026-1500"; singleton:="true""  org.eclipse.test.EclipseTestRunner$TestFailedException: Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131026-1500"; singleton:="true"" at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:582) at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:521) at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
"BETA_JAVA8:  The following program generates an AIOOB exception:  // -- import java.util.Arrays;  public class X { 	public static void main(String [] args) { 		Integer [] array = new Integer[10]; 		Arrays.sort(array, Integer::compare);  	} }"
BETA_JAVA8  For JLS8, the ASTParser gives up on multi-dimensional array references in a MethodRefParameter and leaves the whole Javadoc node without any children. Still Works fine for JLS4.  /**  * Hello.  * @see #foo(Object[][][])  */
Created attachment 236948 [details] Test case  The attachment is a patch of a testcase in Java8ElementProcessor and it fails when Java8ElementTests are run.  The code is: public <T> Z(@Type T t){}  When ExecutableTypeImpl#getParameterTypes() is invoked with the above code, we look at the MethodBinding#parameters to create the TypeMirror. But the parameters contains a TypeVariableBinding but the binding doesn't contain the annotations.
"I suspect this problem is related to type inference which is currently being worked on by the JDT team. Please see the attached .java file for the entire source.  Specifically, the following compiles from the command line, but ""Integer::sum"" is flagged as an error, whose description is ""The type Integer does not define sum(Object, Object) that is applicable here"".  code:   		CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[]{})).thenApplyAsync( (Void v) -> { 			Integer finalResult = futures.stream().map( (CompletableFuture<Integer> f) -> { 				try { 					return f.get(); 				} catch (InterruptedException | ExecutionException e) { 					return 0; 				} 			}).reduce(0, Integer::sum);  (This is not my code. I am exploring the code from this blog post: http://blog.maxant.co.uk/pebble/2013/10/13/1381695720000.html. The git repository for this code is: https://github.com/maxant/share.git.  See the source in ""blog20131013_asyncJava8TrySuccessFailure/src/maxant/ch/async/blackboxtests/TestThreeCompletableFutureJava8.java"".)   -- Configuration Details -- Product: Spring Tool Suite 3.4.0.201310051614-RELEASE (org.springsource.sts.ide) Installed Features:  org.eclipse.jdt 3.9.1.v20130911-1000   $ java -version java version ""1.8.0-ea"" Java(TM) SE Runtime Environment (build 1.8.0-ea-b112) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b54, mixed mode)"
"BETA_JAVA8:   The following program should not compile, but does since RE drops the explicit type argument <String>.  // -- interface I { 	void sam(X t, Integer s); } public class X { 	<T> void function(T t) {} 	public static void main(String [] args) { 		I i = X::<String>function; 		i = X::function; 		i = X::<Integer>function; 	} }   Fix is trivial and will follow shortly."
"BETA_JAVA8:  // -- interface I { 	X<?, ?, ?>[] makeArray(int i); }  public class X<T, U, V> { 	public static void main(String [] args) { 		I i = X<?, ?, ?>[]::new; // OK. 		i = X<String, Integer, ?>[]::new; // ! OK 		X<?, ?, ?> [] a = new X<?, ?, ?>[10]; // OK 		a = new X<String, Integer, ?>[10]; // ! OK 		System.out.println(i.makeArray(1024).length); 	} }    We reject the first line tagged as OK, we should allow it.  Fix is trivial, will follow shortly."
"BETA_JAVA8:  The following program triggers an incorrect error message: The target type of  this expression is not a functional interface: more than one of the intersecting  interfaces are functional  The intersection should collapse to the most specific type when there is a supertype - subtype relationship between two constituents.  // -- import java.io.Serializable; interface I { 	void foo(); } interface J extends I { 	void foo(); } interface K { } public class X { 	public static void main(String[] args) { 		I i = (I & Serializable) () -> {}; 		i = (I & J & K) () -> {}; 		i = (J & I & K) () -> {};   	} }"
Make the "effectively final" state of local variables available. Should be easy to do in IVariableBinding. Would also be very handy in ILocalVariable if possible.  We could sneak this into getModifiers()/getFlags() with an internal flag, but I guess it's better to add a boolean isEffectivelyFinal() API instead.
"I encountered this while analyzing a project. Tried it with ASTView plugin with the same results. The stack trace and a minimal example to reproduce:  Note: hasResolvedBindings: true hasStatementsRecovery: true hasBindingsRecovery: true  Exception Stack Trace: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding 	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveType(DefaultBindingResolver.java:1581) 	at org.eclipse.jdt.core.dom.Type.resolveBinding(Type.java:181) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:161) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getChildren(ASTViewContentProvider.java:97) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.hasChildren(ASTViewContentProvider.java:230) 	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2146) 	at org.eclipse.jface.viewers.TreeViewer.isExpandable(TreeViewer.java:588) 	at org.eclipse.ui.part.DrillDownAdapter.canExpand(DrillDownAdapter.java:106) 	at org.eclipse.ui.part.DrillDownAdapter.canGoInto(DrillDownAdapter.java:142) 	at org.eclipse.ui.part.DrillDownAdapter.updateNavigationButtons(DrillDownAdapter.java:339) 	at org.eclipse.ui.part.DrillDownAdapter.selectionChanged(DrillDownAdapter.java:329) 	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:164) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49) 	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175) 	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:162) 	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2188) 	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1211) 	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1241) 	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:239) 	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:233) 	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:403) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4136) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1458) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1481) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1271) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3982) 	at org.eclipse.swt.widgets.Display.applicationNextEventMatchingMask(Display.java:4871) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5241) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.mouseDownSuper(Widget.java:1093) 	at org.eclipse.swt.widgets.Tree.mouseDownSuper(Tree.java:2052) 	at org.eclipse.swt.widgets.Widget.mouseDown(Widget.java:1085) 	at org.eclipse.swt.widgets.Control.mouseDown(Control.java:2538) 	at org.eclipse.swt.widgets.Tree.mouseDown(Tree.java:2007) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5495) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2102) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2299) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5559) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5004) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5153) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3618) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1053) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:942) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)  Session Data: eclipse.buildId=M20130204-1200 java.version=1.7.0_21 java.vendor=Oracle Corporation BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US Framework arguments:  -product org.eclipse.epp.package.rcp.product -keyring /Users/shahi/.eclipse_keyring -showlocation Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.rcp.product -keyring /Users/shahi/.eclipse_keyring -showlocation  Minimal Example to reproduce:  public class TestClass { 	 	SomeUndeclaredType<?>[] undeclaredField;	// works fine 	 	public static void main(String[] args) { 		SomeUndeclaratedType<?>[] undeclaredLocalDeclaration;	//ClassCastException 	}  }  FieldDeclaration gets around this issue because of line 205, which says ""update binding for type reference"" in comment."
Change the minimum execution environment for org.eclipse.jdt.core from J2SE-1.4 to JavaSE-1.6.  This will allow the use of Java 1.5 and 1.6 language features in ongoing development and in the refactoring of internal jdt.core classes.  Note that this bug neither requires nor suggests any changes to public API classes of jdt.core or migration of existing jdt.core code; it is assumed that those things would be proposed and tracked separately if and when they were deemed appropriate.  This bug simply allows the use of generics, enums, and other language features introduced since 1.4 to facilitate development and avoid the accumulation of technical debt within internal jdt.core code.
Per Javadoc, ITypeBinding.getDeclaredModifiers() is supposed to return "the modifiers ... as specified in the original source declaration of the class or interface". In the present implementation, it simply delegates to getModifiers() which is wrong.
"BETA_JAVA8:  The following program triggers an operand stack underflow error:  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface T {}  public class X { 	public static void main(String argv[]) { 		Object o = (@T Object) new Object();     	} }   Fix will follow shortly. To reproduce the option ""preserved unused locals"" must be turned off at the project level.  Fix is trivial, will follow shortly."
A new enum (Modifier#DEFAULT) has been added in SE 1.8 and APT should start supporting this modifier for default interface methods. At the moment it's not very clear what's the right way - to move the project to 1.8 compliance level or use reflection or some other means to include DEFAULT.
By analyzing UI delays logged using the (new in Luna) UI Performance Monitoring API, we saw that ~50% of all JDT-related UI delays greater than 500ms are attributed to low hit rates in the JavaModel caches, which are currently evicted on every Java-related resource change and every Java build.  The JavaModel existingExternalFiles and existingExternalCommittedFiles caches cache the return value of java.io.File.isFile() and are used heavily by JavaProject.findPackageFragmentRoots() and related calls. By giving the DeltaProcessor class the sole responsibility of updating these caches, we see a speedup of ~56x in calculating JavaProject.findPackageFragmentRoots for a project with ~4200 jars (see below for more details).  The changes to improve the caching include:  * Remove the JavaModel existingExternalFiles and existingExternalCommittedFiles   caches, replacing them with an updated JavaModelManager externalFiles cache   and a new assumedExternalFiles cache. * Make the DeltaProcessor fully responsible for updating the cached values with   current file system state. This is triggered only by calls to DeltaProcessor   .refreshExternalArchives() and PRE_REFRESH events in the DeltaProcessor's   IResourceChangeListener. The previous JavaModel caches were invalidated on   every incremental build and Java file resource change. * In addition, evict the cache if a Java project has multiple builders and   the first builder is not the Java builder, since previous builders may   create jar artifacts that are consumed by the Java builder. * Looking at the two JavaModel caches, both are populated using the same   criteria and evicted at the same time, so there really never was a need   for two separate caches. See http://bugs.eclipse/org/83750   "[perf] Excessive File.isFile calls for clients of JavaModel.getTarget(...)"   for the history of the existingExternalCommittedFiles cache. * Add a performance test for this change. When with on our patched Eclipse 4.3.1   release, which adds the Google-supplied performance patches that have already    been applied to Luna, we get the following results for a classpath containing   100 jars:   Unpatched, local file system: 18ms   Patched, local file system:   18ms   Unpatched, NFS file system:   43ms   Patched, NFS file system:     18ms  In addition, we used JProfiler to profile patched and unpatched versions of Eclipse on a project with ~4200 jars, where the jars are stored on a file system with performance similar to NFS, using the following test:  1) Open Java editor tabs for a file in each of projects A and B 2) Disable Project > Build Automatically 3) Turn on 'Link with Editor' in the Package Explorer 4) Collapse all in the Package Explorer 5) Select project A's Java editor tab, edit and save the file 6) Start profiling 7) Select project B's editor tab, wait for the Package Explorer to populate,    expand and select the file 8) Stop profiling  AbstractTreeViewer.internalExpand is the entry point for the work of populating the Package Explorer tree view.  In the unpatched version, profiling showed that AbstractTreeViewer.internalExpand execution times were dominated by I/O in JavaProject.findPackageFragmentRoots. The average of 5 runs showed JavaProject.findPackageFragmentRoots taking ~3.0 seconds (3.2, 2.6, 3.2, 3.5, 2.8).  In the patched version, JavaProject.findPackageFragmentRoots goes from ~3.0 seconds to ~.053 seconds (.050, .058, .056, .040, .059). That is a ~56x speedup. Total AbstractTreeViewer.internalExpand time took on average ~.0283 seconds, throwing out one run where DecoratingStyledCellLabelProvider.getImage made a gtk call that took over a second to return. Of the five runs, no single function took a dominant amount of time, unlike the unpatched Eclipse, where I/O to repopulate the JavaModel caches was completely dominant.
"BETA_JAVA8  NPE in LocalDeclaration.resolve when performing content assist with an anonymous class in a lambda body. Same problem with a local class.  package jsr335; import java.util.function.IntFunction; public class Snippet {     void foo() {         IntFunction<String> toString = i -> {             //<-- Ctrl+Space here             new Runnable() {                 @Override                 public void run() {                     //<-- Ctrl+Space here                 }             }.run();             return Integer.toString(i);         };     } }  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:191) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:568) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1896) 	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:130) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345) 	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)  Stacktrace in bug 383096 looks similar, but that bug is about code with a syntax error."
BETA_JAVA8:  Staring at LocalVariableBinding.getAnnotations(), I see that there is a potential race condition there: The setting of declaringScope happens far away from the creation of LVB and if there are calls in between to getAnnotations(), we can't retrieve it from the annotation holder since this requires a handle to enclosing source type which is obtainable only from a scope.   To circumvent this, there is a block of code in this method that manufactures an array of annotation bindings and returns it without going to the holder. However, this is problematic since with Java 8 some of the annotations could actually be type annotations which should be detached from the parameters.  This block of code itself cannot filter the type annotations because there are clients that need to see all the annotations to transfer the type annotations  to type.  I think the solution is to set the declaring scope eagerly. At least for arguments, I don't know what side effects ensue for doing this for all locals.  Patch will follow shortly.
For this class declaration, ecj emits an error with a strange message and source range:  public class Snippet {     public default String getName() {         return null;     } }  Error message: Default methods are allowed only in interfaces with source level 1.8 or greater.  - For source level >= 1.8, I'd expect: Message: Default methods are allowed only in interfaces Range: 'getName()'  - For source level < 1.8, I'd expect either a syntax error, or the same error as I get for this example:  public class Snippet {     public volatile String getName() {         return null;     } }
Created attachment 237386 [details] Setting  I think most Eclipse projects (at least Eclipse platform, EGit and e4) ask their contributors to remove trailing whitespace from their contributions.  I suggest to add "Remove trailing white space on all lines" to the default Additional save actions.   I also think that "Use modifier final where possible" for private fields is currently not desired by the Eclipse projects.   This would result in setting similar to the attached screenshot.  Would JDT accept a patch for this change?
"BETA_JAVA8:  The following program triggers a verify error: Inconsistent stackmap frames at branch target 9, Current frame's stack size doesn't match stackmap.  // -- interface I { 	I foo(); }  public class X { 	public static void main(String[] args) { 		try { 			I i = () -> null; 		} catch (NullPointerException npe) {} 	} }  // --  The try/catch blocks seem to be required to reproduce."
"BETA_JAVA8:  The following program correctly triggers an error:   The type X must implement the inherited abstract method J.foo()  // -- interface I  { 	default void foo() {} }  interface J extends I { 	void foo(); } public class X implements J { }  However, if the types are generic, we don't issue an error:  // -- interface I <T> { 	default void foo(T t) {} }  interface J extends I<J> { 	void foo(J t); } public class X implements J { }"
"This program when compiled with ECJ and run produces a verify error:  interface I { 	public void foo(); }  class C implements I { 	public void foo() { 		System.out.println(""You won't get here""); 	} }  public class X { 	public static void main(String[] args) { 		((C & I) (I) new C()).foo(); 	} }  I am not sure if this is a valid program, but the code is compiled without any errors. When run, an exception with the following reason is thrown:  Reason:     Type 'I' (current frame, stack[0]) is not assignable to 'C'   Current Frame:     bci: @13     flags: { }     locals: { '[Ljava/lang/String;' }     stack: { 'I' }"
BETA_JAVA8  Wrong compile error if a throws declaration doesn't use the same TYPE_USE annotations as a declared variable of the thrown exception's type. If I remove the declaration of field 'e1', then the code compiles.   class E1 extends Exception {     private static final long serialVersionUID = 1L; }  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented @interface NonCritical { }  public class Exceptions {     @NonCritical E1 e1; // looks like this field's type binding is reused      //wrong error: //Cannot use the parameterized type E1 either in catch block or throws clause     void f1 (int a) throws /*@NonCritical*/ E1 {         throw new E1();     }          void foo() {         try {             f1(0); //wrong error: Unreachable catch block for E1. //             This exception is never thrown from the try statement body         } catch (@NonCritical final RuntimeException | @NonCritical E1 ex) {             System.out.println(ex);         }     } }
Document the new rules for ITypeBinding equality that have been established by bug 409586.  Javadocs of IBinding#equals(..), #isEqualTo(..), and #getKey() need updates. You may want to keep the general IBindings APIs and just add a reference to the ITypeBinding APIs, where the special rules for ITypeBindings can be explained at the level they apply to.  There's no need to special-case pre-JLS8 AST levels. The behavior for such ASTs is unchanged, and the special rules collapse to the old rules as soon as type annotations are out of the picture.
At the moment, we issue a warning. Javac does it too, but when the identifier is  for a lambda parameter, Javac rejects the code. This bug is to discuss this behavioral difference between ECJ and Javac.
"BETA_JAVA8:  // -- interface F { 	void foo(); }  interface I { 	default void foo() { 		F f = () -> { 		}; 	} }    public class X implements I { 	public static void main(String argv[]) { 		X x = new X(); 		x.foo(); 	} }  This program triggers a NoSuchMethodError because we emit invokeInterface instead of invokestatic - fix is trivial, will follow shortly."
Created attachment 237464 [details] Sample test setup with unused local variable  When the right hand side of the assignment expression is a call to a super class method, with explicit use of the super keyword, then the quick fix will remove the whole assignment.  public class Sub extends Super {     int callMethodWithSideEffectViaSuper()     {         int unused = super.methodWithSideEffect();         return state - 1;     } }  after the quick fix:  public class Sub extends Super {     int callMethodWithSideEffectViaSuper()     {         return state - 1;     } }  Same effect if you run into this as part of a source cleanup, i.e. [Window|Preferences|Java Code Style|Clean Up|Unnecessary Code|Remove unused local variables] is checked.
The whole org.eclipse.jdt.core.tests.eval suite is only run on Windows since: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=4ebeb381c4e8c6974f665730420b70c72062bb00  I didn't find an explanation why exactly it failed back in 2003, so I think we should just try to run it on Linux, and if it passes locally, then we can remove the onWin32 condition.
"BETA_JAVA8:  The following program is rejected by ECJ, but is accepted by javac.  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface T { 	 }  @T @interface T2 { 	 }  For compatibility sakes we should tolerate this."
"BETA_JAVA8   Tested with 8b115:  // -- interface I { 	int m(); 	public default int foo() { return 0; } }  interface T extends I { 	public default int m() {  		I i = I.super::foo;  		return i.foo(); 	} }  public class X { 	public static void main(String argv[]) { 		new T(){}.m(); 	} }   triggers an class format error. JVM does not like the synthetic being a static method."
BETA_JAVA8:  This bug is to track the work in the JDT debugger for supporting Java 8. Please treat this as the top level umbrella ER and raise unit level tasks as separate CR/ERs and link them to this as blockers.  At the outset, it would appear that the task is two folds:      1. Against a recent JRE (8b115 as of today) verify/ensure that all existing debugger tests are green.      2. Add support for debugging Java 8 constructs. I don't see 308, 269, JEP120 having any effect on the debugger - other than to perhaps verify that they are properly tolerated in snippets. For JSR335, we need to ensure that stepping through, breakpoints, inspection of values etc work as expected. For JEP118, verify that the debugger is able to avail and expose the parameter names.
"BETA_JAVA8 ----------  An earlier draft of JSR 335 required the compiler to eliminate overloaded method candidates based on whether the choice of that method would trigger errors in lambda body.  The latest draft has eliminated this requirement. As a result, the following program is no longer legal and should be flagged with an ambiguous method invocation error: 8b115 correctly exhibits this behavior, while eclipse compiles it fine and resolves the call to foo(I).  // -- interface I { 	int foo(int [] a); } interface J  { 	int foo(int a); } public class X { 	public static void main(String[] args) { 		System.out.println(foo((a)->a.length)); 	} 	static String foo(I i) { 		return(""foo(I)""); 	} 	static String foo(J j) { 		return(""foo(J)""); 	} }"
BETA_JAVA8:   Earlier drafts of JSR335 required the lambda body to be type checked and analysed over and over for every potentially applicable method. The latest draft has done away with this requirement, but we still need some information about the lambda even in the absence of target type in invocation contexts.      - Is a lambda value-compatible or void compatible or both ?     - Is a lambda explicitly typed or not ? If the former, what are its       parameter types ?     - What are the return expressions of the lambda ? Is one or more of them       pertinent to applicability ?  For reference expressions,      - Is a reference expression an exact one or an inexact one.  This ER is to implement a preprocess step in INVOCATION_CONTEXT's to gather this information.  As part of this, we should be able to reenable the two tests that were disabled namely:  NegativeLambdaExpressionsTest._test401610h NegativeLambdaExpressionsTest._test401610i
"BETA_JAVA8:  // -- interface I { 	void foo(); } interface J { 	int foo(); } public class X { 	static void goo(I i) { 		System.out.println(""goo(I)""); 	} 	static void goo(J j) { 		System.out.println(""goo(J)""); 	} 	public static void main(String[] args) { 		final boolean x = true; 		goo(()-> goo((I)null)); 	} 	int f() { 		final boolean x = true; 		while (x); 	} }  This program is incorrectly rejected with an error message, cannot return void result. This is because, we incorrectly tag the lambda as being value compatible."
"BETA_JAVA8:  Start with the following program in the editor:  interface I { 	void foo(); } interface J { 	int foo(); } public class X { 	static void goo(I i) { 		System.out.println(""goo(I)""); 	} 	static void goo(J j) { 		System.out.println(""goo(J)""); 	} 	public static void main(String[] args) { 		final boolean x = true; //		goo(()-> goo((J)null)); 	} 	 	int f() { 		final boolean x = true; 		while (x); 	} }  Delete the first three lines of code - until you save or otherwise modify the buffer you don't get to see errors on the use of I."
"BETA_JAVA8:  The following should compile, but does not at the moment:  // -- interface J { 	int foo(); } public class X { 	static void goo(J j) { 		System.out.println(""goo(J)""); 	} 	public static void main(String[] args) { 		final boolean x = true; 		goo(()-> {  			final boolean y = true; 			while (y);  			}); 		goo(()-> {  			while (x);  			}); 	} }"
"BETA_JAVA8: -----------  The following program compiles with ECJ, but fails to compile with 8b115.  It appears ECJ behavior is incorrect.  // -- interface I {  	int run(int s1, int s2);  }  class X { 	     static int f = ((I) (int x5, int x2) -> x1).run(10,  20);     static int x1 = 2; }"
"BETA_JAVA8:  // - interface I {  	int run(int s1, int s2);  }  class X { 	     static int f = ((I) (int x5, int x2) -> x1).run(10,  20);     static int x1 = 2; }   The cast is very much necessary as otherwise, the lambda's target type will be missing."
ExecutionEnvironmentDescription doesn't preserve the order of VM arguments provided in a .ee file (since it uses a plain HashMap), and the test org.eclipse.jdt.debug.tests.core.EEDefinitionTests.testVMArguments() happens to test a combination of VM arguments which under 1.7 just happens to hash in the tested order. Under 1.8 this false positive doesn't happen.  I'm supplying a patch which rectifies this.
(Everybody: You have to install the Eclipse Releng Tools and then enable the POM Version Tool in the preferences).  The JDT Core process of cherry picking changes from master to BETA_JAVA8 is problematic.  I now see POM version problems in BETA_JAVA8 of /org.eclipse.jdt.core.tests.model/pom.xml and /org.eclipse.jdt.core.tests.compiler/pom.xml. The actual reason is not a wrong version in the POM, but a wrong version the MANIFEST.MF.  Even worse, http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=5bf3b69e14807223b9c4f6e1446af8918e21aef4 tells me that this bug was introduced by bug 416740 and authored/signed-off-by by Mickael Istria. But I don't see what Mickael's contribution https://git.eclipse.org/r/#/c/17679/ should have done wrong -- it doesn't even touch the version number!  I really think the JDT Core team should stop using a manual cherry-picking process and should instead use the normal Git workflows. While we're working on BETA_JAVA8, you should periodically select origin/master and merge it into BETA_JAVA8. That way, you only have to deal with version number updates in master once: On the first merge after an update, you have to revert the version number updates in BETA_JAVA8 once. After that, Git won't try to update versions in BETA_JAVA8 any more, since that change has already been merged.
If I add lambdas to the simplest of classes, and tries to debug it, I will get soemthing like the following error text:  --------------------------------------------------  Unable to install breakpoint in demo.LambdaMain$$Lambda$1.380936215 due to missing line number attributes. Modify compiler options to generate line number attributes.  Reason: Absent Line Number Information  [ ] Don’t tell me again  --------------------------------------------------  I don't know why the warning is shown as I haven't tried to set the breakpoints in the function objects themselves. The function object classes are synthetic, even if the classes aren't marked as such (but that's inferred from the class, isn't it?), so perhaps that could be used to detect whether or not to show this warning.
Evaluation uses it's own method lookup logic which seems not to support default methods. Example:  Create a conditional breakpoint or watch expression is this form:  java.util.Arrays.asList("A","B").stream().count() == 2  You'll get the error: "Method "stream" with signature "()Ljava/util/stream/Stream;" is not applicable on this object"  This comes from JDIObjectValue.sendMessage  I wonder if there's a similar issue for static methods.
"BETA_JAVA8: The following program triggers an ambiguity.  // -- interface I {  	int foo();  } interface J {  	double foo();  } public class X { 	static int foo(I i) { 		return 0; 	} 	static int foo(J j) { 		return 1; 	} 	public static void main(String argv[]) { 		System.out.println(foo (() -> true ? 0 : 1)); 	} }"
InterfaceMethodTests uses two excuses from JavacHasABug, where the bug has been fixed meanwhile: - Javac8AcceptsDefaultMethodInAnnotationType - Javac8ProducesIllegalAccessError  Since the bug was in unreleased EA versions, I believe we should simply remove these excuses.  Additionally, testBug421543b() shows a warning (re missing @Override) only from ecj, not from javac. This situation should simply be avoided.
Running TestAll of compiler.regression with -Drun.javac and -Djdk.root pointing to 8b115 I get errors in two suites:  EnumTest.test180 / test180a throw NPE in AbstractRegressionTest.runJavac()  BatchCompilerTest:  - test230_sourcepath_vs_classpath  - test236_classpath - test238_classpath All through StringIndexOutOfBoundsException  I'm not sure whether this is specific to BETA_JAVA8.
Consider the below code snippet:  import java.io.Serializable;  interface I {     void doit(); }  public class X {   // Invoke code assist<Ctrl+space> in this location gives 20+ suggestions     Object o = (I & Serializable) () -> {}; // Invoke code assist<Ctrl+space> in this location gives just 4 template proposals     }  Invoking code assist just before and after a variable initialized using lambda gives different result.
"package test;  import java.util.ArrayList; import java.util.Collections;  class Z { 	private void foo() { 		Collections.sort(new ArrayList(), (o1, o2) -> { 			return o1.compareToIgnoreCase(o1); 		}); 	} } ----------------------------------- In the above example, edit something. We get the following exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:123) 	at org.eclipse.jdt.internal.compiler.ast.Statement.checkAgainstNullTypeAnnotation(Statement.java:151) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.checkAgainstNullAnnotation(ReturnStatement.java:177) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:76) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:297) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:491) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4355) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4331) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1508) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2540) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:674) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1011) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) ..."
When you rerun a test case in the same VM, a ComparisonFailure is treated as a normal failure (i.e. the compare window can't be opened).
BUILD ID: N20131120-2000  http://download.eclipse.org/eclipse/downloads/drops4/N20131120-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_linux.gtk.x86_6.0.html   Unexpected error running resulting class file for testFallThrough.java: --[START]-- Exception in thread "main" java.net.BindException: Address already in use at java.net.PlainSocketImpl.socketBind(Native Method) at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:376) at java.net.ServerSocket.bind(ServerSocket.java:376) at java.net.ServerSocket.<init>(ServerSocket.java:237) at java.net.ServerSocket.<init>(ServerSocket.java:128) at org.eclipse.jdt.core.tests.util.VerifyTests.run(VerifyTests.java:201) at org.eclipse.jdt.core.tests.util.VerifyTests.main(VerifyTests.java:198) ---[END]---  junit.framework.AssertionFailedError: Unexpected error running resulting class file for testFallThrough.java: --[START]-- Exception in thread "main" java.net.BindException: Address already in use at java.net.PlainSocketImpl.socketBind(Native Method) at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:376) at java.net.ServerSocket.bind(ServerSocket.java:376) at java.net.ServerSocket.<init>(ServerSocket.java:237) at java.net.ServerSocket.<init>(ServerSocket.java:128) at org.eclipse.jdt.core.tests.util.VerifyTests.run(VerifyTests.java:201) at org.eclipse.jdt.core.tests.util.VerifyTests.main(VerifyTests.java:198) ---[END]---  at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2344) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2120) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1191) at org.eclipse.jdt.core.tests.compiler.regression.SwitchTest.testFallThrough2(SwitchTest.java:1792) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
int[] @Annot1 [] = new int[1] @Annot1 [2]; gets reduced to int[]@Annot1[] = new int[1]@Annot1[2];
"package com.test;  class TestNPE { 	public static final C c = new C(); // Inline all references of 'c' 	private void test1() { 		int n = c.foo(0); 		test2(c); 	}  	private void test2(C m) {} }  class C { 	int foo(int x) { 		return x; 	} } --------------------------------------------------------------- Inline all references of 'c' at the line with comment in the above example. In the 'Inline Constant' dialog, click 'Preview', click 'Back' and click 'Preview' again. We get the following exception:  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:422) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663) ... ... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.getInitializer(InlineConstantRefactoring.java:800) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkFinalConditions(InlineConstantRefactoring.java:815) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) ..."
"BETA_JAVA8:  At present, there are a set of problems in the way type elided lambda parameters are handled by SelectionEngine/SelectionParser. Similar but different issues  exist with CompletionEngine/CompletionParser too.  Given:  // -- interface I { 	String foo(String x, Integer y); } public class X { 	static void foo(I i) {} 	public static void main(String[] args) { 		foo((x, y) -> x + y); 	} }   (1) if you hover on either of x or y in x + y, we claim those are of type Object - this is blatantly wrong, but happens because the selection parser builds minimal parse trees in which a good bit of the pertinent contextual information is lost.  The flattened parse tree for the method looks like:  public static void main(String[] args) {     (<no type> x, <no type> y) -> <SelectOnName:y>; }  See that the fact about lambda being a method parameter is completely lost.  I see this as requiring good amount of work to get correctly. Because lambda's can occur is deeply nested subexpressions, involving numerous node types, this is not going to be easy solution to ""enhance"" the selection/completion parser  (2) If you hover on the parameter declaration, you get nothing. This is problematic as users will identify this as a classic situation where the IDE should help clarify things for them.  (3) The hover on the use actually claims:   Object y - X.main(String[])  This could perhaps be due to bug 416559 ?   // --  Discussions welcome on how to go about solving this or alternate strategies."
"BETA_JAVA8, JDK 1.8.0-ea-b115  Open java.util.stream.Collectors and try to create an AST for it.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.analyseCode(CompoundAssignment.java:52) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:309) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:506) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:4616) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:501) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:437) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:321) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)"
Created attachment 237697 [details] Fix  BETA_JAVA8  An abstract method from an interface should show an "A" adornment like an abstract method from a class. AFAIK, we didn't add the "A" in the past, since the outline of an interface looks a bit "crowded" when every method has an "A".  However, the missing "A" is already problematic in other views like Search, Type Hierarchy, and in Quick Outline/Hierarchy, since the abstractness of a method cannot be seen without additional knowledge about the declaring type.  With static and default methods in interfaces, this got even worse, since those methods now identify themselves as having an implementation, but abstract methods still look like regular instance methods.  Does anybody disagree with this change or have a better solution?
"Missing code implementation in the compiler compile error when a lambda body accesses an array-typed variable:  package jsr335;  public class LambdaAccessArray {     public static void main(String[] args) throws InterruptedException {         final int[] result= { 0 };         Thread t = new Thread(() -> {             result[0]= 42;         });         t.start();         t.join();         System.out.println(result[0]);     } }  The error doesn't occur when the lambda body is just an expression like this:          Thread t = new Thread(() -> result[0]= 42);  The problem is reported here:   org.eclipse.jdt.internal.compiler.problem.ProblemReporter.needImplementation(ProblemReporter.java:6178) 	at org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateOuterAccess(CodeStream.java:2286) 	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.generateOuterAccess(StackMapFrameCodeStream.java:364) 	at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.generateCode(SingleNameReference.java:487) 	at org.eclipse.jdt.internal.compiler.ast.ArrayReference.generatePostIncrement(ArrayReference.java:166) 	at org.eclipse.jdt.internal.compiler.ast.PostfixExpression.generateCode(PostfixExpression.java:40) 	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:695) 	at org.eclipse.jdt.internal.compiler.ast.Block.generateCode(Block.java:75) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:751) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:702) 	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:923) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:573) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:369) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:781) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)"
"This happened while I was trying to create an example for bug 422515. The code has compile errors, but there shouldn't be an NPE.  !ENTRY org.eclipse.jdt.core 4 4 2013-11-25 20:47:34.680 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr335;  public class LambdaAccessArray {     public static void main(String[] args) throws InterruptedException {         final int[] result= { 0 };         Thread t = new Thread(() -> {             sysoresult[0]= 42;         });         t.start();         t.join();         System.out.println(result[0]);     } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ArrayReference.analyseAssignment(ArrayReference.java:57) 	at org.eclipse.jdt.internal.compiler.ast.Assignment.analyseCode(Assignment.java:80) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:309) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:506) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2172) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:446) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)"
By default this causes a warning and in my setup I get an error since I've increased the severity.
APT Tests uses @suppressWarnings("local") but does not set the compiler severity to 'Warning'. This can cause error or warnings in workspace that changed the setting for unused local variables.
By default this causes a warning and in my setup I get an error since I've increased the severity.
N20131127-2000.  Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131127-2000"; singleton:="true""  org.eclipse.test.EclipseTestRunner$TestFailedException: Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131127-2000"; singleton:="true"" at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:582) at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:521) at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
Convert to 'for' loop using Iterator should also work on a raw collection.
"Consider the code given below. Note the spurious potential NPE reported at (*).  import org.jmlspecs.annotation.NonNullByDefault; import org.jmlspecs.annotation.Nullable; import org.junit.Test;  @NonNullByDefault public class NullExprTest { 	 	private @Nullable Boolean b() { return null; } 	 	@Test 	public void testBoolean() { 		Boolean b1 = b(); 		boolean b = b1 == null ||  				b1; // <-- reports potential NPE (*) 		org.junit.Assert.assertTrue(b); 	}  }"
Follow-up to bug 422515. This time, I won't guess a reason...  package jsr335;  public class LambdaAccess2 {     private String fField; // must be here; can be used or unused      public void foo(Integer arg) {         new Thread(() -> {             // at "arg": Missing code implementation in the compiler             arg.intValue();         });     } }
"The missing import seems to be a big deal:  package jsr335; //import java.util.Random; public class LambdaAccess2 {     public void foo(Random arg) {         new Thread(() -> {             arg.intValue();         });     } }  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:103) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:317) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:543) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2172) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:446) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1011) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)"
In the normal compiler workflow, data/control flow analysis is not undertaken  if resolution phase has errors. For lambda expressions, we need information from  flow analysis right during resolution stage.   https://bugs.eclipse.org/bugs/show_bug.cgi?id=422801 and https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489  exposed problems in our analyzeCode infrastructure's ability to deal with handling bad data handed to them. I suspect the problem is pervasive and these bugs are just a few instances of the systemtic problem.  At the moment, I have disabled shape discovery if there are resolution errors either in the lambda or its enclosing scopes. This is perfectly OK and will not have any material effect - other than some spurious *secondary* errors that may show up during compilation: We may claim a certain method call is ambiguous while it is not, or that no applicable method is found when such is not the case.  This ER is to build a fall back mechanism using ASTVisitor to discover shape. While the general problem is not amenable to being solved using ASTVisitor, several common cases can be solved leaving only pathological cases unanalyzed.  This problem is only for lambdas with block bodies. We already to use heuristics to some extent: for example if we have seen a return statement without an expression (during resolve) then we can declare the lambda as being NOT value compatible - without control flow analysis.  Likewise, if we don't see any loops, any throws etc, we can draw some  conclusions that could suffice for the vast majority of the cases.  This is not a correctness issue, but could lead to better programmer experience.
BETA_JAVA8:  The following program triggers an ambiguous call error from javac 8b115. ATM, I have adjusted the behavior of eclipse to match. But this is most certainly wrong - I have asked for clarifications from the EG and once confirmed, we should fix accordingly.  // --  interface I {   String foo(String [] x, String y);  }  interface J {   void foo(int x, int y);  }  public class X {      static void goo(J j) {          System.out.println("goo(J)");      }      static void goo(I i) {          System.out.println("goo(I)");      }      public static void main(String[] args) throws InterruptedException {         goo((x, y) -> { return x[0] += 1; });      }  }
Ref to bug 421017, which introduces generics to jdt.core project via compliance level 1_6. Even though we had disabled the warnings in the pref file, the official build still enables them, as a result of which we get warnings in the build:  http://download.eclipse.org/eclipse/downloads/drops4/N20131128-2000/compilelogs/plugins/org.eclipse.jdt.core_3.10.0.N20131128-2000/@dot.html  We have to generify them where ever possible or suppress otherwise. For all APIs we will suppress the warnings and other cases need to be looked at case-by-case.
Created attachment 237840 [details] Example project to reproduce the StackOverflow  When I add the Aspose PDF library to my build path and I declare a class that extends one of the classes contained in the Aspose PDF JAR, I get a Stackoverflow error. The same problem occurrs when I create a type hierarchy.  I stripped the Aspose library down to one class and removed all methods and fields. The problem is caused by the type signature. I think class A is declared to implement itself, which is strange as one cannot implement classes, but interfaces only. However, the code obfuscator used by Aspose has somehow managed to create such a class file.  I know the class file is seriously damaged, but nonetheless Eclipse should not crash when dealing with such class files.  I'll attach an example project to repoduce the behavior.  The stack overflow contains these two methods:  org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:1384) org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.superInterfaces(ParameterizedTypeBinding.java:1008)
"I just got a test failure from running tests from command-line:  Failed tests:   testbBug386901(org.eclipse.jdt.core.tests.builder.BasicBuildTests): Incorrect value expected:<0> but was:<2000>  As far as I can tell, the assert that emits the failure is not working properly. The relevant section:  		int previous = org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.MAX_AT_ONCE; 		org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.MAX_AT_ONCE = 1; // units compiled in batches of '1' unit 		/* ... Snipped code executing tests that doesn't assign to previous */ 		org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.MAX_AT_ONCE = 0; // All units compiled at once 		/* ... Snipped code executing tests that doesn't assign to previous */ 		assertEquals(""Incorrect value"", 0, previous); 		 This is equivalent to: 		final int previous = org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.MAX_AT_ONCE; 		assertEquals(""Incorrect value"", 0, previous); 		/* ... Code that used to be between the two previous lines goes here */  This asserts that the default value of AbstractImageBuilder.MAX_AT_ONCE has been changed to be 0. This is attempted to be done in the initializer block during constructing the instance:  { System.setProperty(JavaModelManager.MAX_COMPILED_UNITS_AT_ONCE, ""0""); }  The failure itself is caused by the combination of 2 things:  - Thing 1: AbstractImageBuilder.MAX_AT_ONCE is a static field that is initialized only once during class loading. JavaBuilder.buildAll() creates a new BatchImageBuilder which extends AbstractImageBuilder, which would initialize the field in <clinit>. AbstractMethodTest.test001(), .test002() and .test003() were executed before BasicBuildTests.testTags3() and they build, so if test suites are created only when needed that would be enough to cause the initialization using the default value 2000. I don't have tests running inside Eclipse to verify what exactly ends up loading AbstractImageBuilder, unfortunately.  - Thing 2: A design issue where AbstractMethodTest.testbBug386901() method depends on the side effects of code that it doesn't itself cause to be executed.   The trace:  junit.framework.AssertionFailedError: Incorrect value expected:<0> but was:<2000> 	at junit.framework.Assert.fail(Assert.java:57) 	at junit.framework.Assert.failNotEquals(Assert.java:329) 	at junit.framework.Assert.assertEquals(Assert.java:78) 	at junit.framework.Assert.assertEquals(Assert.java:234) 	at junit.framework.TestCase.assertEquals(TestCase.java:401) 	at org.eclipse.jdt.core.tests.builder.BasicBuildTests.testbBug386901(BasicBuildTests.java:605) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at junit.framework.TestCase.runTest(TestCase.java:176) 	at junit.framework.TestCase.runBare(TestCase.java:141) 	at junit.framework.TestResult$1.protect(TestResult.java:122) 	at junit.framework.TestResult.runProtected(TestResult.java:142) 	at junit.framework.TestResult.run(TestResult.java:125) 	at junit.framework.TestCase.run(TestCase.java:129) 	at junit.framework.TestSuite.runTest(TestSuite.java:255) 	at junit.framework.TestSuite.run(TestSuite.java:250) 	at junit.framework.TestSuite.runTest(TestSuite.java:255) 	at junit.framework.TestSuite.run(TestSuite.java:250) 	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84) 	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53) 	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123) 	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164) 	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110) 	at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175) 	at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:123) 	at org.eclipse.tycho.surefire.osgibooter.OsgiSurefireBooter.run(OsgiSurefireBooter.java:86) 	at org.eclipse.tycho.surefire.osgibooter.HeadlessTestApplication.run(HeadlessTestApplication.java:21) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
"BETA_JAVA8:  There are a bunch of checks in SelectionEngine + CompletionEngine that look like the following:      if (scope.referenceContext instanceof AbstractMethodDeclaration) {         // ...     }  All these places need to upgrade to LambdaExpression as a potential reference context.  Example that breaks:  interface I { 	void foo(); } public class X { 	public static void main(String[] args) { 		 		I i = () -> { 			syso|    // no proposals here. 		}; 		 	} }"
Add to Organize Import dialog dialog the skip button which will preserve wrong import.  Now the Organize Import dialog ask for each type that it can't resolve automatically and I must select the type or cancel the WHOLE operation.   Sometime I prefer to resolve it manually after import organisation, realy.
The incremental build misses a dependency from a lambda expression to its functional interface: When the signature of the interface method is changed, the Lambda expression must be recompiled, even if there's no explicit reference in source code.  package test1; public interface I {     int method(int a); // change argument type to Object }  package test1; public class E {     void take(I i) {     } }  package test1; public class Ref {     void foo(E e) {         e.take((x) -> x+2); // not recompiled when I#method signature changed     } }
Created attachment 238107 [details] Test project  - Import the attached project in your workspace. - Find references of the constant field 'fi' of class Test2 via Ctrl+Shift+G. => Search view shows the references as potential matches instead of accurate matches.  (As a result, in inline refactoring:  - Press Alt+Shift+I on 'fi' declaration to inline all of its references and choose to delete the constant declaration. - Click OK : We get the message "Inaccurate matches have been found...". - Continuing deletes the declaration but the references are not inlined and we get compilation errors.)
Convert anonymous to lambda needs to consider ambiguous target types, see example in bug 403749 comment 22.  This is essentially the same problem as bug 408966 and should be solved with common infrastructure.
ecj reports a wrong compile error for a functional interface with an "@Override default" method that implements an abstract method from a superclass:  package jsr335.funint4;  @FunctionalInterface interface I {     int foo(String s); }  @FunctionalInterface interface A extends I { // wrong compile error (A *is* a functional interface)     @Override     default int foo(String s) {         return -1;     }     Integer foo(java.io.Serializable s); }  @FunctionalInterface interface B { // OK     default int foo(String s) {         return -1;     }     Integer foo(java.io.Serializable s); }
On the EG list Dan mentioned [1] this spec bug:    https://bugs.openjdk.java.net/browse/JDK-8028813  He mentions: "We're planning to come up with an extra incorporation rule that will handle cases like this."  This spec bug currently breaks our GenericsRegressionTest.testBug415734(), which I'm disabling for now, to be re-enabled once we have that new rule.  [1] http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000450.html
While work in bug 400874 is reaching the first milestone, the new spec section mentioned in the bug title has not yet been implemented, partly for lack of test cases for this situation.
While work in bug 400874 is reaching the first milestone, the new spec section mentioned in the bug title has not yet been implemented, partly for lack of test cases for this situation.
"CCE when hovering over the reference to 'goo'. Note that 'I' is not a functional interface, and the compiler correctly reports errors for that.  interface I { }  public class X {     static void goo(I i) {         System.out.println(""goo(I)"");     }          public static void main(String[] args) {         goo(s -> 0); // hover over 'goo' -> CCE     } }  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding 	at org.eclipse.jdt.internal.compiler.ast.Expression.checkCastTypesCompatibility(Expression.java:504) 	at org.eclipse.jdt.core.dom.TypeBinding.isCastCompatible(TypeBinding.java:1056) 	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.doEqualNumberOfParameters(UnresolvedElementsSubProcessor.java:1599) 	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addParameterMissmatchProposals(UnresolvedElementsSubProcessor.java:1336) 	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getMethodProposals(UnresolvedElementsSubProcessor.java:1109) 	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:337) 	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:300) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468) 	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:225) 	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186) 	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181) 	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150) 	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902) 	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243) 	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762)"
"NPE in LambdaExpression#getMethodBinding() for lambda with unresolved type. The example is the same as in bug 423582.  interface I { }  public class X {     static void goo(I i) {         System.out.println(""goo(I)"");     }          public static void main(String[] args) {         goo(s -> 0);     } }  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.getMethodBinding(LambdaExpression.java:912) 	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveMethod(DefaultBindingResolver.java:886) 	at org.eclipse.jdt.core.dom.LambdaExpression.resolveMethodBinding(LambdaExpression.java:319) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:149)"
To improve user experience when people try a new version of Eclipse with Java 8 Early Access JDKs, an unknown JDK version should be assumed capable of working with the latest known JDK version in terms of source code compatibility. This is especially important when existing projects using workspace default JRE are imported to a new workspace managed by an Eclipse installation running on Java 8 EA VM.   Currently projects that compiled without problems under a previous Eclipse-Java combination encounter build errors that are not solved by simply adding a Java 7 JRE to the installation. The 'trick' needed to solve the situation is not obvious: after adding the JRE, one needs to open Preferences->Java->Compiler page and click OK even if the page already claims that compliance level is set to 7.  The fix is simply to treat unknown JDK version strings as meaning compiler compliance 7.
Mea culpa !  org.eclipse.jdt.internal.compiler.parser.Parser.consumeNestedLambda()  has this line of code:   LambdaExpression lambda = new LambdaExpression(this.compilationUnit.compilationResult, this instanceof AssistParser);  that breaks ECJ runs with a ClassDefNotFound error.  Fix is simple - to introduce a level of indirection using a virtual call.  (A lambda needs to know if it was created by the assist parser so it can apply less strict rules for compatibility. Code is being written "just now", if we apply strict rules, we would often reject overloaded calls that would be resolved correctly once the completion which was the raison d'etre for the lambda is done.)  (There are also some interesting chicken and egg situations here. The programmer could be completing return statements, which influence the overload resolution which would influence the target type which would influence the return type completion ...)
"I previously reported this to the openjdk but it turns out it works correctly when compiled with javac: https://bugs.openjdk.java.net/browse/JDK-8029707  The problem exists only with Eclipse compiled classes: Eclipse Version: 4.3.1 Build id: M20130911-1000  Ubuntu 12.10 32bits Java(TM) SE Runtime Environment (build 1.8.0-ea-b118)  Given a package private class with a public method and a public subclass that inherits the public method, if we try to use the inherited public method using a lambda expression like: c.forEach(subclass::inheritedMethod);  we get an java.lang.IllegalAccessError  STEPS TO FOLLOW TO REPRODUCE THE PROBLEM : Considering the following scenario: A package 'mypackage' containing a package private class called MyPackagePrivateBaseClass: class MyPackagePrivateBaseClass {      public void doSomething(String input) {         System.out.println(input);     } } and a public subclass called MyPublicClass: public class MyPublicClass extends MyPackagePrivateBaseClass { }  If I try to access the inherited public method 'doSomething' from a class in a different package using a lambda expression I get a Exception in thread ""main"" java.lang.IllegalAccessError: tried to access class mypackage.MyPackagePrivateBaseClass from class Test 	at Test.doesNotWork(Test.java:37) 	at Test.main(Test.java:31)   public class Test {     public static void main(String[] args) {         doesWork();         doesNotWork();     }      public static void doesNotWork() {         MyPublicClass victim = new MyPublicClass();         List<String> items = Arrays.asList(""first"", ""second"", ""third"");         items.forEach(victim::doSomething); //illegal access error here     }      public static void doesWork() {         MyPublicClass victim = new MyPublicClass();         List<String> items = Arrays.asList(""first"", ""second"", ""third"");         for (String item : items) {             victim.doSomething(item);         }     } }"
Consider an example like this:    class A{/**/}   class B extends A {/**/}    class G<T> {     G<B> gb=null;     G<? super A> gsa=null;     G<? super B> l = (true)? gsa : gb;   }  The conditional expression is a poly expression (appears in an assignment context) and hence should apply this rule from 15.25.3: "The type of a poly reference conditional expression is the same as its target type."  ECJ, however still seems to use lub computation based on which the assignment is rejected.  Avoiding lub in situations like this is important because lub(capture1,capture2) doesn't produce good results, whereas the new rules are much more permissive.
"package com.test;  public class C1 { 	private int[] nums; 	private void foo() { 		nums 	} } ------------------------------------------  In the above example, hover over 'nums' in foo() and apply the quick fix ""Create 'for' loop"". It results in the following code:  		for (int i = 0; i < nums.length; i++) { 			int i = nums[i]; 			 		}  The local variable 'i' is duplicate and has compilation error."
"package test;  class C2 implements C2_Sup {     public static final FI fi = x -> x++;     public static final FL fl = x -> x++;      {         bar(x -> x++); // [1]         bar(fl);      }     void bar(FI fi) { } }  interface C2_Sup {	 	default void bar(FL fl) { } }  @FunctionalInterface interface FI { 	int foo(int x); }  @FunctionalInterface interface FL {     long foo(long x); } --------------------------------------------------------  The above example compiles without any error with ECJ, but shows error at [1] with b118."
http://download.eclipse.org/eclipse/downloads/drops4/I20131210-2000/testresults/html/org.eclipse.jdt.core.tests.model_linux.gtk.x86_6.0.html is missing the org.eclipse.jdt.core.tests.model tests.  http://download.eclipse.org/eclipse/downloads/drops4/I20131210-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html is complete.  The consolelog reveals the reason:  java-test:      [echo] Running org.eclipse.jdt.core.tests.model.AllJavaModelTests. Result file: /opt/users/hudsonbuild/workspace/ep4-unit-lin64/workarea/I20131210-2000/eclipse-testing/results/linux.gtk.x86_6.0/org.eclipse.jdt.core.tests.model.AllJavaModelTests.xml      [echo] timout property: 7200000      [echo] frameworkvmargs:  -Xms40m -Xmx512m -XX:MaxPermSize=256m [..]      [java] java.lang.OutOfMemoryError: Java heap space
"It is impossible to extend java.nio.file.Path because of a compiler error  The type MyPath must implement the inherited abstract method Path.register(WatchService, WatchEvent.Kind<?>[], WatchEvent.Modifier...)	  The method register(WatchService, WatchEvent.Kind<?>[], WatchEvent.Modifier...) of type MyPath must override or implement a supertype method  Name clash: The method register(WatchService, WatchEvent.Kind<?>[], WatchEvent.Modifier...) of type MyPath has the same erasure as register(WatchService, WatchEvent.Kind<?>[], WatchEvent.Modifier...) of type Path but does not override it  The following two methods are the culprit  WatchKey register(WatchService watcher, Kind<?>[] events, Modifier... modifiers) throws IOException WatchKey register(WatchService watcher, Kind<?>... events) throws IOException  ---Full Source---- public class MyPath implements Path {      /** {@inheritDoc} */     @Override     public FileSystem getFileSystem() {         return null;     }      /** {@inheritDoc} */     @Override     public boolean isAbsolute() {         return false;     }      /** {@inheritDoc} */     @Override     public Path getRoot() {         return null;     }      /** {@inheritDoc} */     @Override     public Path getFileName() {         return null;     }      /** {@inheritDoc} */     @Override     public Path getParent() {         return null;     }      /** {@inheritDoc} */     @Override     public int getNameCount() {         return 0;     }      /** {@inheritDoc} */     @Override     public Path getName(int index) {         return null;     }      /** {@inheritDoc} */     @Override     public Path subpath(int beginIndex, int endIndex) {         return null;     }      /** {@inheritDoc} */     @Override     public boolean startsWith(Path other) {         return false;     }      /** {@inheritDoc} */     @Override     public boolean startsWith(String other) {         return false;     }      /** {@inheritDoc} */     @Override     public boolean endsWith(Path other) {         return false;     }      /** {@inheritDoc} */     @Override     public boolean endsWith(String other) {         return false;     }      /** {@inheritDoc} */     @Override     public Path normalize() {         return null;     }      /** {@inheritDoc} */     @Override     public Path resolve(Path other) {         return null;     }      /** {@inheritDoc} */     @Override     public Path resolve(String other) {         return null;     }      /** {@inheritDoc} */     @Override     public Path resolveSibling(Path other) {         return null;     }      /** {@inheritDoc} */     @Override     public Path resolveSibling(String other) {         return null;     }      /** {@inheritDoc} */     @Override     public Path relativize(Path other) {         return null;     }      /** {@inheritDoc} */     @Override     public URI toUri() {         return null;     }      /** {@inheritDoc} */     @Override     public Path toAbsolutePath() {         return null;     }      /** {@inheritDoc} */     @Override     public Path toRealPath(LinkOption... options) throws IOException {         return null;     }      /** {@inheritDoc} */     @Override     public File toFile() {         return null;     }      /** {@inheritDoc} */     @Override     public WatchKey register(WatchService watcher, Kind<?>[] events, Modifier... modifiers) throws IOException {         return null;     }      /** {@inheritDoc} */     @Override     public WatchKey register(WatchService watcher, Kind<?>... events) throws IOException {         return null;     }      /** {@inheritDoc} */     @Override     public Iterator<Path> iterator() {         return null;     }      /** {@inheritDoc} */     @Override     public int compareTo(Path other) {         return 0;     }  }"
"I get the exception below while control-clicking to enter into:  8b115's java.nio.file.Path:   java.lang.IllegalArgumentException 	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2848) 	at org.eclipse.jdt.core.dom.ASTConverter.setTypeAnnotationsAndSourceRangeOnArray(ASTConverter.java:3417) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToArray(ASTConverter.java:3165) 	at org.eclipse.jdt.core.dom.ASTConverter.convertType(ASTConverter.java:3880) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:921) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:554) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2957) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Created attachment 238276 [details] Patch + Maven project  When using Eclipse compiler through JSR-199 interface (e.g. in IntelliJ IDEA), classes generated with Annotation Processing Tool are reported as missing during main classes compilation.  As example, I provide a small Maven project in attachment. Compiling it with Maven (using Eclipse compiler) works fine, but not with IntelliJ CE.  Having looked carefully at the code, it appears that batch compiler and JSR-199 do not report errors in the same way. I also provide a patch that fixes it. Feel free to incorporate it in ECJ sour code.  Thanks,   Best regards,  Gauthier
This CR will collect the follow up tasks found during code review and testing.  1. We should/could get rid of the new abstraction CommitRollbackParser by pushing down the APIs into Parser itself.  2. CompletionParser.becomeSimpileParser() and restoreAssistParser() needs to be studied to see what effect if any they may have on the new commit-rollback scheme.  3. Stacking of assist nodes can be handled better/cleaner ?  4. We could fast forward past the initial identifiers in an identifier collection leading up to completion point.   5. copyState() could avoid deep copy. Note: Parser state stack must be deep copied. As well as the place in CompletionParser attachOrphanNode(), as the latter mucks around with expression and ast stacks a bit too much.  6. One more round of review of CommitRollbackParser.  7. AssistParser.resumedAfterRepair: can be handled better. (?)  8. AssistParser.elementStack: do we need lambdas and body kind there - we don't use it as of now at all.
With bug 400874 about to be closed this bug will server as the umbrella for remaining & new issues relating to type inference in 1.8.
"Using the example from bug 419048:  import java.util.List; import java.util.Map; import java.util.stream.Collectors;   public class Bug419048 { 	void test1(List<Person> roster) {         Map<String, Person> map =                  roster                     .stream()                     .collect(                         Collectors.toMap(                             p -> p.getLast(), //[1]                             p -> p            //[2]                         )); 	} }   Now that type inference is able to find the correct types for the lambda parameters, I tried to hover or crtl-click on occurrences of p and specifically the message send ""getLast()"". Some of these currently fail with  java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:458) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1236) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:951) 	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:162) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)  Note, that hovering over the message receiver ""p"" in ""p.getLast()"" says: ""Object p - Bug419048.test1(List<Person>)"", i.e., the inferred type Person is not known to code select ...  Is code select working with information from before the type inference kicks in?"
"interface FI { 	public static int val = 5; 	default int run (String x) { return 1;}; 	public int run (int x); }  public class Test { 	FI fi = x -> (new FI() { public int run (int x) {return 2;}}).run("""")val; }  Please try to put a dot '.', before the last 'val' in the 2nd last line. See the workbench hanging."
"package com.test;  interface F1 { 	void foo(int x, String s, float f); }  public class C1 { 	F1 f1= () -> {}; // Ctrl+1 on '>' } --------------------------------------------------  In the above example, place caret on '->' and press Ctrl+1.  A warning with AIOOB is logged in the Error log.  Select the quick assist 'Convert to anonymous class creation' and press Enter. We get the AIOOB exception:  java.lang.ArrayIndexOutOfBoundsException: 0 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createParameters(StubUtility2.java:503) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:419) 	at org.eclipse.jdt.internal.corext.fix.LambdaExpressionsFix$CreateAnonymousClassCreationOperation.rewriteAST(LambdaExpressionsFix.java:293) 	at org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFix.createChange(CompilationUnitRewriteOperationsFix.java:101) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.createTextChange(FixCorrectionProposal.java:159) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244) ..."
"package com.test;  public class C2 { 	static F f = C2::m; // [1] Works 	int i = fun(C2::m); // [2] Does not work  	public static int m(int x) { 		return x; 	}  	private int fun(F f) { 		return f.foo(0); 	} }  interface F { 	int foo(int x); } --------------------------------------------------------- In the above example, press F3 or hover over 'm' at [1] and [2]. It works at [1] but not at [2]."
"CCE when trying to search for references to @Annot (a TYPE_USE annotation on an array dimension). Also happens for marker and single-member annotations.  package xy;  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented @interface Annot { }  public class Try { 	{ 		String tab @Annot() [] = null; 	} }   !ENTRY org.eclipse.core.jobs 4 2 2013-12-16 14:03:34.616 !MESSAGE An internal error occurred during: ""Java Search"". !STACK 0 java.lang.ClassCastException: org.eclipse.jdt.internal.core.Initializer cannot be cast to org.eclipse.jdt.core.IAnnotatable 	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.storeHandle(MemberDeclarationVisitor.java:145) 	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:253) 	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.traverse(SingleTypeReference.java:111) 	at org.eclipse.jdt.internal.compiler.ast.NormalAnnotation.traverse(NormalAnnotation.java:68) 	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.traverse(ArrayTypeReference.java:144) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:145) 	at org.eclipse.jdt.internal.compiler.ast.Initializer.traverse(Initializer.java:134) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2619) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2773) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2504) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1737) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1147) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1188) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1320) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"BETA_JAVA8  Bad source ranges for qualified TYPE_USE annotation in extends clause.   BTW: For this specific example, javac 1.8.0-ea-b115 has even worse bugs...  !ENTRY org.eclipse.jdt.core 4 4 2013-12-16 16:31:25.041 !MESSAGE Bad AST node structure: - parent [156, 168] org.eclipse.jdt.core.dom.SimpleType    annotations [156, 194] org.eclipse.jdt.core.dom.MarkerAnnotation - parent [156, 168] org.eclipse.jdt.core.dom.SimpleType    previous [156, 194] org.eclipse.jdt.core.dom.MarkerAnnotation    name [164, 168] org.eclipse.jdt.core.dom.SimpleName  ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr308.myex;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class NestedAnnotationTest extends         @jsr308.myex.NestedAnnotationTest.Anno Object { // bad AST //        @Anno Object { // OK      @Target(ElementType.TYPE_USE)     public @interface Anno {     } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException: Bad AST node structure 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419) 	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:273) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206) ..."
PolyTypeBindings must not render the full lambda body in error messages.  (In reply to Srikanth Sankaran from bug 423584 comment #4) > (2) PolyTypeBinding's are supposed to transient short lived objects that > should not "escape" the overload resolution context.  I'm not sure if they can be totally avoided if the code contains compile errors.  - Example where the lambda has too many arguments:  import java.util.List; public class Snippet {     void foo(List<Process> list) {         list.removeIf((x, y) -> {             System.out.println("very");             System.out.println("long");             System.out.println("lamda");             System.out.println("body");             return true;         }, "bee");     } }   - Error message:  The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((<no type> x, <no type> y) -> {   System.out.println("very");   System.out.println("long");   System.out.println("lamda");   System.out.println("body");   return true; }, String)   => Either PolyTypeBindings never show up in error messages, or their rendering must be reduced, like e.g. for anonymous type ...          list.removeIf(new Runnable() {             @Override             public void run() {                 System.out.println("hi");             }         });  ... the error message is:  The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments (new Runnable(){})   If the argument count is correct, then I don't see PolyTypeBindings any more, but the error message can show illegal types. E.g. for ...          list.removeIf((int x) -> "yep");  ... the error message is:  The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments (Predicate<int>)  => Predicate<int> gives me a good hint that there's something wrong with the 'int', although the type is not correct Java.   I think the best solution would be a custom notation for the type of the lambda that just lists the lambda's parameters, followed by '-> {}', e.g.:  For the first example: The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((? x, ? y) -> {}, String)  For 'list.removeIf((int x) -> "yep");' : The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((int x) -> {})
As discussed in bug 420525 comment 6 it's tricky to find the right location where type inference should be finalized, i.e., if during inference we work on lambda copies etc., at what point should this information be accepted into the original lambda?  The current solution works from two sides: in PGMB.computeCompatibleMethod() right after inference, and: ASTNode.resolvePolyExpressionArguments() between two possible attempts of finding a suitable method binding. This works acceptably well for simple examples but gets more and more difficult with deep nesting of poly expressions.  Looking at the spec this issue relates to the distinction of invocation applicability inference (18.5.1) vs. invocation type inference (18.5.2). The former can be performed many times for the same invocation, and after selecting the most specific method the latter is invoked *once*.  Thus the difficulty to find the location for finalizing resolution into poly expressions relates to the fact that we haven't yet hooked invocation type inference into the proper location.  Initial analysis suggests that - invocation applicability inference corresponds to   Scope.computeCompatibleMethod(MethodBinding,TypeBinding[],InvocationSite) - invocation type inference corresponds to   Scope.mostSpecificMethodBinding(..)  Both methods end up calling PGMG.computeCompatibleMethod(). Out of 8 clients calling the former, only 5 clients also call the latter.  For now I will draft a solution whereby these clients pass a parameter which control whether we should perform part 1 or part 2 of the inference or both.  A final solution should later check how much of methods like mostSpecificMethodBinding should actually be *replaced* with a 1.8-specific implementation.
This program:  import java.util.function.IntPredicate; class UnusedStaticImport {   boolean value = match(Character::isUpperCase, 'A');   public static boolean match(IntPredicate matcher, int codePoint) { return matcher.test(codePoint); } }  Organize imports adds an unused line, leading to a warning: import static java.lang.Character.isUpperCase;  This happens when organize imports is executed from save actions, clean up or organize imports menu item. Tested with Eclipse R4.3.1+BETA_JAVA8 binaries updated yesterday.
"What steps will reproduce the problem? 1. Open the attached file from comment 1 for editing. 2. Edit the file by removing local variables allDirectories, allNonClassFiles, toName, then uncommenting the two lines below those. 3. At this point various errors can happen depending on save actions and compile settings. For good measure, organize imports and save the file.  In addition to the trace below, I also see other errors caused by the NPE:  !ENTRY org.eclipse.jdt.core 4 4 2013-12-17 01:21:38.734 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package errors;  import java.io.IOException; import java.nio.file.Path; import java.util.ArrayList; import java.util.function.Function; import java.util.function.Predicate; import java.util.jar.JarEntry; import java.util.jar.JarFile; import java.util.stream.Collectors; import java.util.stream.Stream;   public class NPEOnCollector {   static void processJar(Path plugin) throws IOException {          try(JarFile jar = new JarFile(plugin.toFile())) {       try(Stream<JarEntry> entries = jar.stream()) {         Stream<JarEntry> stream = entries           .distinct().collect(Collectors.toCollection(ArrayList::new));                }     }   } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:121)  and:  !ENTRY org.eclipse.jdt.ui 4 0 2013-12-17 01:21:38.743 !MESSAGE Error in JDT Core during reconcile !STACK 1 Java Model Exception: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:248) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) !SUBENTRY 1 org.eclipse.jdt.core 4 1005 2013-12-17 01:21:38.743 !MESSAGE java.lang.NullPointerException !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:121)  and:  !ENTRY org.eclipse.jdt.ui 4 10001 2013-12-17 01:21:41.392 !MESSAGE Internal Error !STACK 0 java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:477) Root exception: java.lang.IllegalArgumentException: AST must not be null 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.create(ImportRewrite.java:191) 	at org.eclipse.jdt.ui.CodeStyleConfiguration.createImportRewrite(CodeStyleConfiguration.java:70) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility.createImportRewrite(StubUtility.java:1509) 	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.createTextEdit(OrganizeImportsOperation.java:427) 	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.run(OrganizeImportsOperation.java:398) 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5360) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:1818) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:1815) 	at org.eclipse.ui.internal.progress.ProgressManager$RunnableWithStatus.run(ProgressManager.java:1346) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.progress.ProgressManager$5.run(ProgressManager.java:1184) 	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:180) 	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:150) 	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4688) 	at org.eclipse.ui.internal.progress.ProgressManager.runInUI(ProgressManager.java:1182) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:291) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:204) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)   Tested with BETA_JAVA8 binary plugins updated few hours ago.  -- Error Details -- Date: Tue Dec 17 01:21:41 EET 2013 Message: Error in JDT Core during AST creation Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jdt.ui Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:121) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.capture(ParameterizedTypeBinding.java:140) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:812) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:636) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:136) 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:1089) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:136) 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:1089) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:273) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:204) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.GeneratedMethodAccessor28.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
"What steps will reproduce the problem? 1. Open the test class from attachment in comment 1 and hover mouse over variables indicated with ""NOT OK"". 2. Error log view shows new entries per each hover. 3. The file contains several variations of code with and without compile errors that may be related.  Tested with very recent BETA-JAVA8 binary plugins.  -- Error Details -- Date: Tue Dec 17 03:11:32 EET 2013 Message: Unexpected runtime error while computing a text hover Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jface.text Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  This is a continuation of log file C:\Users\Timo\workspace\.metadata\.bak_0.log Created Time: 2013-12-17 01:20:52.886  Exception Stack Trace: java.lang.IllegalArgumentException: capture#1-of ? extends java.lang.String 	at org.eclipse.jdt.core.Signature.createCharArrayTypeSignature(Signature.java:1076) 	at org.eclipse.jdt.core.Signature.createTypeSignature(Signature.java:1235) 	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:458) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1236) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:951) 	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:162) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:118) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:608) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:604) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
"This example produces compilation errors while it shouldn't:  interface I { 	void bar(String t); } class X<T> implements I { 	public void bar(String t) {} 	X(String x) {} 	X(T x) {} 	public void one(X<I> c){} 	public void two() { 		one(new X<>((String s) -> { })); // 1. Three errors 		X<I> i = new X<>((String s) -> { }); // 2. Error - Comment out the previous line to see this error go away. 		one (i); 	} }  Interestingly, when the first statement is commented out, the second one compiles alright."
"package test;  interface FIOther { 	FIOther run(int x); }  public class TestOther { 	FIOther fi = x -> { 		return new FIOther() { 			public FIOther run(int x) { // [1] 				return null; 			} 		}; 	}; } --------------------------------------------------------------  Apply clean-up or quick assist to convert the anonymous class to lambda. It results in the following code with compilation error:  package test;  interface FIOther { 	FIOther run(int x); }  public class TestOther { 	FIOther fi = x -> { 		return x -> null; // Error 	}; }  // Error : Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope.   See also bug 422766."
"package test.one;  class C1 { 	public void fun1() { 		FI fi = I::staticMethod; // [1] 	} }  @FunctionalInterface interface FI { 	void foo();	 }  interface I { 	static FI staticMethod() { 		return null; 	} } -----------------------------------------------------  The above example compiles with b118 but shows error at [1] with ECJ.  The error is: The type I does not define staticMethod() that is applicable here"
"package test.one;  @FunctionalInterface public interface FI { 	void foo(); }  class X { 	static FI staticMethod() { 		return null; 	} } ------------------------------------------------  package test.two;  import test.one.FI;  class C1 { 	public void fun1() { 		FI fi = X::staticMethod; // [1] X cannot be resolved 	} } ------------------------------------------------  Place the above files in 2 separate packages as given. Press Ctrl+Shift+O in class C1 to organize imports. The import for class X in not added."
"Created attachment 238407 [details] Fix  Example:      void foo(java.util.Set<Integer> set) {         set.removeIf((a, b) -> { });     }  See bug 424154 about the first error message.  The second error is:  	set.removeIf((a, b) -> { }); 	             ^^^^^^^^^ Lambda expression's signature does not match the signature of the functional interface method   This message doesn't contain enough information to quickly fix the problem. It would be good to include the actual functional interface method, so that a user (or a quick fix) immediately knows what's expected. Improved message:  Lambda expression's signature does not match the signature of the functional interface method test(Integer)"
Convert lambda to anonymous has problems with wildcards:  package xy; import java.util.*; public class E {     void foo(Integer[] ints){         Arrays.sort(ints, (i1, i2) -> i1 - i2);         Comparator<?> cw = (w1, w2) -> 0;         Comparator cr = (r1, r2) -> 0;         Comparator<? extends Number> ce = (n1, n2) -> -0;     }; }
"As the project that the builder is having problems with is licensed under GPLv2 I haven't looked into what code could be causing the exception. Hopefully the stack trace and steps below are enough to uncover what the problem is.  What steps will reproduce the problem? 1. Download a zip containing the project source code from http://code.google.com/p/jsr308-langtools/source/browse/ 2. Unzip the file and rename the project folder to 'jsr308-langtools'. 3. Move the folder in the workspace folder. 4. Import it as an existing project. 5. Building fails with an error message dialog and the error below appears in Error log.   -- Error Details -- Date: Wed Dec 18 01:44:15 EET 2013 Message: Errors running builder 'Java Builder' on project 'jsr308-langtools'. Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:683) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:124) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:703) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:661) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1559) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2663) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:849) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:681) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1145) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)"
The new version 0.8.0 of the JSR 335 spec has been published, which contains some significant changes affecting type inference. These need to be incorporated, or verified for those changes that go back to our own reports.
When applying attachment 238421 [details] from bug 424167 comment 5, OverloadResolutionTest8.test004() starts failing.  I believe this is caused by the way how lambda shape analysis surrenders when enclosingScopesHaveErrors().  The test contains three almost identical method calls with a lambda as their argument. In all three cases inference wants to detect an incompatibility because the function type returns an int but the lambdas are not value-compatible. However, only the first occurrence succeeds to report this, because subsequent occurrences will detect the first error in some outer scope and refuse to complete its analysis. IMHO these statements should be fully independent.  I know that this area is close to impossible to get right and fully spec-compliant, but the result in this test looks wrong.
"(In reply to Markus Keller from bug 424083 comment #1) > It's strange that you can get a quick assist there. This should be blocked in > QuickAssistProcessor#getAssists(..) line: 248  -------------------------------------------------- package com.test;  interface F1 { 	void foo(int x, String s, float f); }  public class C1 { 	F1 f1= () -> {}; // Ctrl+1 on '>' } --------------------------------------------------  On pressing Ctrl+1 at '>', we get the following quick assists: - Convert to anonymous class creation - Extract to constant  which should not appear according to the code at QuickAssistProcessor#getAssists(..) line: 248, since the location has error.  If the selection length is > 0, the quick assists are not available. They should also be blocked when the selection length = 0."
"At the moment, I am not sure if this is a bug in ECJ, but here's the test case:  public class X<T> implements MyComparable<T>{      public static void main(String argv[]) {     	int result = ((Comparable<Integer> & MyComparable) new X()).compareTo(1);     }     public int compareTo(T o) { 		return 0; 	} } interface MyComparable<T> extends Comparable<T> {}  We allow this code while Javac doesn't. I can't find anywhere in the spec about intersection of types in same hierarchy one with type argument and other without.  We reject code like this:  int result = ((Comparable<String> & MyComparable<Integer>) new X()).compareTo("""");"
"This is the code causing the NPE:  interface Functional { int foo(); }  class X {     static int bar() {         return -1;     }     static <T> T consume(T t) { return null; }      public static void main(String[] args) {     	Functional f = consume(X::bar);     }   }  Not sure if the NPE is causing it, but we also report a compilation error.  And here's the stack trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.recordQualifiedReference(CompilationUnitScope.java:636) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getSingleAbstractMethod(ReferenceBinding.java:1861) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isPertinentToApplicability(ReferenceExpression.java:554) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.createInitialConstraintsForParameters(InferenceContext18.java:139) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.inferInvocationApplicability(ConstraintExpressionFormula.java:271) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationApplicability(InferenceContext18.java:217) 	at ..."
"// -- Triggers NPE:  import java.util.ArrayList; import java.util.Collection;  interface Functional<T> {    T apply(); }  class X {     void foo(Object o) { }  	<Q extends Collection<?>> Q goo(Functional<Q> s) { 		return null; 	}       void test() {         foo(goo(ArrayList<String>::new));     } }"
"This program, when run, produces a VerifyError:  interface Functional<T> {     T foo(int size); } public class X  {     public static void main(String argv[]) {     	Functional<int[]> constr = int[]::new;      }  }   Exception in thread ""main"" java.lang.VerifyError: Bad return type Exception Details:   Location:     javasoft/sqe/tests/lang/lmbd044/lmbd04401m0/X.lambda$0(I)[I @4: areturn   Reason:     Type '[LI;' (current frame, stack[0]) is not assignable to '[I' (from method signature)   Current Frame:     bci: @4     flags: { }     locals: { integer }     stack: { '[LI;' }   Bytecode:     0000000: 1abd 001c b0"
When debugging examples involving nested structures that require type inference we can see that inference and resolving for the same elements is triggered ridiculously many times.  Consider a lambda as an argument to a method with many candidate overloads: for each method the lambda is asked isCompatible against the corresponding method parameter. Consider further a body inside that lambda that requires type inference.  Each time isCompatible is invoked we create a copy of the lambda, invoke resolveType which may invoke inner inference and all results we compute inside will immediately be discarded.  Caching such results not only improves performance but should also make debugging easier :)
"package packUp;  interface FX { 	default int defaultMethod(String x) { 		return -1; 	}  	int foo(int x); }  class TestX { 	FX fxx = x -> { 		return (new FX() { 			@Override 			public int foo(int x) { 				return 0; 			} 		}).defaultMethod(""a""); 	}; } --------------------------------------------------------------  Invoke Ctrl+1 at '>' and press Enter to select the quick assist 'Convert to anonymous class creation'.  The resulting anonymous class overrides the default method as it is and we get compilation error."
Using this class, try to inline the method combine. It fails with error message "return statement in method declaration interrupts execution flow".   Tested with BETA_JAVA8 binaries updated yesterday.  import java.util.function.Function; import java.util.function.Supplier; import java.util.stream.Stream;  class Streamer {   public static <T, R> Supplier<Stream<R>> map(Supplier<Stream<T>> supplierOfT, Function<T, R> mapperOfTToR) {     Supplier<Stream<R>> changed = combine(supplierOfT, mapperOfTToR); // Inline method combine here     return changed;   }   private static <T, R> Supplier<Stream<R>> combine(Supplier<Stream<T>> supplierOfT, Function<T, R> mapperOfTToR) {     Supplier<Stream<R>> supplierOfR = () -> { return supplierOfT.get().map(mapperOfTToR); };     return supplierOfR;   } }
"Using Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20131222-0103_BETA_JAVA8  Steps to reproduce:  1 Create empty default 1.8 Java project with wizard 2 Copy/paste content of http://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java to the ""src"" folder 3 The file can't be compiled due NPE's in TypeSystem.getUnannotatedType, see log below.  Error Sun Dec 22 20:29:46 CET 2013 Errors running builder 'Java Builder' on project 'Java8Examples'.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76) 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:146) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:938) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.substituteInferenceVariable(ParameterizedTypeBinding.java:827) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintFormula.applySubstitution(ConstraintFormula.java:70) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:291) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:95) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:703) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:661) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1559) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2365) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:650) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)"
Created attachment 238533 [details] Screenshot of spurious errors  With 4.3.1 + JAVA8_Beta (1.0.0.v20131221-0104_BETA_JAVA8), there are a number of spurious local variable resolution errors in the Graal project source code. Unfortunately I cannot reproduce a small test case. However, checking out the code and reproducing the problem is fairly straightforward:  hg clone http://hg.openjdk.java.net/graal/graal/rev/72e2ec923b7b cd graal unzip eclipse-config.zip # attached to this bug report  Start Eclipse (running on top of JDK8) with new workspace directory being graal. Configure a JavaSE-1.8 Execution Environment. File | Import... | General | Existing Projects into Workspace Choose graal/graal subdirectory and import all discovered projects.  Once "Building workspace" completes, you should see about 33 errors in the Problems View, most of which are obviously spurious variable resolution errors. See attached screenshot.
When selecting the IOException in the getterMaker1 throws declaration, the get() method inside the returned lambda block is highlighted as well.  import java.io.IOException; public class ExtraInsideLambda {   interface Getter<T> { T get() throws IOException; }      /* Place caret in IOException in throws declaration below, the method call inside lambda is    * highlighted too. The other versions work as expected. */   public static Getter<Long> getterMaker1(Getter<Long> getter) throws IOException {     Long value = getter.get();     return () -> value == null ? getter.get() : value;   } }  Other similar versions work as expected:    /* As expected, no throws declarations is needed. */   public static Getter<Long> getterMaker2(Getter<Long> getter) { return () -> getter.get(); }    /* As expected, both throws declarations highlight only one get-method when selected. */   public static Getter<Long> getterMaker3(Getter<Long> getter) throws IOException {     Long value = getter.get();     return new Getter<Long>() {       @Override public Long get() throws IOException { return value == null ? getter.get() : value; }     };   }
"Tested with BETA_JAVA8 binaries updated today.  What steps will reproduce the problem? 1. Add this class:  public class AddThrows {   interface Getter2<T, E extends Exception> { T get() throws E; }      public static Long main2(Getter2<Long, ?> getter) {     Long value = getter == null ? 0l : 1l;     /* uncomment next line, then press CTRL-1 and      * select either ""add throws.."" or ""surround.."" quick fix. */     //value = getter.get();     return value;   } }  2. Uncomment the value = getter.get(); line. 3. Hover mouse over the uncommented line and select ""Add throws declaration"" quick fix. 4. The NPE is logged.  Selecting ""Surround with try/catch"" also causes the same exception. Pressing CTRL-1 instead of hovering also causes the NPE, this time logged as a warning from jface.text.   -- Error Details -- Date: Mon Dec 23 16:26:41 EET 2013 Message: Unhandled event loop exception Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.ui Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.dom.ASTNodeFactory.newType(ASTNodeFactory.java:142) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.modifyExceptions(ChangeMethodSignatureProposal.java:384) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.getRewrite(ChangeMethodSignatureProposal.java:138) 	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244) 	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:372) 	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.performChange(ChangeCorrectionProposal.java:136) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.LinkedCorrectionProposal.performChange(LinkedCorrectionProposal.java:150) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.apply(CUCorrectionProposal.java:184) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.apply(AbstractAnnotationHover.java:538) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.access$2(AbstractAnnotationHover.java:515) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl$5.widgetSelected(AbstractAnnotationHover.java:509) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081) 	at org.eclipse.swt.widgets.Widget.sendSelectionEvent(Widget.java:1098) 	at org.eclipse.swt.widgets.Link.wmNotifyChild(Link.java:1084) 	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5617) 	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1935) 	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5169) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4667) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4990) 	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method) 	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443) 	at org.eclipse.swt.widgets.Link.callWindowProc(Link.java:172) 	at org.eclipse.swt.widgets.Widget.wmLButtonUp(Widget.java:2075) 	at org.eclipse.swt.widgets.Control.WM_LBUTTONUP(Control.java:4995) 	at org.eclipse.swt.widgets.Link.WM_LBUTTONUP(Link.java:922) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4648) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
A static class an a static fina object of this class are declared with @NonNull. In another class the static object are used in as methode-argument that are annotated @NonNull. The compiler shows the warning "Null type safety (type annotations): The expression of type '@NonNull Test3.Test3aa' needs unchecked conversion to conform to '@NonNull Object'" by the use of Methode "test1" in class "Test4" (see Attachment)  The warning says "Test3.Test3aa" but the Objectname are "Test3.Test3a".  I uses Java 8 Beta and eclipse-SDK-4.3.1-linux-gtk-x86_64-efx-0.9.0-SNAPSHOT.tar.gz
I'm running: JDK 1.8.0 b120 64-bit Eclipse 4.3.1 Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20131223-0103_BETA_JAVA8  public class MainTest {     public static interface Consumer<T> {         void accept(T t);     }          public static class Base {         public void method () {}     }     public static class Foo extends Base {}     public static class Bar extends Base {}      public static void main (String[] args) {         Consumer<Foo> foo = Foo::method;         Consumer<Bar> bar = Bar::method;     } }  The above class compiles fine with Eclipse, but when I go to run it I get the following error:  Exception in thread "main" java.lang.BootstrapMethodError: call site initialization exception     at java.lang.invoke.CallSite.makeSite(CallSite.java:328)     at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:296)     at MainTest.main(MainTest.java:19) Caused by: java.lang.invoke.LambdaConversionException: Invalid receiver type class MainTest$Foo; not a subtype of implementation type class MainTest$Bar     at java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:221)     at java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:303)     at java.lang.invoke.CallSite.makeSite(CallSite.java:289)     ... 2 more  To get the class to run without an error via Eclipse, I can either implement method() in one of the subclasses or change both method references in main to Base::method. However, neither of these changes is needed to compile and run using JDK8.
"This example still causes an NPE in ReferenceExpression.generateCode(line 172) (modified version of example from bug 424415) :  package bug424415;  import java.util.ArrayList; import java.util.Collection;  interface Functional<T> {    T apply(); }  class X {     void foo(Collection<String> o) { }  	<Q extends Collection<?>> Q goo(Functional<Q> s) { 		return null; 	}       void test() {          foo(goo(ArrayList<String>::new));     } }"
"This may be a duplicate but the problematic source code is so neat I'm reporting it without checking too carefully :)  What steps will reproduce the problem? 1. Copy the source code from the error message below and paste it to a project and save. 2. AIOOB is logged many many times from many many places.  Tested with BETA_JAVA8 binaries updated earlier today.  -- Error Details -- Date: Tue Dec 24 21:15:24 EET 2013 Message: Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package vararg.methodref;  import java.nio.file.Files; import java.nio.file.Path; import java.util.function.Function; import java.util.stream.Stream;   public class AstAndReconcileErrors {   public static void method() {     Function<Path, Stream<Path>> method = Files::walk;   } }  ----------------------------------- SOURCE END ------------------------------------- Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.ArrayIndexOutOfBoundsException: 1 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:468) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:965) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:204) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:270) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
"Using Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20131228-0104_BETA_JAVA8  Steps to reproduce:  1 Create empty default 1.8 Java project with wizard 2 Copy/paste this code (accepted by 1.8 javac) to the src folder:  ============== import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.function.Function; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.stream.Stream;  public class MapperTest {      public static void main( String... argv ){         List<String> data = Arrays.asList(""abc"", ""123"", ""1a"", ""?!?"");         List<Pattern> patterns = Arrays.asList(Pattern.compile(""[a-z]+""), Pattern.compile(""[0-9]+"")); 		patterns.stream() 				.flatMap( 						p -> { 							Stream<Matcher> map = data.stream().map(p::matcher); 							Stream<Matcher> filter = map.filter(Matcher::find); 							Function<? super Matcher, ? extends Object> mapper = Matcher::group; 							mapper = matcher -> matcher.group(); 							return filter.map(mapper); 						}) 				.forEach(System.out::println);     } } ==============  Exception below will be reported during build:  Error Sat Dec 28 10:31:29 CET 2013 Errors running builder 'Java Builder' on project 'Java8Examples'.  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding 	at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.localVariableBinding(SingleNameReference.java:849) 	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:199) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:123) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:367) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1046) 	at org.eclipse.jdt.internal.compiler.ast.FunctionalExpression.checkAgainstFinalTargetType(FunctionalExpression.java:140) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:693) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:854) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:683) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:591) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)  Removing line 20 (mapper = matcher -> matcher.group();) fixes the problem, also changing the lines 19-20 to  Function<? super Matcher, ? extends Object> mapper = matcher -> matcher.group(); fixes the problem too.  The assignment to the local variable doesn't work here..."
"Using Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20131228-0104_BETA_JAVA8  Steps to reproduce: Open java.util.stream.SortedOps from 1.8 JDK in Java Editor (via ""Open Type"").  Error appear in the error log view:  eclipse.buildId=4.3.0.M20130911-1000 java.version=1.7.0_45 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.standard.product -showLocation Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.standard.product -showLocation  Error Sat Dec 28 11:20:14 CET 2013 Error in JDT Core during AST creation  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isProvablyDistinctTypeArgument(TypeBinding.java:934) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isProvablyDistinct(TypeBinding.java:782) 	at org.eclipse.jdt.internal.compiler.ast.CastExpression.checkUnsafeCast(CastExpression.java:333) 	at org.eclipse.jdt.internal.compiler.ast.Expression.checkCastTypesCompatibility(Expression.java:415) 	at org.eclipse.jdt.internal.compiler.ast.CastExpression.resolveType(CastExpression.java:546) 	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:203) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:572) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1310) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1108) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$1.run(ClassFileEditor.java:710) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"There where some API changes for JDK 8, e.g. additional intermal parameters for the language changes.  As an example for type annotations in  org.eclipse.jdt.internal.compiler.ast.TypeReference  changed the signature of the method:   public static final TypeReference baseTypeReference(int baseType, int dim)  to   public static final TypeReference baseTypeReference(int baseType, int dim, Annotation [][] dimAnnotations)   This breaks for instance the popular compiler extension lombok:   http://code.google.com/p/projectlombok/issues/detail?id=597   I suggest to add compatibility functions for this like e.g.: public static final TypeReference baseTypeReference(int baseType, int dim) { 	// compatibility function 	return  baseTypeReference(baseType, dim, null); }  This here is just an example. These kind of compatibility functions are very simple and help to prevent the breaking of potentially many external plugins and rise the acceptance for the new eclipse version.   I know this is an internal package, but you should be well aware that many external plugins around compilers and and languages (quite a popular topic nowadays) directly use your nice compiler APIs, especially the AST.  I kindly request to add at least this function because lombok is very important and works fine with this additional method ;)"
"Getting this problem on a large Java 8 project with the 20 december Java8 release:  java.lang.ArrayIndexOutOfBoundsException: 1 	at org.eclipse.jdt.internal.compiler.ast.Statement.analyseArguments(Statement.java:120) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:168) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:52) 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.analyseCode(TryStatement.java:169) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:52) 	at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode(IfStatement.java:105) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:128) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:740) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:119) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:776) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Unknown Source)  I'm unsure where it occurs exactly as the stack trace leaves much to be desired to figure out where this problem occurs."
"Using the Java 8 preview installed I got the following stacktrace when compiling:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.nullAnnotationUnsupportedLocation(ProblemReporter.java:5708) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkIllegalNullAnnotation(AllocationExpression.java:505) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:327) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:591) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:136) 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:1089) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:965) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:204) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:270) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)  This was apparently caused by a wrong location of a @Nonnull annotation, used in the source code as:  @Nonnull public class DbUpdater {  Removing the @Nonnull fixed the problem.  The version of the Java 8 binaries is 1.0.0v20131229-0103_BETA_JAVA8"
Using the JAVA8 preview to compile a large code base. Preview version is 1.0.0v20131229-0103_BETA_JAVA8.  The compiler reports errors like: "The nullness annotation 'Nullable' is not applicable at this location" for parameter definitions that have a type specified as a qualified path (not a SimpleName). For instance, the error is reported on:  public QualificationLookupInput(@Nullable Qualification qualificationProperty, @Nullable java.util.Date checkDate) { (second parameter). Removing the java.util resolves the problem.  Other examples: public void renderNodeContent(@Nonnull NodeBase component, @Nonnull NodeContainer node, final @Nullable OldHelpManager.Entry object, @Nullable Object parameters) throws Exception { (third parameter, with Entry being an inner class)  @Nonnull public java.security.cert.Certificate[] getCertificateChain() { (return value)
"package two.test;  class TestInlineLambdaArray { 	TestInlineLambdaArray h = new TestInlineLambdaArray(x -> x++);	// [9] 	public TestInlineLambda(FI fi) {} }  interface FI { 		void foo(); } -------------------------------------------------  Place the above example in a java file and save. We get the following exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:628) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isCompatibleWith(TypeBinding.java:556) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1050) 	at org.eclipse.jdt.internal.compiler.ast.FunctionalExpression.checkAgainstFinalTargetType(FunctionalExpression.java:140) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:693) 	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:339) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:458) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1145) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:965) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:204) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:270) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) ..."
"@FunctionalInterface interface FI { 	int foo(int x); }  class Test { 	public static final FI f= Test::m; 	 	static int m(int x) { 		return x++; 	} }  enum E1 { 	E_C1(Test.f); // [1] - Inline 'f' here 	E1(FI fi) { 	} } -------------------------------------"
Created attachment 238617 [details] Zipped demo project  Starting with Luna M4 I get a very annoying effect in some (not all) Java files. The indentation of some (not all) braces alternates between two different positions whenever I save those files. One position is correct and the other one not. The incorrect one can be fixed with Shift+Ctrl+F but that makes the editor dirty and the next save brings it back to the incorrect brace positions. The alternating behaviour can also be reproduced by adding a space after any line in the file and saving it.  I attach a zipped project with a single Java file in it which seems to reproduce it in a fresh workspace. The file is full of compile errors because I stripped down the project but that doesn't impact the problem I describe above.  Maybe bug 251824 has caused this regression?
When using Java 8 compliance settings, the following code results in the compiler error "The method sort(List<T>, Comparator<? super T>) in the type Collections is not applicable for the arguments (List<Object>, Ordering<Object>)". Java 7 compliance settings work (Ordering and Function classes are from Google Guava):  List<Object> list = new ArrayList<>(); Function<Object, String> function = new Function<Object, String>() {   public String apply(Object arg0) {   return arg0.toString();   } }; Ordering<Comparable> natural = Ordering.natural(); Collections.sort(list, natural.onResultOf(function));  As a Workaround, extract the expression "natural.onResultOf(function)" to a variable:  Ordering<Object> onResultOf = natural.onResultOf(function); Collections.sort(list, onResultOf);  Version of used JDT patches: 1.0.0.v20140103-0106_BETA_JAVA8
Respect the line delimiter preference when creating a new CU by pasting to the Package Explorer.  Currently, we use the line delimiter from the clipboard, which may not be the same as the project preference.
"package com.p1;  interface A { 	String foo();  	default void fun1() { 		System.out.println((A) super::toString); 	} } ----------------------------------------------  The above example compiles with ECJ but shows error with b120.  (JSR 335, 15.28 : If a method reference has the form super :: NonWildTypeArgumentsopt Identifier, let T be the type declaration immediately enclosing the method reference. It is a compile-time error if T is the class Object or T is an interface.)"
and associated changes as per bug 418979
// -- import java.util.ArrayDeque; import java.util.Deque; import java.util.function.Supplier;  public class X<S, T extends Deque<S>> {     private final Supplier<T> supplier;      public X(Supplier<T> supplier) {         this.supplier = supplier;     }          public static <S> X<S, Deque<S>> newDefaultMap(int dequeCapacity) {         return new X<>(() -> new ArrayDeque<>(dequeCapacity));     } }  triggers an error: "Cannot infer type arguments for X<>"  This code used to work earlier I believe.
"package test; import java.lang.annotation.*; public class X {     test.@A Outer<>.@A Inner<> i;  } class Outer<T> { 	class Inner<S> {} } @Target (ElementType.TYPE_USE) @interface A{}    compilation of the above produces   java.lang.ArrayIndexOutOfBoundsException: -2 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:262) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:946) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:944) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveAnnotations(TypeReference.java:584) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.internalResolveType(ParameterizedQualifiedTypeReference.java:176) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.resolveType(ParameterizedQualifiedTypeReference.java:427) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1695) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:869) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:839) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
"Starting with spec version 0.8.0 we'll record the fact when a type compatibility constraint involves unchecked conversion. The inference side of this will be released soon via Bug 424286.  At that point InferenceContext18 will provide:    	public boolean usesUncheckedConversion()  This information is to be used in determining the method invocation type (Part F, 15.12.2.6)."
"package one.test;  interface I<M> { 	M run(M x); }  class Test { 	I<?> li2 = s -> null; } ----------------------------------------  Convert lambda to anonymous class using the quick assist.   We get the following code with compilation error:  I<?> li2 = new I<Object>(){@Override public ? run(Object s){return null;}};  See also: bug 424273."
The formatter should have an option "Insert new line after type annotation", which should be disabled by default.  E.g. for the following source, the formatter should only insert a new line after "@Deprecated", but not after any occurrence of @Annot (even if all other "Insert new line after annotations on ..." options are enabled):  package xy;  import java.lang.annotation.*; import java.util.List;  public class Try extends@Annot Object {     @Deprecated public @Annot int b;     public@Annot()int foo(@Annot  List<@Annot()Object> a) {         return 0;     } }  @Documented @Target(ElementType.TYPE_USE) @interface Annot { }   Bug 401848 / bug 403816 have already discussed the problem that type annotations cannot be distinguished from declaration annotations in all cases, e.g.:      @Deprecated @Annot boolean hardToDecide() {         return true;     }  I don't think the formatter should resolve types, so the next best solution is to rely on a heuristic:      In ambiguous cases, consider annotations as type annotations     iff they appear after the last keyword in a modifier list.  This heuristic fails for the hardToDecide() example, but that's acceptable (and still way better than the current state, where the formatter produces bad results in many more cases).
(In reply to Srikanth Sankaran from bug 422489 comment #3) > Note to UI team: Compiler will not emit IProblem.TypeMismatch any more > for issues with return statement types. Instead expect > IProblem.ReturnTypeMismatch. > Not sure if this will break your test suites and/or quick fix support.  This created 4 valid test failures in TypeMismatchQuickFixTests.
For many IDE functionalities, we need an IJavaElement for a lambda expression:  - CodeSelect should resolve the lambda element when the caret is on the '->'. Currently, there's no easy way to see the contract of the functional interface method that the lambda implements. We should show a Javadoc hover for lambdas.  - (Quick) Type Hierarchy should include all implementations of a functional interface (bug 423123); ITypeHierarchyChangedListener should notify of changes.  - Reference search matches should show up in a 'lambda' element, not in the element that contains the lambda expression.  - The parent of a lambda parameter (ILocalVariable) should be the lambda element, not the enclosing element.  About the only place where lambdas are not relevant for the UI is in IJavaElement#getChildren(), since we don't intend to show lambdas in the Outline (but we can also filter them out in the UI if that's easier).  Lambdas share many properties of IType and IMethod, but on the other hand also don't support some of their methods. E.g. IType#create*(*) doesn't make sense, the ISourceManipulation methods can just throw a JME, the type name will be "" (like for anonymous types) and the name range will be null.  The API of ITypeHierarchy looks like we need at least an IType for a lambda.  For existing Java model clients, the best solution would be to have an IType as well as an IMethod for a lambda expression (rather than a new kind of IJavaElement or only an IType but not an IMethod).  If it reduces the implementation effort, we can also try to treat lambda elements as pseudo-elements like ILocalVariable , ITypeParameter, IAnnotation, which are not part of IJavaElementDeltas, and which are not returned by getChildren().
"Whilst optimizing for least ambiguity in overloaded methods with most flexibility in how an API might let them be called I listed all the options that I could think of and got a lot of these exceptions. I'm not sure which of the 10 cause it so the test class is a bit bigger:  package npe.ConstraintTypeFormula.reduceSubType.line201; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.function.Consumer;  @FunctionalInterface interface Use<T, E extends Throwable> {   void accept(T t) throws E; }  @SuppressWarnings(""unused"") public class SomethingBreaks<T, E extends Throwable> {   protected static SomethingBreaks<String, IOException> stream() {     return null;  }    public void forEach(Consumer<T> use) throws E {}    public <E2 extends E> void forEach(Use<T, E2> use) throws E, E2 {}    private static void methodReference(String s) throws IOException {     System.out.println(Files.size(Paths.get(s)));   }      public static void useCase1() throws IOException {     Use<String, IOException> c =       (String s) -> System.out.println(Files.size(Paths.get(s)));     stream().forEach(c);   }      public static void useCase2() throws IOException {     Use<String, IOException> c = SomethingBreaks::methodReference;     stream().forEach(c);   }      public static void useCase3() throws IOException {     stream().forEach((Use<String, IOException>) (String s) -> System.out.println(Files.size(Paths.get(s))));   }      public static void useCase4() throws IOException {     stream().forEach((Use<String, IOException>) SomethingBreaks::methodReference);   }      public static void useCase5() throws IOException {     stream().<IOException> forEach((String s) -> System.out.println(Files.size(Paths.get(s))));   }      public static void useCase6() throws IOException {     stream().<IOException> forEach(SomethingBreaks::methodReference);   }      public static void useCase7() throws IOException {     stream().<Use<String, IOException>> forEach((String s) -> System.out.println(Files.size(Paths.get(s))));   }      public static void useCase8() throws IOException {     stream().<Use<String, IOException>> forEach(SomethingBreaks::methodReference);   }      public static void useCase9() throws IOException {     stream().forEach((String s) -> System.out.println(Files.size(Paths.get(s))));   }      public static void useCase10() throws IOException {     stream().forEach(SomethingBreaks::methodReference);   } }   This is the stack trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(ConstraintTypeFormula.java:201) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:587) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:603) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:541) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:526) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:114) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:717) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:673) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1630) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2752) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:852) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:684) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:549) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:542) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:485) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:475) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"This code results in an NPE:  interface Base {  	Base get(int x); } class Main {     <T> Base foo(Base b) {          return null;       }     void bar(Base b) { }     void testCase() {         bar(foo((int p)->null));      } }  And the stack trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:393) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:162) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:162) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:128) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:741)"
"The following code should not be allowed, but ECJ compiles it:  class C1 {} class C2 {}  interface I<P1 extends C1, P2 extends P1> {     P2 foo(P1 p1); }  public class Main  { 	    public static void main(String argv[]) { 	    	I<?, ?> i = (C1 c1) -> { return new C2(); }; 	        Object c2 = i.foo(null); 	    } }  Note that C1 and C2 have no relationship and hence C2 can't be returned for P2 (which effectively extends C1). As you would expect, this throws up ""java.lang.VerifyError: Bad return type"" when the program is run."
This happens only when the parameter of the method being invoked is a parameterized type with wildcard. Here is an example:  interface I<T> {     void foo(T t); } public class X {     void bar(I<?> i) {         i.foo(null);     }     void run() {         bar((X x) -> {}); // Incompatible error reported     } }  The reported error: The method bar(I<?>) in the type X is not applicable for the arguments ((X x) -> { })  The error goes away when bar() is rewritten to be "void bar(I<X> i)"
Bug 424712 showed that possibly a CallinBinding18 might be accessed in unsafe ways, here: dereferencing .wildcard, which is null for CallinBinding18.  While bug 424712 is resolved by way of other improvements, we should think of ways to make the use of CallinBinding18 safe in all situations.
This issue seems similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=415981, but I'm not sure if it's identical.  javac compiles this valid Java code.      public interface MyFunction<Input, Output>     {         Output apply(Input input);     }          public <Input, Output> List<Output> wrap(MyFunction<? super Input, ? extends Output> function, Input input)     {         return Arrays.asList(function.apply(input));     }  ecj rejects it with "Type mismatch: cannot convert from List<capture#2-of ? extends Output> to List<Output>"
The binding for 'this' should have type annotations when the corresponding receiver or constructor is annotated.  Example that also includes annotated parameters for comparison:   package pack2;  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @interface A {     int value() default 0; }  public class Outer {     void foo(@A Outer this, @A Outer arg) {         this.hashCode(); //      ^ binding is "Outer"; expected "@A Outer"         arg.hashCode(); //      ^ type binding is "@A Outer" (good)     }          class Inner {         public @A(1) Inner(                 @A Outer Outer.this, @A Outer arg2) { //                       ^ type binding is null; expected "@A Outer"             Outer r1 = Outer.this; //                     ^     ^ bindings are "Outer"; expected "@A Outer"             Outer r2 = arg2; //                     ^ binding is "@A Outer" (good)             Inner i = this; //                    ^ binding is "Inner"; expected "@A(1) Inner"         }     } }   The receiver qualifier in "Outer.this" has no binding. It should have the same binding as a reference to "Outer.this" in the constructor body.
// -- interface I<T, S extends X<T>> {      T foo(S p); }  public class X<T>  {     public void bar() {     I<Object, X<Object>> f = (p) -> p; // Error     } }  Compiles fine with javac.
"+++ This bug was initially created as a clone of Bug #424296 +++  interface FIOther<T> { 	<M> FIOther<T> run (M x); }  public class TestOther {     FIOther<String> fi1 = new FIOther<String>() {public <M> FIOther<String> run(M x) {return null;}};      }   "
"+++ This bug was initially created as a clone of Bug #424296 +++  Annotations are lost in this example:   // -- interface I { 	void goo(String ... strings); }   public class X { 	public static void main(String[] args) { 		I i = new I() {  			@Override 			"
"What steps will reproduce the problem? 1. Plain build on eclipse of a project that does build correctly on Junos SR2 and former versions 2.  3.    -- Error Details -- Date: Fri Jan 10 18:22:21 IST 2014 Message: Errors running builder 'Java Builder' on project 'Topology'. Severity: Error Product: Eclipse 2.0.1.20130919-0803 (org.eclipse.epp.package.jee.product) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.7.0_45 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product  Exception Stack Trace: java.lang.NullPointerException 	at java.lang.String.<init>(Unknown Source) 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.conditionalArgumentsIncompatibleTypes(ProblemReporter.java:1445) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.resolveType(ConditionalExpression.java:600) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1802) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799) 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799) 	at org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression.resolveType(CombinedBinaryExpression.java:344) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:605) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:970) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:127) 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:1100) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114) 	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.resolve(WhileStatement.java:263) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:510) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:265) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:469) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1185) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1295) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:561) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Unknown Source)"
// ERROR: Cannot convert from Object[] to Integer[] final Integer[] boom =   Arrays.asList("1", "22", "333")   .stream()   .map(str -> str.length())   .toArray(i -> new Integer[i]);  // WORKAROUND: casting final Integer[] boom =   Arrays.asList("1", "22", "333")   .stream()   .map(str -> str.length())   .toArray((IntFunction<Integer[]>) i -> new Integer[i]);
Created attachment 238880 [details] contains two projects to show this issue  I am using JDT/Eclipse Java 8 Support (version is 1.0.0.v20140110-0104_BETA_JAVA8).  I attach two projects. - apt-lib (contains an annotation processor to log this issue) - apt-client (contains processed source code)  The log is following: ----- eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=ja_JP Framework arguments:  -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocation Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocation  Info Sat Jan 11 09:55:58 JST 2014 class=client.MyInterface, method=run, param=value, annotationSize=0, myParam=null -----  This log shows that the type annotation 'lib.MyType' is processed, but the parameter annotation  'lib.MyParam' is not found.
We should compile      (int [] & Serializable) new int [0];  javac doesn't, but that is a bug.
"!ENTRY org.eclipse.jdt.core 4 4 2014-01-13 20:21:04.124 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package snippet;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class Snippet {     Object ax = new @A Outer().new Middle<String>(); }  @Target(ElementType.TYPE_USE) @interface A {} class Outer {     class Middle<E> {} }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:105) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:135) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:938) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:287) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:147) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveTypeEnclosing(ParameterizedSingleTypeReference.java:367) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:331) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:965) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:204) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:270) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
master and BETA_JAVA8  Some references to parameterized nested types have type bindings whose IBinding#isDeprecated() wrongly returns false.  The uncommented references are OK:  @Deprecated public class Outer<O> {     @Deprecated     public class Middle<X> {         @Deprecated         public class Inner<E> {         }     }          Outer<String> o;     Middle<String> m; // Middle should be deprecated     Outer<String>.Middle<String> m2; // Middle should be deprecated     Outer.Middle m3;      Middle<String>.Inner<Object> i; // Inner should be deprecated } class Ref {     Outer<String> o;     Outer<String>.Middle<String> m;     Outer<String>.Middle<String>.Inner<Object> i; }
From JSR 335 spec 0.9.1, 15.28   It is a compile-time error If a method reference has the form ClassType :: NonWildTypeArguments new, where a constructor type argument list is provided, but the ClassType is a raw type.  So the following program must be rejected, but we don't:  // -- class Y<T> {     Y() {} }      interface I {     Y<Y> foo(); }  public class X  {     I i = Y::<X>new; }
"See https://bugs.openjdk.java.net/browse/JDK-7139681  javac8 has started compiling this code:  // -- public class X { 	int[] i = {1, 2, 3}; 	void foo() { 		for (int i : i) { 			System.out.println(i); 		} 	} }  while eclipse continues to reject it."
Created attachment 238978 [details] Project reproducing the bug  In the Wildfly project, the CacheGroupService class is annotated with @Listener, from the Infinispan project (org.infinispan.notifications.Listener)[1]. CacheGroupService implements org.wildfly.clustering.group.Group, which itself defines an inner interface named Listener[2]  When JDT APT is enabled, there's a compilation error appearing on CacheGroupService[3] : Type mismatch: cannot convert from Group.Listener to Annotation  Without APT enabled, there's no error.  I managed to reproduce the issue with a simpler setup (attached). Unzip and import as an eclipse project. You'll see an error on test.Foo, annotated with @Something from the annotation package. Foo extends SomeClassDeclaringSomethingToo. Disabling APT makes the error go away.   [1] https://github.com/wildfly/wildfly/blob/5670d12b5576d2695f9af7114e548805c87d302e/clustering/server/src/main/java/org/wildfly/clustering/server/group/CacheGroupService.java#L32 [2] https://github.com/wildfly/wildfly/blob/5670d12b5576d2695f9af7114e548805c87d302e/clustering/api/src/main/java/org/wildfly/clustering/group/Group.java#L32 [3] http://i.imgur.com/hRor2Gd.png
"BETA_JAVA8:  // -- public class X {     {         bar( () -> (char) 0); // [1]     }     void bar(FB fb) { }     public static void main(String[] args) { 		System.out.println(""OK""); 	} } interface FB { 	byte foo(); }  elicits:   The method bar(FB) in the type X is not applicable for the arguments (() -> (char) 0)  This program is valid - bug is LE.isCompatibleWith - when checking return expressions, we should not use parameterCompatibilityLevel, we should see if the expression is assignmenet compatible instead as would be done for return expressions.  Expression [] returnExpressions = this.resultExpressions; 		for (int i = 0, length = returnExpressions.length; i < length; i++) { 			if (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate 				if (!returnExpressions[i].isCompatibleWith(sam.returnType, this.enclosingScope)) 					return false; 			} else { 				if (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) { 					if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block) 						return false; 				} 			} 		}  This is at the root of the problem reported in https://bugs.eclipse.org/bugs/show_bug.cgi?id=423803#c6"
The following code is allowed by ECJ:  interface I {    default Object clone() { return null; } } public class Main  {     public void foo() {         I x = new I(){};         System.out.println(x.clone());     } }  While Javac rejects it as clone is a protected method and should not be allowed to be accessed.
"BETA_JAVA8:   This is probably a recent regression.  // -- interface I {    default void foo(Object obj) { 	   System.out.println(""interface method"");    } } class Base {     public void foo(Object obj) {         System.out.println(""class method"");    } } public class X extends Base implements I { 	 public static void main(String argv[]) { 	    	new X().foo(null); 	    } }  Patch will follow shortly."
"This is as often reproducible as not.  When I run RunAllJava8Tests, testBug424195a fails because the actual error message is   ""----------\n"" +  		""1. ERROR in NPEOnCollector.java (at line 18)\n"" +  		""	.distinct().collect(Collectors.toCollection(ArrayList::new));\n"" +  		""	                                            ^^^^^^^^^^^^^^\n"" +  		""The constructed object of type ArrayList is incompatible with the descriptor\'s return type: Stream<JarEntry>&Collection<T#2>&Collection<JarEntry>\n"" +  		""----------\n""  : Not what the test expects.  Running the GenericsRegressionTest_1_8 suite alone also shows the problem, but  less consistently."
As far as I understood bug 409586, ITypeBinding#getTypeDeclaration() should always strip off type annotations from an ITypeBinding.  This currently works fine for a parameterized type binding, but it doesn't work for other kinds (primitive, class, interface, raw, array, ...).   package bug;  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.List;  @Target(ElementType.TYPE_USE)   @interface A {     int value() default 0; }  public class GetTypeDeclarationProblems {     @A int primitive;     @A Object clazz;     java.lang.@A Object qualified;     @A List raw;     @A List<@A(1) String> parameterized;     @A List<@A(1) ?> wild;     @A String @A(1) [] array;     @A List<@A(1) String> @A(2) [] array2; }
"Place the following code after the call to unit.reconcile(..) in org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy#reconcile(ICompilationUnit, boolean):  AbstractTypeDeclaration test= (AbstractTypeDeclaration) ast.types().get(0); FieldDeclaration fi= (FieldDeclaration) test.bodyDeclarations().get(0); VariableDeclarationFragment vdf= (VariableDeclarationFragment) fi.fragments().get(0); LambdaExpression lambda= (LambdaExpression) vdf.getInitializer(); VariableDeclaration param= (VariableDeclaration) lambda.parameters().get(0); if (param instanceof SingleVariableDeclaration) { 	IBinding binding= ((SingleVariableDeclaration) param).getName().resolveBinding(); 	System.out.println(ast.findDeclaringNode(binding)); } else { 	IBinding binding= ((VariableDeclarationFragment) param).getName().resolveBinding(); 	System.out.println(ast.findDeclaringNode(binding)); }  ------------------------------------------------------ Edit the following example code to invoke the reconciler and check the Console view for the result:  public class C1 { 	FI fi= (x2) -> x2; }  @FunctionalInterface interface FI { 	int foo(int n); }  ------------------------------------------------------ #findDeclaringNode returns ""null"" when there is no type specified at the lambda parameter.  If we modify the lambda expression to include the parameter type, #findDeclaringNode returns the correct AST node:          FI fi= (int x2) -> x2;"
"Created attachment 239023 [details] eclipse project to test.  Hello, I have an error while opening a file in eclipse for editing. Attached an eclipse project to test. open ""Test.java"" and it will fire an error.  An internal error occurred during: ""Requesting Java AST from selection"". java.lang.StackOverflowError  I am using jdk 8 ea b123 and followed http://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_(BETA)  So there is installed :   Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140115-0104_BETA_JAVA8	org.eclipse.jdt.java8patch.feature.group	Eclipse.org    Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140115-0104_BETA_JAVA8	org.eclipse.pde.java8patch.feature.group	Eclipse.org    Eclipse RCP Patch for Java 8 Support (BETA)	1.0.0.v20140115-0104_BETA_JAVA8	org.eclipse.rcp.java8patch.feature.group	Eclipse.org"
"BETA_JAVA8, Java project set up with JDK 1.8.0-ea-b120  Search for references to method java.util.Objects#requireNonNull(T)  !ENTRY org.eclipse.core.jobs 4 2 2014-01-15 19:14:14.185 !MESSAGE An internal error occurred during: ""Java Search"". !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(ConstraintTypeFormula.java:201) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:639) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.addTypeBoundsFromWildcardBound(BoundSet.java:504) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.incorporate(BoundSet.java:456) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:532) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:114) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:720) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:676) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2794) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:857) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:689) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:641) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1733) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1150) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1191) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1323) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
The test GTT_1_8.testBug425798() currently witnesses a wrong outcome:  The example should be accepted whereas we report: The type of annotationType() from the type Annotation is Class<? extends Annotation>, this is incompatible with the descriptor's return type: Class<capture#3-of ? extends Annotation>  Not marking as inference-related, because the error is reported in the regular part of RE.resolveType().
"Hello, I encountered this problem while compiling my workspace with java 8 ea b123 and     Eclipse Java Development Tools Patch for Java 8 Support (BETA)	        1.0.0.v20140117-0105_BETA_JAVA8	org.eclipse.jdt.java8patch.feature.group	Eclipse.org   Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140117-0105_BETA_JAVA8	org.eclipse.pde.java8patch.feature.group	Eclipse.org   Eclipse RCP Patch for Java 8 Support (BETA)	                                1.0.0.v20140117-0105_BETA_JAVA8	org.eclipse.rcp.java8patch.feature.group	Eclipse.org  (I followed http://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_(BETA) )  !ENTRY org.eclipse.core.resources 4 2 2014-01-17 08:14:09.968 !MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.core.resources"". !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.leavePolyInvocation(InferenceContext18.java:853) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:121) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:642) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:545) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:530) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:114) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:720) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:676) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2794) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:857) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:689) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1296) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:538) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:641) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:594) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:594) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1296) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:538) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)   eclipse.buildId=unknown java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=fr_FR Framework arguments:  -product org.eclipse.platform.ide Command-line arguments:  -product org.eclipse.platform.ide -data C:\java\data\dev\headjava8 -dev file:C:/java/data/dev/AnalyseJava8/.metadata/.plugins/org.eclipse.pde.core/Eclipse Infologic Java8/dev.properties -os win32 -ws win32 -arch x86 -consoleLog"
"This semantically invalid class causes the IDE to go into error-spewing mode when parentheses are not balanced, specifically when one is missing between the two annotations on the return value's type. While reducing the test case the NPEs started shifting to a different operation stage and thus this report is a combination of two Error Log events.  What steps will reproduce the problem? 1. Copy-Paste the code below into workspace and save. 2. Make sure that the line containing the compose method's return value with its annotations has not been split at least up to the method's name. 3. Remove one of the parentheses from  before::apply))  4. Then Error Log displays a lot of errors.   import java.lang.annotation.Annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface Throws {   Class<? extends Throwable>[] value() default Throwable.class;   Returns method() default @Returns(Annotation.class); }  @Target(ElementType.TYPE_USE) @interface Returns {   Class<? extends Annotation> value() default Annotation.class; }  @FunctionalInterface public interface CopyOfFunction<T, @Returns R> {   @Returns  R apply(T t);    default <V> @Throws(((CopyOfFunction<? super V, ? extends T>) before::apply)) @Returns CopyOfFunction<V, @Returns R>     compose(CopyOfFunction<? super V, ? extends T> before) {      return (V v) -> apply(before.apply(v));   } }  Here is the trace:  -- Error Details -- Date: Sun Jan 19 04:27:11 EET 2014 Message: Error in JDT Core during AST creation Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jdt.ui Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0-ea java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.internalBoundCheck(TypeVariableBinding.java:165) 	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.boundCheck(TypeVariableBinding.java:84) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.boundCheck(ParameterizedTypeBinding.java:96) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:291) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:147) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:359) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:551) 	at org.eclipse.jdt.internal.compiler.ast.CastExpression.resolveType(CastExpression.java:517) 	at org.eclipse.jdt.internal.compiler.ast.MemberValuePair.resolveTypeExpecting(MemberValuePair.java:92) 	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:743) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:850) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:720) 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:625) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1772) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1465) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:853) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:549) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:542) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:485) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Created attachment 239121 [details] Screenshot  Hi, I'm chinese, and in eclipse 4.3.1 jee edition, may there are one erro, that is in the "javadoc display dialog", I would like to display the javadoc for chinese version, but it display the chinese garbled? can any one tell me whay? bacause in v4.2.x it's looks okay!
"// BETA_JAVA8  interface Functional<T> {     void foo(T t); } interface I { } public class X { 	public static void main(String[] args) {     	Functional<? extends X> f = (Functional<? extends X> & I) (X c) -> {     		System.out.println(""main"");     	};     	f.foo(null);     } }   The program above is rejected by ECJ erroneously."
"This program crashes when run:  public class X { 	<T> int square(int i) { 		return i * i; 	} 	boolean isOdd(boolean what) { 		return square(what ? new Integer(1) : new Integer(2)) % 2 == 1; // trouble here 	} 	public static void main(String argv[]) { 		System.out.println(new X().isOdd(true)); 	} }  Note that the program runs fine if you: 1. remove the type parameter <T> (or) 2. substitute the 'what' with a boolean literal (or) 3. get rid of the boxing for int primitive  So, looks like all these are playing a part here."
"This code causes an LCE when run:  interface Functional {     Long square(Integer a); }  public class X {     static class Base {     	 private Long square(Integer a) {              return Long.valueOf(a*a);          }      }     static class SubClass extends Base {         public Long callSquare(Integer i) {             Functional fi = SubClass.super::square;             return fi.square(i);         }     }     public static void main(String argv[]) throws Exception {     	System.out.println(new SubClass().callSquare(-1));     } }  Looks like the method reference in the lambda is associated with SubClass even though it is declared to be from 'super'."
"Follow up of bug 417937  package pack1; import pack2.B;  public class X{ 	public void foo( B @Marker[] arg,  A a) {}  } class C{} @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE) @interface Marker {}  Refactor ""foo"" => Move to A @Marker annotations dropped."
"package p;  class X { 	public void foo(B [] arg, A a) { } }  class A { 	 } class B {  	 } ------------------------------------  Move method #foo to A. We get the following exception:  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:422) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) ... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.dom.Bindings.equals(Bindings.java:91) 	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor$VisibilityAdjustingArgumentFactory.adjustTypeVisibility(MoveInstanceMethodProcessor.java:1011) 	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor$1.getArgumentNode(MoveInstanceMethodProcessor.java:2062) ..."
// -- import java.util.Comparator;  public class X  {     public static void main(String argv[]) {         Comparator<? extends String> c = true ? (Integer i, Integer j) -> { return 0; } : (Long i, Long j) -> { return 1; };     } }   The fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=423685 has exposed this issue.
The disassembler output should print actual strings for bootstrap methods, not just constant pool index #s.  E.g. for the example in bug 422016 comment 10, I get:  Bootstrap methods:   0 : # 67 arguments: {#68,#71,#72}   Expected:  Bootstrap methods:   0 : #67 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;     arguments:       #68 ()V       #71 invokestatic jsr335/Main.lambda$0:()V       #72 ()V
// -- import java.util.ArrayList; import java.util.List;  public class X {     public static void main(String argv[]) {        goo(foo());     }      static <T extends Number> List<T> foo() {         return new ArrayList<T>();     }      static void goo(Object p1) {         System.out.println("goo(Object)");     }      static void goo(List<Integer> p1) {         System.out.println("goo(List<Integer>)");     } }  On the program above, ECJ compile results in goo(Object) while javac compile results in goo(List<Integer>)
Created attachment 239202 [details] /Users/eclipse/Documents/eclipse.jdt.ui.patch  In recent Mac OS X versions (at least since 10.8), Mission Control by default uses shortcuts Ctrl+Up and Ctrl+Down. Their Shift-ed variants do the same, but slow down the animations. Yes, they sacrificed shortcuts for a show-effect nobody needs.  "Expand Selection To > Enclosing Element" and "Restore Last Selection" conflict with Mission Control. We have to reassign at least those two commands, but to keep the four directions in sync, I've also reassigned the "Next/Previous Element" commands.
"// -- public class X { 	static int foo(Object x) { 		return 0; 	} 	static int foo(int e) {  		return 1;  	}  	public static void main(String args[]) {  		Object x = new Object(); 		System.out.println(foo(true ? x : new int[0]) != 0); 	} }  triggers:   java.lang.UnsupportedOperationException: Unexpected control flow, should not have reached Expression.isCompatibleWith 	at org.eclipse.jdt.internal.compiler.ast.Expression.isCompatibleWith(Expression.java:1158) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.isCompatibleWith(ConditionalExpression.java:707) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4625) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4594) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel18(Scope.java:829) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:738) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:676) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2479) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:856) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:689) 	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:831) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:641) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55) 	at java.lang.reflect.Method.invoke(Method.java:613) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:88) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55) 	at java.lang.reflect.Method.invoke(Method.java:613) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
// -- abstract class Y {      public abstract void foo(Object[] x);     public abstract void goo(Object[] x); }  interface I {    default public <T> void foo(T... x) {};    public abstract void goo(Object ... x); }  public abstract class X extends Y implements I {  }  triggers an incorrect name clash error.
"package a;  import java.util.Collections; import java.util.List;  /**  * @author tomschindl  *  */ public class Test { 	public static class A { 		public A(B newSelectedObject, String editorController) { 	    }  	    public A(List<B> newSelectedObjects, String editorController) { 	    } 	} 	 	public static class B { 		 	} 	 	public static class C extends A { 		public C() { 			super(Collections.emptyList(), """"); 		} 	} }  It looks like the type-inference is broken the above code should just compile but fails with an exception. The compilation succeeds if the type is speced explicitly:  super(Collections.<B>emptyList(), """");"
Have the following in the clipboard (without the ---- delimiters) and then use Navigate > Open from Clipboard:  ------------------------------------------------------------ java.lang.Exception: Test did not run: testNullParams(org.eclipse.osgi.tests.util.BidiTextProcessorTestCase) at org.eclipse.core.tests.session.SessionTestRunner.run(SessionTestRunner.java:313) at org.eclipse.core.tests.session.TestDescriptor.run(TestDescriptor.java:87) at org.eclipse.core.tests.session.SessionTestSuite.runSessionTest(SessionTestSuite.java:156) at org.eclipse.core.tests.session.SessionTestSuite.runTest(SessionTestSuite.java:174) at org.eclipse.core.tests.session.ConfigurationSessionTestSuite.run(ConfigurationSessionTestSuite.java:217) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) ------------------------------------------------------------  => Command aborts with NPE:  java.lang.NumberFormatException: For input string: "org.eclipse.osgi.tests.util.BidiTextProcessorTestCase"         at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)         at java.lang.Integer.parseInt(Integer.java:492)         at java.lang.Integer.valueOf(Integer.java:582)         at org.eclipse.jdt.internal.debug.ui.actions.OpenFromClipboardAction.getJavaElementMatches(OpenFromClipboardAction.java:323)         at org.eclipse.jdt.internal.debug.ui.actions.OpenFromClipboardAction.run(OpenFromClipboardAction.java:200) ...  There are many problems at work here. After bug 327443, the whole input string is put on one line and all whitespace is removed. Then, OpenFromClipboardAction#getMatchingPattern(String) calls s.matches(STACK_TRACE_LINE_PATTERN), although that pattern doesn't make sense for multi-line inputs, since it starts with ".*". Finally, #getJavaElementMatches(..) uses s.indexOf('(') instead of lastIndexOf, which causes the NPE.  A quick fix for the NPE is to replace said indexOf with lastIndexOf. That still resolves a wrong type, but that doesn't matter, since the multi-line input text ends up in the Console view anyway.  However, the parsing still does way too much (e.g. all references to WS are pointless after whitespace is removed, and all patterns containing ".*" match too much for non-trivial input).
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=424211#c5  // -- public class X { 	public static void main(String argv[]) throws Exception { 		((Serializable & AutoCloseable) (() -> {})).close(); 	} }   This program fails at runtime."
EclipseCompiler#run() implements javax.tools.Tool#run(), which has following javadoc:       * @param in "standard" input; use System.in if null      * @param out "standard" output; use System.out if null      * @param err "standard" error; use System.err if null  EclipseCompiler doesn't take care of this, instead just passes along the parameters err and out. This needs to be fixed.
Good:  org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test425512()  Bad:  org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test425512cd()  No idea why.
Created attachment 239259 [details] Testcase  As the attached test case demonstrates, EclipseFileManager.inferBinaryName(Location, JavaFileObject) throws an IAE when name for a file of OTHER kind is requested. The Javadoc in JavaFileManager#inferBinaryName() doesn't say anything about this scenario, although it doesn't talk anything about Kind.OTHER being not supported.
ITypeBinding#createArrayType(int) should preserve existing type annotations.   For primitive types, it currently strips all type annotations. For other types, it preserves annotations on the element types but not on dimensions.   Example code to play in the ASTView:  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE)   @interface A {     int value() default 0; }  class Test {     @A int @A(1)[] @A(2)[] is;     @A String @A(1)[] @A(2)[] ss; }
While reviewing the DOM APIs, I found that PackageDeclaration#annotations() and TypeParameterModifier#annotations() are a bit odd:  These are the only declaration nodes that have an #annotations() property. All other declaration nodes use #modifiers(). Elsewhere, #annotations() is only used on type references (AnnotatableTypes / Dimension).  The JLS8 grammar also uses the nonterminals "PackageModifier" and "TypeParameterModifier", which hints that future language versions may add other modifiers there (e.g. for accessibility).  To future-proof our APIs, we should rename these #annotations() properties and generalize their type to IExtendedModifier.
This is the Javadoc from StandardJavaFileManager#getJavaFileObjectsFromFiles()      /**      * Gets file objects representing the given files.      *      * @param files a list of files      * @return a list of file objects      * @throws IllegalArgumentException if the list of files includes      * a directory      */  But both the following JDT implementations allow directories and need to be fixed:  org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager org.eclipse.jdt.internal.compiler.tool.EclipseFileManager  A patch will follow.
(In reply to Jayaprakash Arthanareeswaran from comment #21) > If you took this new code that create new annotations from the UI code, it > may not be a bad idea to move that code to Core so both Core and UI could > use that.  Yes, we should not duplicate nontrivial code. We should remove the old org.eclipse.jdt.internal.corext.dom.ASTNodeFactory#newAnnotation(..) and turn ImportRewrite#newAnnotation(..) into an API like this:  /**  * Adds the necessary imports for the given annotation binding to the rewriter's record  * and returns an {@link Annotation} that can be used in the code.  * <p>  * No imports are added for types that are already known. If an import for a type is recorded to be removed, this record is discarded instead.  * </p>  * <p>  * The content of the compilation unit itself is actually not modified  * in any way by this method; rather, the rewriter just records newly added imports.  * </p>  * @param binding the annotation to be added  * @param ast the AST to create the returned annotation for  * @param context an optional context that knows about types visible in the current scope or <code>null</code>  * to use the default context (only using the available imports)  * @return an annotation node. The returned annotation contains unqualified type names where  * an import could be added or was already known. Type names are fully qualified if an import conflict prevented an import.  *   * @since 3.9 BETA_JAVA8  */ public Annotation addAnnotation(IAnnotationBinding annotation, AST ast, ImportRewriteContext context)
Bindings from reconciler are sometimes missing type annotations.  - launch a clean runtime workspace with a 1.8 JRE - copy all the code below to the clipboard and paste it into the Package Explorer in one batch - put the caret after "bug.imports.Outer.getInner();" and press Ctrl+1, Enter  => The created field type is "@A(1) Outer<Random>.Inner<Date> inner", which misses most of the type annotations.  The problem is that the AST from the SharedASTProvider is missing these type annotations in the binding for the ...getInner() expression. This can also be seen in the ASTView if you switch to "Use SharedASTProvider.getAST" or "Use ICompilationUnit.reconcile".  Workaround to get correct bindings: Switch to another Java editor and then switch back. In this case, an ASTParser is used to feed the SharedASTProvider. If you modify the active editor, then the bindings become wrong again.   ============================= package bug.imports;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE)   public @interface A {     int value() default 0; }  package bug.imports;  public class Outer<O> {     public class Inner<I> {     }          public static @A(1) Outer<java.util.@A(2) Random>.@A(3) Inner<java.util.@A(4) Date> getInner() {         return null;     } }  package bug.imports;  public class Client { //    class Random {} //    class Date {} //    class Outer {} //    class Inner {} //    class A {}          void foo() {         bug.imports.Outer.getInner();     } }  ======================================
"package bug.formatter;  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @interface T { }  public class C { 	java.util.concurrent.@T Callable c; 	java.util.@T Set<java.lang.@T String> s; }  The formatter inserts bad spaces after the package components of an annotated qualified type (but it seems to be afraid of touching a parameterized type):  	java. util. concurrent.@T Callable c; 	java.util.@T Set< java. lang.@T String> s;"
Seems to be a problem with both new and old inference schemes.  // -- X.java:   import p.*;  public class X  {     public static void main(String argv[]) {         new B().foo(null, null);     } }       // B.java package p;  class A { }  public class B extends A {     public <T extends A> void foo(T ... o) { } }  If the Type parameter T were to be replaced directly by A, I get an error as expected.
"This is the test code:  public class X { 	void foo(J[] list, I<J<?>> i) { 		sort(list, i); 	} 	 	<T> T[] sort(T[] list, I<? super T> i) { 		return list; 	} } interface I<T> {} interface J<T> {}  The invocation sort(list, i) should be reported but not."
"// -- import java.util.stream.Stream; import java.util.Collections; import static java.util.stream.Collectors.collectingAndThen; import static java.util.stream.Collectors.toList; public class X { 	Object o = ((Stream<Integer>) null).collect(collectingAndThen(toList(), Collections::unmodifiableList)); }  This snippet fails to compile with HEAD. b123 likes the code fine."
"Here's my testcase:  public class X { 	 	<T extends Comparable & Serializable> void foo(T o1) { 	}  	<T extends Serializable> void foo(T o1) { 	}  	void bar() { 		foo((Comparable & Serializable)0); // [1] not applicable for error 		foo(0); // [2] ambiguous for type error 	} }  As demonstrated by the following code, if you add a type argument to Comparable, the second error goes away.  public class X { 	 	<T extends Comparable<T> & Serializable> void foo(T o1) { 	}  	<T extends Serializable> void foo(T o1) { 	}  	void bar() { 		foo(0); // No issues here 	} }"
// -- package p;  public class X {    static public int f; }  // -- package q; public class X {    static public int f = 6; }   // --- import static p.X.f; import static q.X.f;  public class X {      public static void main(String argv[]) {     } }   elicits: "The import q.X.f collides with another import statement"  JLS7 7.5.3 says nothing about collision of single static imports.  JDK8 has started accepting this code and for compatibility's sakes we should too.  Related javac bugs:  https://bugs.openjdk.java.net/browse/JDK-4980495 https://bugs.openjdk.java.net/browse/JDK-8019461  The dates don't quite tally up, but these have some discussion FWIW.
"Code causing the exception:  interface I<U, V extends J<U>> {  	void foo(U u, V v);  }  interface J<T> {}  public class X  {      public void bar(FI<?, ?> fi) {}      public static void main(String args[]) {       new X().bar((p, q) -> {});      } }   Note that bar takes a parameter of type FI, which doesn't exist. And the excepton thrown is:  java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 0 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getNonWildcardParameterization(ParameterizedTypeBinding.java:1367) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.findGroundTargetType(LambdaExpression.java:419) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:743) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4641) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4610) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel18(Scope.java:836) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:741) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:679) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1666) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2801) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:862)"
Created attachment 239302 [details] Fix (tests green)  Can we use the standard syntax in org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding#toString()?  I find the "@A{ value = (int)1}" form hard to read in the debugger.  Secret plan: I'd like to abuse this toString() method in the ASTView to render type bindings with type annotations.
"the first method does NOT compile, the 2nd does:  import javafx.animation.Interpolator; import javafx.animation.KeyFrame; import javafx.animation.KeyValue; import javafx.beans.property.SimpleDoubleProperty; import javafx.util.Duration;  public class FXTestCases { 	void test1_fail() { 		KeyFrame keyFrame = new KeyFrame(Duration.millis(100),new KeyValue(new SimpleDoubleProperty(), 0,                 Interpolator.EASE_BOTH)); 	} 	 	void test1_success() { 		KeyValue kv = new KeyValue(new SimpleDoubleProperty(), 0,                 Interpolator.EASE_BOTH); 		new KeyFrame(Duration.millis(100),kv); 	} }  To get the javafx imports resolved in eclipse you need to modify yours project JRE System Library's Access rules to make ""javafx/**"" accessible."
"It looks like as if the type inference for the tenary operator is broken:  class A { 		 	} 	 	class B extends A { 		 	} 	 	class C extends B { 		 	} 	 	class D { 		D(A a) { 			 		} 		 		D(boolean b) { 			this(b ? new B() : new C()); 		} 	}  produces ""The constructor FXTestCases.D((b ? new B() : new C())) is undefined"""
I know, you are not finished, but just some feedback for type annotations:  If you compile the following with the Eclipse Compiler: (Size is an easy Type Annotation with 1 argument for wasier debugging)  List<@Size(max = 41) CharSequence>[] @Size(max = 42) [] @Nonnull @Size(max = 43) [][] test = new @Size(max = 44) ArrayList @Size(max = 45) [10][][] @Size(max = 47) @Size(max = 48) [];  Then we find multiple (none-cosmetic) differences in the compiled byte in comparision to JDK 8 (most recent build), some of them not spec conform I think.  1.) No attribute "Local variable type table" with the generic type info for the variable is rendered, I know generic array declarations are somewhat so-so from spec view. JDK 8 generates this happily... (But you generate the type annotation info for the CharSequence type param.)  2.) Size(44) till Size(4) appear 2 times in the Bytecode, one is correct int he array structure, but you generate it again for the local variable. So they appear at the wrong place, whats against the spec (not repeatable type annotations can appear multiple times)  3.) The new operation has offset 2, if new is the second operation. I think thats like described (fuzzily) in the spec. The JDK 8 has the previos operation pc as offset! So you are different. I think the JDK is wrong here, you might have shorter/stronger communication lines to the JDK team?!  4) Little bit different topic, but same stuff for me: Java Bytecode Viewer doesn't show class level type annotation attributes...
"Consider the following program:  // - interface I { 	 <T> void foo (T... p); } abstract class A implements I { 	public void foo(Object [] p) { 		System.out.println(""A.foo""); 	} } public class X extends A { 	public static void main(String[] args) { 		A a = new X(); 		a.foo(""hello"", ""world""); 	} }  At the call site, A.foo is not applicable given the arguments and parameters differ in length.  I.foo is accessible and applicable, but A.foo does override it without being applicable."
On this example:  import static java.util.stream.Collectors.toList; public class Y {         Object o = toList(); }  inference never terminates, because some inference variable has neither lower nor upper bounds, and hence no progress is made during resolution.  One could argue, that this rule  * Otherwise, where αi has proper upper bounds U1, ..., Uk, Ti = glb(U1, ..., Uk).  implicitly includes the case of k=0, where glb() is probably assumed to answer j.l.Object.
I tried adjusting our production scripts to build the "BETA_JAVA8 branch" and in first attempt got the errors below. I have not looked at it enough to know if "real" error, or related to "production scripts" ... just wanted to get it documented.   = = = =   [ERROR] The build could not read 8 projects -> [Help 1] org.apache.maven.project.ProjectBuildingException: Some problems were encountered while processing the POMs: [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 14, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 14, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15, column 11  [WARNING] 'build.plugins.plugin.version' for org.eclipse.tycho.extras:tycho-custom-bundle-plugin is missing. @ line 51, column 15
Spawned from bug 426540:  Complex example:  Arrays.asList((List<Integer>) null).stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)).remove(0);  Compiler says: "The method remove(int) is undefined for the type Object"  We find an inference solutions that seems to satisfy all constraints except the signature of Collections::unmodifiableList, which is    <T> List<T> unmodifiableList(List<? extends T> list)  This would be the only place that would connect the third and forth type variables of   <T,A,R,RR> collectingAndThen Without inspecing the signature of unmodifiableList, RR is completely unconstrained and thus inferred as Object.  Since I don't see any path how inference would be allowed to look at the signature of the reference expression, let's start with simpler examples:  interface I<X,Y> {     Y fun(X y); } public class Test {     static <S> S id(S s) { return s; }     void test() {         m1(Test::id, "Hi");                // (1)         m2(Test::id, "Hi").toUpperCase();  // (2)         m3(Test::id, "Hi").toUpperCase();  // (3)     }          <U,V> void m1(I<V,U> i, U u) { }     <U,V> V m2(I<V,U> i, U u) { return null; }     <U,V> V m3(I<U,V> i, U u) { return null; } }  The naive idea is: by passing Test::id for parameter I<V,U> one could equate U and V and with further equating U with String the results of methods m2 and m3 should be String, right?  Actual results: javac 1 error: - error at (2): cannot find symbol    symbol: method toUpperCase()    location: class Object  ecj-1.8-head 4 errors: (1) The type of id(Object) from the type Test is Object, this is incompatible with the descriptor's return type: String (2.a) The type of id(Object) from the type Test is Object, this is incompatible with the descriptor's return type: String (2.b) The method toUpperCase() is undefined for the type Object (3) The method toUpperCase() is undefined for the type Object  The difference between (2) and (3) looks funny.  Back to debugger & spec.
I'm using the BETA distribution from here, along with Eclipse Kepler 4.3.1: http://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_(BETA)  This program does not compile with Eclipse's Java 8 compiler:      import java.util.Arrays;     import java.util.function.Supplier;     import java.util.stream.Stream;               public class Test {         public static void main(String[] args) throws Exception {             // Type inference works on map call.             Stream<String> s1 =             Arrays.stream(new Integer[] { 1, 2 })                   .map(i -> i.toString());                          // Type inference doesn't work on map call.             Stream<String> s2 =             Arrays.stream(new Integer[] { 1, 2 })                   .map(i -> i.toString())                   .distinct();         }     }  It seems that the compiler cannot infer the generic method type <R> on Stream.map(), and infers Object instead of String. As a workaround I can write this:              Stream<String> s2 =             Arrays.stream(new Integer[] { 1, 2 })                   .<String>map(i -> i.toString())                   .distinct();  Another workaround is this:              Stream<String> s2 =             Arrays.stream(new Integer[] { 1, 2 })                   .map((Function<Integer, String>)(i -> i.toString()))                   .distinct();  Which is similar to the problem described here (which works as expected in my environment, though): https://bugs.eclipse.org/bugs/show_bug.cgi?id=425460  The original program compiles with javac using build jdk-8-ea-bin-b121-windows-x64-20_dec_2013
Follow up of https://bugs.eclipse.org/bugs/show_bug.cgi?id=426534:  I see another problem with vararg accessibility: I'll shortly release a regression test showing the problem.
"// --  interface BinaryOperation<T> {     T operate(T x, T y); }  class StringCatenation implements BinaryOperation<String> {      public String operate(String x, String y) { return x + y; } } public class X {     public static void main(String argv[]) {     	foo(false ? (a,b)->a+b :new StringCatenation());     }     static void foo(BinaryOperation<Integer> x) {        x.operate(5, 15);     } }  results in CCE from the generated code.  JDK 8b123 rejects this code correctly:  X.java:10: error: incompatible types: bad type in conditional expression         foo(false ? (a,b)->a+b :new StringCatenation());                                 ^     StringCatenation cannot be converted to BinaryOperation<Integer>"
Created attachment 239368 [details] Patch for testcase  As the attached test cases (in the form of unit tests) demonstrate, the .class files created by the annotation processor doesn't invoke the processor for another round of processing. Here is what the processor is trying to do:  1. Create a .class file for a package-info with an annotation, such as the following:    PackageAnnot package targets.filer8;   @interface PackageAnnot {}  2. The processor is tracking down the no of rounds and during the first round, copies the .class file's contents from the class loader and writes it using Filer.createClassFile() interface. This is expected (?) to call the annotation processor once again but not. This does happen with Javac, however.  Another but different issue is the behavior is different in the two test processor that are part of the patch. While Java8FilerProcessor#process() doesn't get the second call, Java8ElementProcessor#process() does get the second call, albeit with no package element as part of root elements. Javac also exibits different behavior across these two processors.  The patch probably contains other unnecessary things, but what is significant is in Java8ElementProcessor and those inside targets.filer8.
This code gets rejected by ECJ:  interface I {} class C1 implements I {} class C2 implements I {} public class X  {     <T > void foo(T p1, I p2) {}     <T extends I> void foo(T p1, I p2) {}     void bar() {         foo(true ? new C1(): new C2(), false ? new C2(): new C1()); // Rejected         foo(new C1(), false ? new C2(): new C1()); // Rejected too     } }  Note that both C1 and C2 (which are part of the conditional expression) are types of I, which means we can pick a valid method in both cases.
While converting code to Java 8 (with the new Java 8 compiler) I get this severe error:  Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:450)  I can locate it to this statement:      Collections.sort( result,                        Comparator.comparingInt( (CourseProviderEmploymentStatistics stat) ->  stat.doneTrainingsTotal ).reversed()                                 .thenComparing( (CourseProviderEmploymentStatistics stat) -> stat.courseProviderName ) );
Since BETA_JAVA8 was upgraded to 1.6 compliance, we can now use generics. The new inference engine was already designed with generics in mind, this should be materialized now.
I guess we need to implement this fairly recent clarification:  "New text for 15.12.2.6:  If the chosen method is the getClass method of the class Object (4.3.2), the method's invocation type is the same as the method's type, except that the return type is Class<? extends T>, where T is the type that was searched, as determined by 15.12.1."  See https://bugs.openjdk.java.net/browse/JDK-8029568
Currently the o.e.jdt feature version is "3.9.0.qualifier" in beta branch.   In R4_3_maintenance, it was recently incremented to 3.9.1.qualifier.  in master (Luna) version it is 3.10.0.qualifier.   I suggest that the version in beta branch be 3.9.51.qualifier.   This allows 50 "point releases" of 3.9.1 "pure Kepler SR2" before any risk of getting "larger than" the beta_java8 version. I think it is semantically clearer if we make the service field "distinct" from what is in "Kepler SR2".   (Ultimately it may not matter, if/when we produce pure "patch features", but ... if/while we want to "build everything" in beta branch, it make it much clearer, semantically, plus avoid the comparator "swapping in" some matching version from "pure kepler SR2" release. I think that is happening at this moment, so we need to "touch" the feature in some way ... just as well increment service field.
"package test.pack1;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface TypeUse { }  @T| interface I { 	default @T| void foo() { } } -----------------------------------------------  In the above example, replace '|' with the caret at both the locations and press Ctrl+space.  At 1st location (before interface), @TypeUse is not suggested, though it is valid there. At 2nd location (before 'void'), @TypeUse is suggested, and selecting that results in compilation error."
"package test;  import java.io.IOException; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class Snippet { 	void f1(int a) throws @Marker IOException, @Marker SecurityException { 	}  	void foo() { 		try { 			f1(0); 		} catch (@Marker SecurityException ex) { 		} 	} }  @Target(ElementType.TYPE_USE) @interface Marker { } ---------------------------------------------------  Hover over the error in abpve example at ""f1(0)"" and select the following quick fixes:  - ""Add throws declaration"", results in: 	void foo() throws IOException { 		try { 			f1(0); 		} catch (@Marker SecurityException ex) { 		} 	}  - ""Surround with try/catch"", results in: 	void foo() { 		try { 			try { 				f1(0); 			} catch (IOException e) { 				// TODO Auto-generated catch block 				e.printStackTrace(); 			} 		} catch (@Marker SecurityException ex) { 		} 	}   The type use annotation on IOException is not added in the above quick fix results, whereas it is added in case of ""Add catch cause to surrounding try"" and ""Add exception to existing catch clause"" quick fixes."
In bug 426861 we used a "trick" to override the BREE setting in the manifest.mf, since JavaSE-1.8 does not yet work (See 426692). Once that bug 426692 is fixed (and in a version or snapshot of Tycho we can use) we need to remember to go back and revert the change in bug 426861 ... which is in pom.xml of the o.e.j.annotation version 2.0.0 bundle. Basically to remove the whole <build> element in that pom.   Just a wild guess, I'm expecting this would be in about March that the changes needed would be available to us to use in our builds.
"From bug 422029 comment #17:  ""public interface A { 	default int getOne() { 		return 1; 	} }  public interface B { 	default int getOne() { 		return 2; 	} }  public class Impl implements A, B { 	public int getOne() { 		return B.super.getOne(); //bp here and inspect B.super.getOne() 	} 	public static void main(String[] args) { 		Impl i = new Impl(); 		System.out.println(i.getOne()); 	} }  Put a breakpoint where indicated and select + inspect ""B.super.getOne()"" - the resulting popup has the error about not being able to find the declaring type for the method.""  As Jesper found this is currently not supported by the JDK: https://bugs.openjdk.java.net/browse/JDK-8031195  Once JDWP has support for this it will be listed here (under the 'Enhancements ' section) http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/"
Created attachment 239440 [details] add another "module to build".  One local change I'd made, but forgot to carry forward, was to add  org.eclipse.jdt.annotation_v1 to the "root pom", in the list of modules.
"Consider the code snippet: import org.eclipse.jdt.annotation.NonNull; public class Square implements Shape {  	public Integer getArea(@NonNull Integer length) { 		return new Integer(length * length); 	} }  Refactor ""Pull Up"" the method to ""Shape"", the resulting file does not contain the import declaration for @NonNull and hence the user ends up with compilation errors."
"This code is rejected, while Javac allows:  public class X { 	interface I<U extends List<X>, V> { 		V foo(U p); 	} 	public void main() { 		I<List<X>, Object> fi = p -> p.toArray(new X[] {}); 	} }  This appears to be a recent regression."
"package com.test.todo;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class Test { 	static void m() { 		 	} 	new Runnable() { 		public void run(|) { 			 		} 	}; }  @Target(ElementType.TYPE_USE) @interface TU { } ------------------------------------------------  In the above example, type ""R"" in the parenthesis of ""run()"" in place of '|'. We get the following exception:  java.lang.ClassCastException: org.eclipse.jdt.core.dom.AnnotationTypeDeclaration cannot be cast to org.eclipse.jdt.core.dom.TypeDeclaration 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2729) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:637) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:199) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1373) 	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:274) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) ..."
Bug 420525 masked a problem in GenericsRegressionTest_1_8.testBug424710() so that fixing bug 420525 will create a regression in this test, saying:  Type mismatch: cannot convert from Stream<capture#8-of ? extends Object> to Stream<? extends capture#4-of ? extends Object>  I don't really know what "? extends capture#4-of ? extends Object" means and if we can avoid such beasts.  When releasing the fix for bug 420525 I will disable this test for now.
Type inference relies on a new method Expression.unresolve() which is probably unsafe, and not tested for completeness of various AST kinds. In bug 424930 I'm even adding one more call to this method (in AllocationExpression, in analogy to MessageSend).  On the long run we should either find a way to avoid using this method, or find a way of convincing ourselves that this approach is / can be made safe.
"This seems like a very recent regression. This code no longer compiles:  		public class Snippet { 			static void call(Class type, long init) { 				String string = new String(); 				method(type, init == 0 ? new String() : string); 			} 			private static void method(Class type, String s) {} 		}  The error is: The method method(java.lang.Class, java.lang.String) in the type Snippet is not applicable for the arguments (java.lang.Class, java.lang.String)  The code is narrowed down from JNA source code project that has been sitting open in my workspace for some time. Originally the two methods were named the same, but this was required to cause the error. The cause might be the fix to bug 426764 in which case feel free to mark as duplicate."
Type inference has been implemented per bug 400874 and bug 424053.  With those bugs closed or about to be closed, I'm creating this as the new home for any polish items regarding type inference.
Created attachment 239499 [details] Test Result  27 tests are failing in NullAnnotationsQuickFixTest when executed in BETA_JAVA8 branch , the same testcases pass in master branch.
We don't compile this code anymore:  // -- interface I {     Object m(X t); } interface J extends I { } class X {     int foo()  { return 0; }     int test() {         return foo(X::foo);     }     int foo(I i) {return 0;}     int foo(J j) { return 1;} }
"Created attachment 239501 [details] BP in interface methods  interface I2 { 	default int m1() { 		int a = 1; 		return a + 2; 	} 	static void m2() { 		System.out.println(""hi""); 	} } --------------------------------------------- Try to add a breakpoint within the default/static method above. We get the message as shown in the screenshot and the breakpoint is not added."
"Created attachment 239502 [details] Error on inspecting within interface methods  package p1;  public class C2 { 	@SuppressWarnings(""unused"") 	public static void main(String[] args) { 		I2 i2 = (I2) () -> {}; 		int i = i2.m1(); // [1] 		int j = I2.m2(); // [2] 	} }  interface I2 { 	default int m1() { 		int a = 1; 		return a + 2; 	} 	static int m2() { 		int a = 1; 		return a + 2; 	} 	void foo(); } --------------------------------------------------  Set the breakpoints at line [1] and [2]. While debugging, step into (F5) the methods #m1 and #m2. We get exception in the Error log which is given below. Also, try to Inspect(Ctrl+Shift+I) the expr ""a + 2"" in the methods, we get the error dialog as shown in the screenshot.  Exception: Internal error logged from JDI Debug:  org.eclipse.debug.core.DebugException: Unable to evaluate expressions in the context of an interface 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.checkInterface(ASTEvaluationEngine.java:199) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.evaluate(ASTEvaluationEngine.java:133) 	at org.eclipse.jdt.internal.debug.ui.JavaWatchExpressionDelegate$EvaluationRunnable.run(JavaWatchExpressionDelegate.java:142) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Created attachment 239503 [details] Screenshot  package p1;  public class C3 { 	public static void main(String[] args) { 		I3 i3a= m1(); 		System.out.println(i3a.foo(2)); 	}  	private static I3 m1() { 		I3 i3a= i -> { 			int x= 100; 			return i+x; 		}; 		return i3a; 	} }  interface I3 { 	int foo(int i); } --------------------------------------------------------  Set the breakpoint at line ""return i+x;"" in lambda expression. While debugging, hover over ""i"" or ""x"" in the lambda expression. We do not see the variable's value on hover (we can see the values on hover when the lambda expr is converted to an anonymous class)."
"package p1;  @SuppressWarnings(""unused"") public class C4 { 	public static void main(String[] args) { 		I4 i4e= null; 		System.out.println(i4e); 	}  	private static int test(int x) { 		return x + 20; 	} }  @FunctionalInterface interface I4 { 	int foo(int x); }  class I4Impl implements I4 { 	@Override 	public int foo(int x) { 		return x + 10; 	} } ----------------------------------------------------------  - Set the breakpoint at System.out.println line in #main. - While debugging (at the above line), go to the Variables view, right-click on 'i4e' and select ""Change Value..."". - In the Change Object Value dialog, enter the following expressions one-by-one and see the result as mentioned below:  1. new I4Impl() => 'i4e' value is updated.  2. new I4() { 	@Override 	public int foo(int x) { 		return x + 30; 	}     }; => we get the error ""Anonymous type declaration cannot be used in an evaluation expression"".  3. x -> 10 4. C4::test => we get the error ""The target type of this expression must be a functional interface"" for 3 and 4. Why so?  5. (I4) x -> 10 6. (I4) C4::test => No error and the value of 'i4e' is changed to 'null', which is not correct."
"Brought from bug 426515, comment #15  The following files should be in their own files:  I1.java public interface I1 { 	public String bar2( String s, @Marker List l1, List<String> l2); }  ------------- A.java  public class A implements I1 {  	@Override 	public String bar2(String s, @Marker List l1, List<String> l2) { 		return null; 	} }  Doing a clean build, you can notice there's no error. But when you touch A.java in the editor, the reconciler reports an error."
"Created attachment 239523 [details] Screenshot on clicking 'Open Actual Type Hierarchy'  package p1;  public class C6 { 	 	@SuppressWarnings(""unused"") 	public static void main(String[] args) { 		I6 i6a = s -> -1; 		I6 i6b = C6::test; 		System.out.println(); 	} 	 	static int test(String s) { 		return -1; 	} }  @FunctionalInterface interface I6 { 	int foo(String s); } -------------------------------------------------  - Set the breakpoint at System.out.println(); line. - While debugging (at the above line), open Variables view. - Right-click on 'i6a' or 'i6b'. - Select 'Open Actual Type' - Nothing is highlighted. - Select 'Open Actual Type Hierarchy' - We get the error message as shown in attached screenshot."
"import java.util.ArrayList; import java.util.List;  public class X { 	public static void bar() { 		List<Integer> l = new ArrayList<Integer>(); 		l.forEach(s -> System.out.println(s)); /* replace lambda with null and the following works*/ 		l./* Press Ctrl-space before this comment */ 	} 	public static void main(String[] args) { 		bar(); 	} }"
For IProblem ids *NotBelow18 in org.eclipse.jdt.core.compiler.IProblem, a new quick fix can be supported to change the project setup to 1.8.  It would also be useful for experimental checks in test workspace where back and forth switching between 1.7 and 1.8 is required.
"In a 1.8 project with null type annotations enabled, this snippet:  	void consume(@NonNull String @Nullable... strings) { 	}  triggers this error:  Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location.  This is wrong, one annotation affects the array the other its contents.  Using same annotations, each one has the desired effect on null analysis. Apparently only the check for contradictions (partially) sees the first annotation as a declaration annotation (and thus affecting the entire type, i.e., the array)."
"This nonsense code (note the syntax error):  import java.util.*;  @FunctionalInterface interface FInter { 	String allToString(List<String> input); }  public abstract class NNLambda { 	abstract <INP> void printem(FInter conv, INP single); 	 	void test() { 		printem((i) -> { 				Collections.<String>singletonList(""const"") // missing ';' 			},  			""single""); 	} }  triggers this NPE:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:71) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:642) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:450) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:502) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5039) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1261) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1731) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1626) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2571) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:861) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:694) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571)"
In https://bugs.openjdk.java.net/browse/JDK-8033407 it has been acknowledged that my 'correction' regarding reduction of ⟨null <: α⟩ is correct.  What I failed to see is that also ⟨α <: null⟩ is affected by the same spec bug.
"this code:  interface Producer<T> { 	<P> P produce(); } public class X { 	<T> void perform(Producer<T> r) { } 	void test() { 		perform(() -> 13);  	} }  throws this NPE: Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(ConstraintTypeFormula.java:198) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:642) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:658) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:759) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:744) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:115) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:729) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:685) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1725) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1626) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2571) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:861) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:694) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571)"
"I was playing with a lambda with a simple expression, and then I wanted to add slightly more logic which required me to use a block instead of the expression.  Wouldn't it be cool if JDT/UI offered a quick assist     ""Convert body expression to block""? :)  To convert this:  	void assistDemo(boolean flag) { 		perform(() -> 13);  	}  into this:  	void assistDemo(boolean flag) { 		perform(() -> { 			return 13; 		});  	}   (And perhaps the inverse, too, if possible)."
Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140201-0104_BETA_JAVA8  ----------  import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.function.Function;  public class MainTest {     public static <T> List<T> copyOf (Collection<T> c) {         return new ArrayList<>(c);     }          public static <T> List<T> copyOf (Iterable<T> c) {         return new ArrayList<>();     }          public static void main (String[] args) {         Function<Collection<String>, List<String>> function1 = c -> MainTest.copyOf(c); //OK         Function<Collection<String>, List<String>> function2 = MainTest::copyOf;        //error     } }  ----------  This code was working in the JDT patch from a few days ago, but when I updated today, it's not working. For the method reference assigned to function2, Eclipse gives the following error: "The type MainTest does not define copyOf(Collection<String>) that is applicable here". However, the equivalent lambda expression for function1 is OK.  If I remove the copyOf(Iterable) method, or remove the generic <T> and use <String>, it compiles fine. Also, the same error appears regardless of whether the methods are static or not.
The new type java.util.stream.Stream extends AutoCloseable, although in many cases these do not hold a reference to any resource that would *require* closing.  To avoid uninteresting warnings, our leak analysis should generally white list Stream (no warnings if not closed), and add special treatment for API which are known to produce a Stream that indeed holds GC resistant resources, in particular: all static methods in java.nio.file.Files that return a java.util.stream.Stream.
"This program crashes at runtime when compiling and running it from within eclipse. Compiling and running it with jdk8 b127 from the command line works fine.  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - package crash;  import java.util.function.Function;  class Crash { 	 	public static void main(String[] args) { 		test(1, Crash::intToSome); 	}  	static <T> Some test(T value, Function<T, Some> f) { 		return (value == null) ? new Nothing() : f.apply(value); 	}  	static SomeInt intToSome(int i) { 		return new SomeInt(); 	} 	 	static abstract class Some {} 	static class SomeInt extends Some {} 	static class Nothing extends Some {} 	 	// NOTE: on the other hand this works fine: 	//static interface Some {} 	//static class SomeInt implements Some {} 	//static class Nothing implements Some {} 	 } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  Exception in thread ""main"" java.lang.VerifyError: Instruction type does not match stack map Exception Details:   Location:     crash/Crash.test(Ljava/lang/Object;Ljava/util/function/Function;)Lcrash/Crash$Some; @21: areturn   Reason:     Type 'java/lang/Object' (current frame, stack[0]) is not assignable to 'crash/Crash$Some' (stack map, stack[0])   Current Frame:     bci: @21     flags: { }     locals: { 'java/lang/Object', 'java/util/function/Function' }     stack: { 'java/lang/Object' }   Stackmap Frame:     bci: @21     flags: { }     locals: { 'java/lang/Object', 'java/util/function/Function' }     stack: { 'crash/Crash$Some' }   Bytecode:     0000000: 2ac7 000d bb00 2259 b700 24a7 000a 2b2a     0000010: b900 2502 00b0                            Stackmap Table:     same_frame(@14)     same_locals_1_stack_item_frame(@21,Object[#50])  	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688) 	at java.lang.Class.getMethod0(Class.java:2937) 	at java.lang.Class.getMethod(Class.java:1771) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)"
See https://bugs.eclipse.org/bugs/show_bug.cgi?id=427207#c8 for a snippet and crash info.
"EJC does not like the line mentioned below, jdk8 b127 does compile it.  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - public class Test {  	List<Object> toList(Object o) { 		if (o instanceof Optional) { 			// DOES NOT COMPILE 			return Arrays.asList(((Optional<?>) o).orElse(null)); 		} else { 			return null; 		} 	}	  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  Errors occurred during the build. Errors running builder 'Java Builder' on project 'xxx'. java.lang.NullPointerException   WORKAROUND: Casting  	return Arrays.asList( (Object) ((Optional<?>) o).orElse(null) );"
"From bug 424591 comment 32:  public class Test2 {     public static native <T> T applyToSet(java.util.Set<String> s);      public static void applyToList(java.util.List<String> s) {         applyToSet(new java.util.HashSet<>(s));     } }  $ /usr/lib/jvm/jdk1.8.0/bin/javac Test2.java $ java -jar org.eclipse.jdt.core_3.9.2.v20140202-0105_BETA_JAVA8.jar -1.8 Test2.java ---------- 1. ERROR in /home/dsimon/Test2.java (at line 13) 	applyToSet(new HashSet<>(s)); 	^^^^^^^^^^ The method applyToSet(Set<String>) in the type Test2 is not applicable for the arguments (new HashSet<>(s)) ---------- 1 problem (1 error) $  Removing the (unused) ""<T>"" from applyToSet makes the problem go away."
Due to the changes in jdt/core as per Bug 426462
Ref bug 426510 comment 0 To quote: "...We should remove the old org.eclipse.jdt.internal.corext.dom.ASTNodeFactory#newAnnotation(..) and turn ImportRewrite#newAnnotation(..) .."
"Using this test code:  package shortcutter; public class ShellLink {   public final String targetApplication;   public final String arguments;   public final String appUserModelID;   public ShellLink() {} }  Steps: 1. Click in the name of the constructor with red error marker to place caret there. 2. Press Ctrl-Space to invoke code assist. 3. The UI becomes unresponsive in about 1 second.  Tested in Eclipse SDK 4.3.1 with the latest BETA_JAVA8 plugins. This doesn't reproduce in Eclipse SDK 4.4M5.  Stack trace of the hanging main thread:   java.lang.Thread.State: RUNNABLE 	at org.eclipse.jdt.internal.compiler.parser.Parser.automatonWillShift(Parser.java:12441) 	at org.eclipse.jdt.internal.compiler.parser.Parser.atConflictScenario(Parser.java:10817) 	at org.eclipse.jdt.internal.compiler.parser.Scanner.maybeAtLambdaOrCast(Scanner.java:4407) 	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:4480) 	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1161) 	at org.eclipse.jdt.internal.compiler.parser.Parser.moveRecoveryCheckpoint(Parser.java:10638) 	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.resumeAfterRecovery(AssistParser.java:1842) 	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.resumeAfterRecovery(CompletionParser.java:5087) 	at org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError(Parser.java:12247) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:10868) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11210) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11167) 	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9610) 	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.dietParse(CompletionParser.java:4543) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1810) 	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:358) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:346) 	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244) 	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:206) 	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63) 	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333) 	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337) 	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:325) 	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:282) 	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1839) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:566) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:563) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:498) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:492) 	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1665) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:183) 	at org.eclipse.ui.texteditor.ContentAssistAction$1.run(ContentAssistAction.java:82) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.texteditor.ContentAssistAction.run(ContentAssistAction.java:80) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
Following doesn't compile:  List<PriceOption> availableOptions = new ArrayList<>();  availableOptions.stream()                         .map(p -> new Object() { })                         .collect(toList());  I suspect type inference doesn't work well with anonymous classes.
"Hello,  I have some compilation problems while trying Java 8 with eclipse 4.3.1 Using Java jdk 8 fcs b127 both on 32 and 64 bits and   Eclipse Java Development Tools Patch for Java 8 Support (BETA)	        1.0.0.v20140203-0104_BETA_JAVA8	org.eclipse.jdt.java8patch.feature.group	Eclipse.org   Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140203-0104_BETA_JAVA8	org.eclipse.pde.java8patch.feature.group	Eclipse.org   Eclipse RCP Patch for Java 8 Support (BETA)	                                1.0.0.v20140203-0104_BETA_JAVA8	org.eclipse.rcp.java8patch.feature.group	Eclipse.org   sscce :  import java.util.Collection;  public class A  { 	public A(String... a) 	{ 	} 	public static <T> T[] a(T[] a, T[] b) 	{ 		return null; 	} 	 	public static void error() 	{ 		final Collection<A> as = null;                 for (A a : as)                 {                 	new A(A.a(                          new String[0],                          new String[0]));                 } 	} }  Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". Error in JDT Core during AST creation    Internal compiler error: java.lang.ArrayIndexOutOfBoundsException: -1 	at org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:6209) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:4254) 	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1382) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:341) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Noopur asked a good question I couldn't answer:  org.eclipse.jdt.core.dom.ITypeBinding.getEnclosingType() : How is it different from ITypeBinding.getDeclaringClass()?  The API got added in http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=0eef8a719c726a9948e73db62c7f81adbce0f319
Question from Noopur: How to differentiate between a type use annotation and a constructor annotation on a constructor. We get both via IBinding.getAnnotations(). - Probably a bug?  I would also expect @A to be treated as a type annotation in the snippet below. Java 8 reflection seems to agree with that viewpoint.   package jsr308.bug.ctor;  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @interface A {}  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @interface B {}  @Target(ElementType.CONSTRUCTOR) @Retention(RetentionPolicy.RUNTIME) @interface C {}  public class Test<E> {     @C     public @A <T> Test() { // @A should be type annotation on constructor binding         new @B() Test();     }          public static void main(String[] args) throws Exception {         Annotation[] declAnnos = Test.class.getDeclaredConstructors()[0].getAnnotations();         System.out.println(java.util.Arrays.asList(declAnnos));                  Annotation[] typeAnnos = Test.class.getDeclaredConstructors()[0].getAnnotatedReturnType().getAnnotations();         System.out.println(java.util.Arrays.asList(typeAnnos));     } }
"Start with the valid and working program below, computing a factorial: ------------------------------------------------ package java8.test;  public class Main { 	 	interface Duo { 		int apply(int n, Duo g); 	} 	  	public static void main(String[] args) { 		Duo f = (n, g) -> n > 0 ? n * g.apply(n - 1, g) : 1;   		System.out.println(f.apply(5, f)); 	} } ------------------------------------------------  then change the line declaring the ""Duo f"" variable as such: ------------------------------------------------ 		Duo f = (n, g) -> n > 0 ? n * g.apply(n - 1, g) : 1, f. ------------------------------------------------  After the ""."" is entered after ""f"", Eclipse hangs and must be killed."
Since the fix for bug 426515 did not resolve the issue reported in bug 426515, comment #1, I am raising a new bug to track it.  package pack1;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target({ ElementType.TYPE_USE }) public @interface ReadOnly {  } package pack1;  import java.util.List;  public interface I1 { public @ReadOnly String bar2(@ReadOnly String s, @ReadOnly List<@ReadOnly String> l2); } package pack1;  import java.util.List;  public class AImpl implements I1, InnerA {}//Invoke the quick fix to Add Unimplemented methods  interface InnerA{ public @ReadOnly String bar1(@ReadOnly String s, @ReadOnly List<@ReadOnly String> l2); }  Inspect the IMethodBinding corresponding to InnerA#bar1(). binding.getParameterTypes()[0].getTypeAnnotations() returns the AnnotationBinding corresponding to @ReadOnly()  Now inspect the IMethodBinding corresponding to I1#bar2(). binding.getParameterTypes()[0].getTypeAnnotations() returns empty AnnotationBinding. Now inspect with the same binding binding.getParameterAnnotations(0), this returns the AnnotationBinding corresponding to @ReadOnly(), which seems wrong as the Javadoc for getParameterAnnotations() says that this is supposed to return the declaration annotation and not the type annotation.
"abstract class Test2 { 	abstract void m0(Test2 this, int i); 	 	void m1(int i, Test2 this) { } 	static void m2(Test2 this, int i) { } 	 	Function<String, String> f1= (String s, Function this) -> s; 	Function<String, String> f2= (Function this, String s) -> s; }  Here, 'this' parameter info is present as given below: - In #m0: present in RECEIVER_TYPE_PROPERTY, not present in parameters list. - In #m1: not present in RECEIVER_TYPE_PROPERTY, present in parameters list. - In #m2: not present in RECEIVER_TYPE_PROPERTY, not present in parameters list. - In f1 and f2: present in parameters list of LambdaExpression.  Cases for #m0 and f1/f2 are fine. Case for #m1 also seems Ok? In case of #m2, 'this' parameter info is not present anywhere in the AST, which is wrong.  When 'this' parameter is added at an incorrect location, it should be present at a consistent place somewhere in the AST."
"From bug 425040 comment #1:  Consider the following example: -------------------------------------------- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class X { }  @Target(ElementType.TYPE_USE) @interface Ann1 { }  class A { 	public void foo(X x, @Ann1 X arg) { } } -------------------------------------------- Move method #foo to X by choosing 'X x' as the receiver. It results in inserting a new line after annotation on the parameter as shown below: -------------------------------------------- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class X {  	public void foo(@Ann1 	X arg) { } }  @Target(ElementType.TYPE_USE) @interface Ann1 { }  class A { } -------------------------------------------- It happens as the parameter (@Ann1 X arg) is considered as a SingleVariableDeclaration during AST rewrite and the formatter option ""Insert new line after annotations on local variables"" is enabled."
"The produced classfile for this CU is problematic:   package bug.imports.test;  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @interface Ann {     Thread.State value() default Thread.State.NEW;     int value2() default 1; }  public class BadClassfile {     public void foo003(             @Ann(value = XXThread.State.BLOCKED, value2 = 42) Object o             ) {} }   The search index says:  !MESSAGE The Java indexing could not index /zz1.8/bin/bug/imports/test/BadClassfile.class. This .class file doesn't follow the class file format specification. Please report this issue against the .class file vendor  When I locate the BadClassfile.class file in the Navigator view and then try to open it, the disassembler fails here:  java.lang.ArrayIndexOutOfBoundsException: 659 	at org.eclipse.jdt.internal.core.util.ClassFileStruct.u1At(ClassFileStruct.java:52) 	at org.eclipse.jdt.internal.core.util.ExtendedAnnotation.<init>(ExtendedAnnotation.java:112) 	at org.eclipse.jdt.internal.core.util.RuntimeInvisibleTypeAnnotationsAttribute.<init>(RuntimeInvisibleTypeAnnotationsAttribute.java:55) 	at org.eclipse.jdt.internal.core.util.MethodInfo.<init>(MethodInfo.java:128) 	at org.eclipse.jdt.internal.core.util.ClassFileReader.<init>(ClassFileReader.java:238) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:261) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.updateCodeView(ClassFileEditor.java:410) ..."
+++ This bug was initially created as a clone of Bug #427371 +++  I still see this in a few places. This is an old "update manager" image that has not been used since p2 was introduced.   Besides removing the image, the file name should be removed from bu
At commit 055cf2299e246e07310e3c00069174f749475bd4 the tests TypeBindingTests308.testAnnotatedBinaryType* are failing in my workspace.  Is that some work-in-progress?
"Created attachment 239632 [details] Self-contained program to reproduce the error  Originally posted here: https://bugs.eclipse.org/bugs/show_bug.cgi?id=426984 I use the latest Java8 JDT (Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140204-0108_BETA_JAVA8) and Hamcrest matchers 1.3 (verifyThat) and JavaFX (ObservableList).  The original problem is from a hamcrest matcher call that looks like this: assertThat(list, not(hasItem(x)));  Please see the attached example that contains a more general way to reproduce this bug: GenericClass<Iterable<? super Object>> tempVariable = genericClassTransformer(genericClassFactory(o));  leads to: Type mismatch: cannot convert from GenericsBug.GenericClass<Iterable<? super Object>> to GenericsBug.GenericClass<Iterable<? super Object>>"
"Hello, I have an NPE while compiling this piece of code:  public class B { 	 	public void testError() 	{ 		assertEquals(A.e(null,null,null),null); 	} 	 	public static boolean assertEquals(String a, String b) 	{ 		return false; 	} 	 	public static boolean assertEquals(Object a, Object b) 	{ 		return false; 	} }  public class A  { 	public static <T, V> V e(T[] t, V[] v, T object) 	{ 		return null; 	} }   A and B are two classes within two different files. Should it be considered as a bug ? I understand that the compiler is not able to choose between the two equals methods.  I am using :    Eclipse Java Development Tools Patch for Java 8 Support (BETA)		1.0.0.v20140205-0104_BETA_JAVA8   Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140205-0104_BETA_JAVA8   Eclipse RCP Patch for Java 8 Support (BETA)					1.0.0.v20140205-0104_BETA_JAVA8  This is the stack:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4755) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4724) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4657) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.mostSpecificMethodBinding(Scope.java:4337) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1895) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1627) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2572) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:861) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:694) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Hello, I have an NPE while compiling this code :  public class C { 	 	public C(Class clazz) 	{ 		  	} 	 	public void error() 	{ 		boolean test = false; 		int i = 1; 		 		new C( 		test 		? (i == 2 		   ? D.class 	       : E.class) 	    : null); 	} 	 	 	public class D{} 	public class E{} 	 }    I am using :    Eclipse Java Development Tools Patch for Java 8 Support (BETA)		1.0.0.v20140205-0104_BETA_JAVA8   Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140205-0104_BETA_JAVA8   Eclipse RCP Patch for Java 8 Support (BETA)					1.0.0.v20140205-0104_BETA_JAVA8    This is the stack :  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:272) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:265) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.generateCode(AllocationExpression.java:210) 	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:698) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:328) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"@FunctionalInterface interface FI1 { 	int foo(int x) throws Exception; } class Test { 	FI1 fi1= (int x) -> { 		throw new Ex| 	}; 	private void test() throws Exception { 		throw new Ex| 	} } -----------------------------------------------------------------"
"@FunctionalInterface interface FI1 { 	int foo(int x) throws Exception; }  class Test { 	private void foo() { 		FI1 fi1 = (x) -> {  			@| 		}; 	} } ---------------------------------------------------------  In the above example, replace '|' with caret and "
Created attachment 239658 [details] noJREonClasspath.zip  The Eclipse compiler can't resolve java.lang.annotation.Annotation from source any more.  Since bug 419331, I get a compile error "The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files" when I try to compile the attached project. When I revert the change for that bug, then the Annotation type is found, and I get better (expected/solvable) problems. (The given project is very incomplete but shows the issue).  Background: I'm trying to regenerate rtstubs18.jar for the JDT/UI tests, so that it includes the APIs from latest JREs. We need this e.g. for the test case in bug 425183 comment 10.  ECJ should generally be able to compile a complete rt.jar from source.
When trying to compile rt.jar of Java 8 with ecj, I'm getting a compile error in java.util.Spliterators.AbstractDoubleSpliterator. I've extracted the problem into a self-contained example below.  I think the compile error is wrong because interface OfDouble already overrides the method Spliterator#forEachRemaining(Consumer<? super T>) with a concrete variant OfDouble#forEachRemaining(Consumer<? super Double>), so the former method should not be considered any more when AbstractDoubleSpliterator is compiled.  ===================================================================== package split2;  import java.util.function.Consumer; import java.util.function.DoubleConsumer;  public interface Spliterator<T> {          default void forEachRemaining(Consumer<? super T> action) {     }          public interface OfPrimitive<T, T_CONS, T_SPLITR extends OfPrimitive<T, T_CONS, T_SPLITR>>             extends Spliterator<T> {         // overloads Spliterator#forEachRemaining(Consumer<? super T>)         default void forEachRemaining(T_CONS action) {         }     }          public interface OfDouble extends OfPrimitive<Double, DoubleConsumer, OfDouble> {         @Override // the method from Spliterator         default void forEachRemaining(Consumer<? super Double> action) {         }                  @Override // the method from OfPrimitive         default void forEachRemaining(DoubleConsumer action) {         }     } }  class Spliterators {     /* Error on class: Duplicate default methods named forEachRemaining with      * the parameters (Consumer<? super Double>) and (Consumer<? super T>) are      * inherited from the types Spliterator.OfDouble and Spliterator<Double>      */     public abstract static class AbstractDoubleSpliterator implements Spliterator.OfDouble {          /* Implementation that prevents the compile error: */ //        @Override // the method from Spliterator //        public void forEachRemaining(Consumer<? super Double> action) { //        }     } } =====================================================================
Created attachment 239664 [details] Collecting a Map with lambdas resulting in a bug.  Overview: I get an error message after compiling a litte java 8 lambdas experiment.   Steps to reproduce: 1) Create new Java Projekt  2) Insert attached file in default package  Actual Results: I get the Error Message: > Internal compiler error: java.lang.UnsupportedOperationException: Breaking a dependency cycle NYI at   org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.missingImplementation(InferenceContext18.java:1449)   Expected Result: It shall compile without errors.  Build Date & Hardware: * I just downloaded a fresh Eclipse for Java Developers with Build id: 20130614-0229. * Windows 7   Additional Information: * The JDT has the version   1.0.0.v20140205-0104_BETA_JAVA8. * My workspace is as new as "new Date()". * I tested the file with a java 8 sdk version number 1.8.0-ea-b104. It compiled and gave output as expected.
With the most recent Java 8 support, Eclipse reports the error as given in the snippet:  new TreeSet<>((String qn1, String qn2) -> {    boolean b = true;    System.out.println(b); // ok    if(b) { } // Eclipse says: b cannot be resolved or is not a field    return qn1.compareTo(qn2); });
"Hi, EJC does not compile the following snippet:  public class Test {  	public static <T> Tree<T> model(T o) { 		return Node(Leaf(o), Leaf(o)); 	} 	 	interface Tree<T> {} 	static <T> Tree<T> Node(Tree<T>... children) { return null; } 	static <T> Tree<T> Leaf(T o) { return null; } 	 }  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.varArgTypes(InferenceContext18.java:1076) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC(InferenceContext18.java:454) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC_OneExpr(InferenceContext18.java:480) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC(InferenceContext18.java:462) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:396) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:516) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5047) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1262) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1732) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1627) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2572) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:861) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:694) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Spawned from https://bugs.eclipse.org/bugs/show_bug.cgi?id=427117#c3  Completion fails in before, after and inside a lambda in the presence of intersection casts:    // -- import java.io.Serializable;  interface I { 	void foo(); } public class X { 	I i = () -> { 		System.out.println(); 	}; 	 	public static void main(String[] args) { 		syso| 		I i = (I & Serializable) () -> { 			syso} 		}; 		syso| 	} }"
"// -- import java.io.Serializable; interface I { 	void foo(); } public class X { 	public static void main(String[] args) { 		I i = (I & Serializable) () -> {}; 	 	} }  Search for I using Java search + type references + cast locations.  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.IntersectionCastTypeReference incompatible with org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference 	at org.eclipse.jdt.internal.core.search.matching.TypeReferenceLocator.match(TypeReferenceLocator.java:99) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.consumeCastExpressionLL1WithBounds(MatchLocatorParser.java:227) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:7015) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:10965) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11314) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.parseBodies(MatchLocatorParser.java:834) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.parseBodies(MatchLocatorParser.java:808) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBodies(MatchLocator.java:889) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.parseAndBuildBindings(MatchLocator.java:1671) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1091) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1196) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1328) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:96) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Presently writing completion and selection tests from user provided problem snippets is a pain because these tests run against minimal version of libraries (JCLMIN) that don't even have java.lang.String in some incarnations of them.  For example given:  import java.util.List; import java.util.Map; import java.util.stream.Collectors;   public class Bug419048 { 	void test1(List<Person> roster) {         Map<String, Person> map =                  roster                     .stream()                     .collect(                         Collectors.toMap(                             p -> p.getLast(), //[1]                             p -> p            //[2]                         )); 	} }  one needs to transform all the symbols that originate from JRE into local types or otherwise rewrite the test into shape.  Historically the UI project has maintained their some of their tests against a stubbed version of JRE and recently Markus created the JDK8 version of it. See http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=BETA_JAVA8&id=4505fb3550ef580808061e75a5a925cfe9d3b9d2  We need CompletionTests18 and ResolveTests18 to similarly run against a version of library that has all the types in tact (but for method bodies which are stubbed out) to make it easy to write tests."
"spawned from bug 401848 comment 18 (Reproduced below).  bug 426868 comment #1 - the disabled test in the patch, is an example of the SE8 exclusive location where the issue occurs.  Example: ------------------------------------------------------------------- import java.io.FileNotFoundException; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  class E { 	void test(int a) { 		throw new @Marker FileNotFoundException(); 	} }  @Target(ElementType.TYPE_USE) @interface Marker { } ------------------------------------------------------------------- Apply the patch from bug 426868 comment #1 in JDT/UI and hover over the error in above example (at 'thorw'). Select ""Add throws declaration"" quick fix. The result is: ------------------------------------------------------------------- class E { 	void test(int a) throws @Marker 	FileNotFoundException { 		throw new @Marker FileNotFoundException(); 	} } -------------------------------------------------------------------  Here, the ""@Marker FileNotFoundException"" node to be added in 'throws' comes as a SimpleType with #annotations having '@Marker'.  Please check if the above issue will be resolved with this bug or bug 425040.  Refer to bug 401848 comment 19 as well."
"Hello, I had a new compilation issue will compiling this piece of code :  import java.util.Collection; import java.util.List;  public class G {  	public void error(Collection<Object> c) 	{ 		boolean b  =true; 		 		c.add(b ? new Integer(1) 		        : c==null ? null  				  : c instanceof List ? Integer.valueOf(1)  				                      : o());  	} 	 	public Object o() 	{ 		return null; 	} }   the stack Error in JDT Core during AST creation java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:265) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:426) 	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:699) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:328) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)   Good luck! Mathieu."
"(Occurs in the Early access release III for Java 8)  I got this in the Error Log while trying to submit another bug.  I was just typing the following:    new ArrayList<String>().toArray(  ...and I used Ctrl+Space to invoke code completion after the parenthesis.  Not always reproduceable.  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.computeBoxingType(LookupEnvironment.java:413) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:59) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:642) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:653)  (rest of stacktrace removed, repeats last line)"
"Hello, since today (1.0.0.v20140207-0104_BETA_JAVA8) I have and error with the following code :   public class H { 	 	public void error(I i) 	{ 		test(i!=null?i.getJ():null); 	} 	 	 	public void test(I i) 	{ 		 	} 	public void test(J j) 	{ 		 	} 	 	 	public class I{ 		public J getJ() 		{ 			return null; 		} 	} 	public class J{}  }  The error is : The method test(H.I) is ambiguous for the type H Is it not possible to guess that the result of the condition will be of the type J ? It was working well with earlier versions (like 1.0.0.v20140206-0106_BETA_JAVA8)"
"Select ""TYPE_USE"" and search for references in Workspace => stops with NPE.  ============================================================ package testing; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  class Y0 implements unresolved. @Marker1 Collection<Integer> { }  @Target (ElementType.TYPE_USE) @interface Marker1 {} ============================================================   !ENTRY org.eclipse.core.jobs 4 2 2014-02-07 16:21:02.575 !MESSAGE An internal error occurred during: ""Java Search"". !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2328) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2733) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2513) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1746) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1155) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1196) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1328) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:96) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
The method max(int, int) in the type Math is not applicable for the arguments (int, Integer)  Does not compile: Math.max(0, java.util.Collections.max(Collections.<Integer>emptySet()));  Compiles: Math.max(0, java.util.Collections.<Integer>max(Collections.<Integer>emptySet()));  1.0.0.v20140208-0104_BETA_JAVA8
This is the code, comes from trying to compile JDK source code:  class Test1<K, V> {   /**    * @param <K2> unused    * @param <V2> unused    */   private static class Node<K2, V2> {}      @SuppressWarnings("unused")   private KeySetView<K, V> keySet(V mappedValue) {return null;}      /**    * See {@link #keySet() keySet()},    * @param <K3> unused    * @param <V3> unused    */   private static class KeySetView<K3, V3> {}      private static <K4, V4> Node<K4, V4> untree0(Node<K4, V4> hi) {return hi;}   void untreesomething(Node<K, V> n) {     // The method untree0(Test1.Node<K4,V4>) in the type Test1<K,V> is not      // applicable for the arguments (Test1.Node<K,V>)     untree0(n);   }      private static <K4, V4> Node<K4, V4> tabAt0(Node<K4, V4>[] tab, int i) {return tab[i];}   void tabatsomething(Node<K, V>[] t) {     // The method tabAt0(Test2.Node<K4,V4>[], int) in the type Test2<K,V> is not      // applicable for the arguments (Test2.Node<K,V>[], int)     tabAt0(t, 0);   } }  I thought this might be the same as bug 427411 but the the javadoc snippet with @link is giving me pause, and so I think this might be different. Tested with the latest BETA_JAVA8 branch updated couple of minutes ago.
This is a regression since the fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=427628.  The following program does not compile any more:  // -- public class X {        public static void main(String argv[]) {         int i = ((I) (x) -> { return 999; }).foo(true ? 0 : (Comparable) null);         System.out.println(i);     }      interface I {         int foo (Comparable arg);          default int foo (Object arg) {              return 0;         }     } }
import java.lang.annotation.Annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.reflect.Method;  public class X extends Super {     public static void main(String[] args) {         try {             Method m = X.class.getMethod("setFoo", String.class);             Annotation a = m.getAnnotation(Anno.class);             System.out.println("Annotation was " + (a == null ? "not " : "") + "found");         } catch (Exception e) {             e.printStackTrace();         }     } }  class Super {     @Anno     public void setFoo(String foo) {} } @Retention(RetentionPolicy.RUNTIME) @interface Anno {}  MethodVerifyTest#208 On running the above, javac finds ("Annotation was found") the annotation while eclipse jdt does not. The behaviour was "Annotation not found" in 1.7 in javac as well. Looks like it was a bug that got fixed in javac. b126 in 1.7 mode also finds the annotations. - [May have to move out of 1.8 as well after analysis.]
Another weird sounding error from compiling JDK source, with this source code:  public class CannotConvertTest {   private static interface Action<T> {T run();}   private static Action<Boolean> baction;   static void getLog(int override) {}   static void getLog(boolean override) {}   private static <T> T doit(Action<T> action) {return null;}   static {     //Type mismatch: cannot convert from Boolean to boolean     getLog(doit(baction));   } }
"interface I {     void foo(X<String> y); } public class X<T> {     class Z<K> {         Z(X<String> y) {             System.out.println(""Y<T>.Z<K>:: new"");         }         public void bar() {             I i = Y<String>.Z<Integer>::<String> new;             i.foo(new Y<String>());         }     } 	public void foo() { 		Z<String> z = new Z<String>(null); 		z.bar(); 	} 	public static void main(String[] args) { 		Y<String> y = new Y<String>(); 		y.foo(); 	} }  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:345) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:248) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:618) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1312) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1110) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)"
Run SerializableLambdaTest#test001_simple  Compatibility fails - Issue: Helper.class to be created under util/ but created in the current directory and hence error "java.lang.NoClassDefFoundError: util/Helper" [stop in ART.execute() and check errorLogger() to find this issue]. Once this is fixed, failing tests of SLT have to be re-run.
This bug is to track our effort on testing our 1.8 compiler with the source code of 1.8 JDK. The primary goal is to cover as much variety of code s possible, since there's lot of generics and lambda related code as part of the JDK's source code.   From previous offline discussions, here are some ideas from Stephan:  1. Just extract the src.zip and use eclipse command line compiler. 2. Import the source as a project into eclipse and compile at 1.8 level.  The idea is to test the compiler against both 1.8 and non 1.8 code and raise defects and follow up.
"This code is rejected by ECJ, but allowed by Javac:  public class X extends Foo { 	public X(I i) { 		super(i != null ?  i.toString() : null);     } }  class Foo implements I { 	Foo(I i) {} 	Foo(String string){} } interface I {}"
"MirrorDeclarationTestAnnotationProcessor has the following code, which is causing problems:  ArrayList<AnnotationMirror> annotationMirrors = new ArrayList<AnnotationMirror>(); for (MethodDeclaration methodDeclaration : methodDecls) { 	Collection<AnnotationMirror> mirrors = methodDeclaration.getAnnotationMirrors(); 	annotationMirrors.addAll(mirrors); } ProcessorTestStatus.assertEquals(""Wrong size for annotation mirrors"", 3, annotationMirrors.size());  It appears that now AnnotationMirrorImpl (JLS5) has equals() that checks for equality of underlying dom binding. This check probably was returning false earlier but now returns true since we now reuse the same binding for annotations. The test code has three methods all annotated with the same annotation, which means we will only have one entry annotationMirrors in the end.  I think we only need to fix the test just to check that individual methods get their annotations."
"From building JDK source code comes this reduced test case which causes a flood of error log entries and an error message popup:  package npe.oejicl.TypeSystem.getUnannotatedType.line76;  /**  * @param <K> unused  * @param <V> unused  */ class Outer<K, V> {    void method() {     //Internal compiler error: java.lang.NullPointerException at     // org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76)     new Inner<>(null);   }    final class Inner<K2, V2> {     /**      * @param next unused       */     Inner(Inner<K2, V2> next) {}   } }  Tested with the latest BETA_JAVA8 plugins.  Here is the stack trace:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76) 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:146) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:123) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:946) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:507) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:493) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:614) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:439) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:4958) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:576) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:496) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:486) 	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1019) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:136) 	at org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement.resolve(SynchronizedStatement.java:198) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:618) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:921) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:966) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136) 	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) 	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
"This example compiles correctly with javac but ECJ gives 4 errors:  public class Excercise {   static <A, B> Stream<B> objmap(Function<A, B> p1, A[] p2) {return Stream.of(p2).map(p1);}   static <B> Stream<B> intmap(IntFunction<B> p1, int[] p2) {return IntStream.of(p2).mapToObj(p1);}    public static void main(String[] args) {     Integer[] p12 = {1, 2, 3};     int[] p22 = {1, 2, 3};     //works     String[] a11 = objmap(String::valueOf, p12).<String> toArray(String[]::new);     String[] a21 = intmap(String::valueOf, p22).<String> toArray(String[]::new);     //does not work     String[] a12 = objmap(String::valueOf, p12).toArray(String[]::new);     String[] a22 = intmap(String::valueOf, p22).toArray(String[]::new);   } }  The errors I get are: Description	Resource	Location	Path	Type The method toArray(IntFunction<A[]>) in the type Stream<String> is not applicable for the arguments (String[]::new)	Excercise.java	line 21	/EclipseBugsLive/src/homework	Java Problem Constructed array String[] cannot be assigned to A[] as required in the interface descriptor  	Excercise.java	line 21	/EclipseBugsLive/src/homework	Java Problem The method toArray(IntFunction<A[]>) in the type Stream<String> is not applicable for the arguments (String[]::new)	Excercise.java	line 20	/EclipseBugsLive/src/homework	Java Problem Constructed array String[] cannot be assigned to A[] as required in the interface descriptor  	Excercise.java	line 20	/EclipseBugsLive/src/homework	Java Problem"
"I am using Eclipse 4.4 with Java 8 support as follows:    Eclipse Java Development Tools Patch for Java 8 Support (BETA)    1.0.0.v20140206-0106_BETA_JAVA8	 The Eclipse download file was    eclipse-SDK-4.4M5-win32-x86_64-efx-1.0.0-SNAPSHOT.zip  Eclipse is reporting an error on the following code, but I don't get an error when I compile with the Java 8 JDK build 128 (jdk-8-fcs-bin-b128-windows-x64-01_feb_2014).  I am fairly confident that the error is in the Eclipse Java compiler.  The error is reported on line 19.  If I comment out line 19 and uncomment line 21, I do not get an error, but the Java 8 JDK compiler reports no errors either way.  ___________________________________________________________________   import java.util.Arrays;  public class TestComparators   {     public static void main(String[] args)       {         String[] words = {""java"", ""interface"", ""lambda"", ""expression"" };          Arrays.sort(words, (String word1, String word2) ->                   {                     if (word1.length() < word2.length())                         return -1;                     else if (word1.length() > word2.length())                         return 1;                     else                         return 0;                   });          Arrays.sort(words, (word1, word2) -> Integer.compare(word1.length(), word2.length()));  //        Arrays.sort(words, (String word1, String word2) -> Integer.compare(word1.length(), word2.length()));       }   }"
This test case comes from compiling javac's unofficial&unsupported Java API from JDK source code; javac compiles it without errors:  @SuppressWarnings("unused") final class Test {   private static class Key<T> {}   private static class Context {}   private static class Obj {}   private static class Dial<T> {}   private static interface Factory<T> {T make(Context c);}    private <T> void put(Key<T> key, Factory<T> fac) {}   private <T> void put(Key<T> key, T data) {}   private <T> void put(Class<T> clazz, Factory<T> fac) {}   private <T> void put(Class<T> clazz, T data) {}    private static <T> Dial<T> wrap(Dial<T> dl) {return null;}    static void foo(Dial<? super Obj> dial, Test context) {     //The method put(Test.Key<T>, Test.Factory<T>) in the type Test is not     //applicable for the arguments (Class<Test.Dial>, Test.Dial<capture#1-of ? super Test.Obj>)     context.put(Dial.class, wrap(dial));   } }
"Hello, I have an error from the compiler while compiling this code:   K1.java : import java.util.List; import java.util.Map;   public interface K1 { 	public Map<String,List> get(); }  K.java import java.util.List; import java.util.Map;   public class K implements K1 { 	@Override 	public Map<String, List> get() { 		return null; 	} } ""The return type is incompatible with K1.get()""  Why do i have this error, as the signature are the same? When i put List<?> in both the interface and the class, this work properly. Is the wildcard mandatory?  I am using 1.0.0.v20140213-0104_BETA_JAVA8 Eclipse Java Development Tools Patch for Java 8 Support (BETA), Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA), Eclipse RCP Patch for Java 8 Support (BETA)  Thanks!"
"Created attachment 239911 [details] Example from Horstmann's 'Java SE 8 for the Really Impatient', chapter 8, section 7  Received following exception while compiling the attached source:  !ENTRY org.eclipse.jdt.ui 4 0 2014-02-13 08:21:36.316 !MESSAGE Error in JDT Core during AST creation !STACK 0 java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:216) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:289) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:426) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:419) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.generateCode(LocalDeclaration.java:152) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:328) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:474) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)  Encountered in Luna, build I20140123-1600 with Eclipse Java Development Tools Patch for Java 8 Support (BETA) v 1.0.0.v20140213-0104_BETA_JAVA8"
Member.isMainMethod(IMethod) currently checks for isPublic() flag on main method.  With Java 8, Interface can have main method without explicit Public modifier. So the condition needs to be modified to take care of this.
Test case from compiling Eclipse source code at source and target level 1.8:  interface BundleRevision {} interface BundleDescription extends BundleRevision {} public class Snippet {   static Collection<BundleRevision> test(BundleDescription[] triggers) {     @SuppressWarnings("unchecked")     Collection<BundleRevision> triggerRevisions =     //Type mismatch: cannot convert from Collection<Object> to Collection<BundleRevision>       Collections         .unmodifiableCollection(triggers == null ? Collections.EMPTY_LIST         : Arrays.asList((BundleRevision[]) triggers));     return triggerRevisions;   } }  This is with the latest official BETA_JAVA8 plugins.
As a way to stress test the Java 8 compiler, we could build the entire eclipse SDK as a collection of 1.8 projects.  We already know that we are able to build the SDK at the prevailing compliance/source levels, but artificially boosting to 1.8 and building could serve as an excellent test.  This CR will serve as the master bug for this project, with leaf level bugs created for problems and linked here.
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=427787#c26  Here's an interesting case from the list:  public class HashMap<K, V> { 	static class Node<K, V> { 		Node(int hash, K key, V value, Node<K, V> next) {} 	} 	/** @see #put(Object, Object) */ 	public V put(K key, V value) {	return null; }  	Node<K, V> newNode(int hash, K key, V value, Node<K, V> next) { 		return new Node<>(hash, key, value, next); // Error 	} }  But the error goes away if I get rid of either the put() method or the javadoc above that."
"In this call stack:  SourceTypeBinding.kind() line: 797	 LookupEnvironment.convertUnresolvedBinaryToRawType(TypeBinding) line: 605	 ParameterizedTypeBinding.swapUnresolved(UnresolvedReferenceBinding, ReferenceBinding, LookupEnvironment) line: 1221	 UnresolvedReferenceBinding.setResolvedType(ReferenceBinding, LookupEnvironment) line: 133	 PackageBinding.addType(ReferenceBinding) line: 78	 ClassScope.buildType(SourceTypeBinding, PackageBinding, AccessRestriction) line: 411	 CompilationUnitScope.buildTypeBindings(AccessRestriction) line: 153	 LookupEnvironment.buildTypeBindings(CompilationUnitDeclaration, AccessRestriction) line: 190	 CompilationUnitResolver(Compiler).accept(ICompilationUnit, AccessRestriction) line: 331	 CompilationUnitResolver.accept(ICompilationUnit, AccessRestriction) line: 178	 CompilationUnitResolver.accept(ISourceType[], PackageBinding, AccessRestriction) line: 174	 LookupEnvironment.askForType(char[][]) line: 147	 UnresolvedReferenceBinding.resolve(LookupEnvironment, boolean) line: 103	 BinaryTypeBinding.resolveType(TypeBinding, LookupEnvironment, boolean) line: 174	 PackageBinding.getTypeOrPackage(char[]) line: 190	 ClassScope(Scope).getTypeOrPackage(char[], int, boolean) line: 3296	 ClassScope(Scope).getType(char[]) line: 3008	 SingleTypeReference.getTypeBinding(Scope) line: 54	 SingleTypeReference(TypeReference).internalResolveType(Scope) line: 468	 SingleTypeReference(TypeReference).resolveType(ClassScope) line: 559	 SingleTypeReference(TypeReference).resolveSuperType(ClassScope) line: 537	 ClassScope.findSupertype(TypeReference) line: 1264	 ClassScope.connectSuperInterfaces() line: 1030	 ClassScope.connectTypeHierarchy() line: 1085	 CompilationUnitScope.connectTypeHierarchy() line: 308	 LookupEnvironment.completeTypeBindings() line: 228	 LookupEnvironment.completeTypeBindings(CompilationUnitDeclaration) line: 260	 CompilationUnitResolver(Compiler).accept(ICompilationUnit, AccessRestriction) line: 335	 CompilationUnitResolver.accept(ICompilationUnit, AccessRestriction) line: 178	 CompilationUnitResolver.accept(ISourceType[], PackageBinding, AccessRestriction) line: 174	 LookupEnvironment.askForType(char[][]) line: 147	 UnresolvedReferenceBinding.resolve(LookupEnvironment, boolean) line: 103	 BinaryTypeBinding.resolveType(TypeBinding, LookupEnvironment, boolean) line: 174	 PackageBinding.getTypeOrPackage(char[]) line: 190	 MethodScope(Scope).getTypeOrPackage(char[], int, boolean) line: 3296	 MethodScope(Scope).getType(char[]) line: 3008	 SingleTypeReference.getTypeBinding(Scope) line: 54	 SingleTypeReference(TypeReference).internalResolveType(Scope) line: 468	 SingleTypeReference(TypeReference).resolveType(BlockScope, boolean) line: 555	 MethodScope(Scope).connectTypeVariables(TypeParameter[], boolean) line: 935	 SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1793	 SourceTypeBinding.methods() line: 1467	 SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 855	 CompilationUnitScope.faultInTypes() line: 424	 CompilationUnitResolver.resolve(CompilationUnitDeclaration, ICompilationUnit, NodeSearcher, boolean, boolean, boolean) line: 1201	 CompilationUnitResolver.resolve(ICompilationUnit, IJavaProject, List, NodeSearcher, Map, WorkingCopyOwner, int, IProgressMonitor) line: 693	 ASTParser.internalCreateAST(IProgressMonitor) line: 1187	 ASTParser.createAST(IProgressMonitor) line: 813	 ASTProvider$1.run() line: 548	 SafeRunner.run(ISafeRunnable) line: 42	 ASTProvider.createAST(ITypeRoot, IProgressMonitor) line: 541	 ASTProvider.getAST(ITypeRoot, SharedASTProvider$WAIT_FLAG, IProgressMonitor) line: 484	 SharedASTProvider.getAST(ITypeRoot, SharedASTProvider$WAIT_FLAG, IProgressMonitor) line: 132	 SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(ITypeRoot, ITextSelection, IProgressMonitor) line: 170	 SelectionListenerWithASTManager$PartListenerGroup$3.run(IProgressMonitor) line: 155	 Worker.run() line: 53	  we could conclude that a non-generic type is a generic type and create raw versions of it.  This is because, ClassScope.buildType() calls PackageBinding.addType() to add the new source type that is being built *before* its type variables are built. These type variables are consulted by frame 0 i.e  SourceTypeBinding.kind()  which reads:  if (this.typeVariables != Binding.NO_TYPE_VARIABLES)      return Binding.GENERIC_TYPE;  since this.typeVariables is still null and not initialized with either the special value Binding.NO_TYPE_VARIABLES or to the built type variables in the case of generic type, we would confuse a non-generic type to be a generic type and create raw versions of it.  This results various type incompatibilities down the road between    List<Type#Raw> and List<Type>  For example, while building JRE8 from the sources, we obsreve errors of the form:  Type mismatch: cannot convert from List<GarbageCollectorMXBean> to List<GarbageCollectorMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 415	Java Problem Type mismatch: cannot convert from List<MemoryManagerMXBean> to List<MemoryManagerMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 399	Java Problem Type mismatch: cannot convert from List<MemoryPoolMXBean> to List<MemoryPoolMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 386	Java Problem"
"The following program should compile, but is presently rejected:  // -- interface I { 	X foo(int a); }  public class X { 	public static void main(String[] args) { 		String s = ""Blah""; 		class Local extends X { 			Local(int a) { 				System.out.println(a); 				System.out.println(s); 			} 		} 		I i = Local::new; // Incorrect error here.                 i.foo(10); 	} }  Point is Local being in static context, does not have an enclosing instance."
//---- import java.util.function.*; import java.util.Optional;  interface I<E,F> {} class A<G> implements I<G, Optional<G>> {}  public class Y<S,T> {     Y(T o, Predicate<T> p, Supplier<I<S,T>> s) {}      static <Z> Y<Z, Optional<Z>> m() {         return new Y<>(Optional.empty(), Optional::isPresent, A::new);     } } //----  In current HEAD this produces an error (while javac is silent):          return new Y<>(Optional.empty(), Optional::isPresent, A::new);                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Type mismatch: cannot convert from Y<Object,Optional<Object>> to Y<Z,Optional<Z>>  With my pending patch for bug 428198 this escalates to an NPE.  Thus I need to find out what's going on here, before resolving the other bug.
The JDK8 compiler accepts this cast but Eclipse JDK8 does not:  package junk;  public class Junk4 {     private void setValue(Number n) {         int rounded = (int) Math.round((double) n);     } }  I expect other casts such as (float) and (int) should be accepted.
Attempting to compile this file in Eclipse JDK8 produces the exception described in the tile of this bug report:  /*  * Copyright (c) 2008, 2013 Oracle and/or its affiliates.  * All rights reserved. Use is subject to license terms.  *  * This file is available and licensed under the following license:  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *  - Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  - Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  - Neither the name of Oracle Corporation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ package ensemble.samples.charts.bar.image;   import javafx.application.Application; import javafx.collections.FXCollections; import javafx.scene.Parent; import javafx.scene.Scene; import javafx.scene.chart.BarChart; import javafx.scene.chart.CategoryAxis; import javafx.scene.chart.NumberAxis; import javafx.scene.chart.XYChart; import javafx.stage.Stage;   /**  * A bar chart that uses CSS to display stacks of car images to indicate data values  * for categories.   *  * @sampleName Image Bar Chart  * @preview preview.png  * @see javafx.scene.chart.BarChart  * @see javafx.scene.chart.CategoryAxis  * @see javafx.scene.chart.NumberAxis  * @playground chart.data  *   * @playground - (name="xAxis")  * @playground xAxis.autoRanging  * @playground xAxis.gapStartAndEnd  * @playground xAxis.startMargin  * @playground xAxis.endMargin  *   * @playground xAxis.animated  * @playground xAxis.side  * @playground xAxis.tickLabelFill  * @playground xAxis.tickLabelGap  * @playground xAxis.tickLabelRotation (min=-180,max=180,step=1)  * @playground xAxis.tickLabelsVisible  * @playground xAxis.tickLength  * @playground xAxis.tickMarkVisible  *   * @playground - (name="yAxis")  * @playground yAxis.autoRanging  * @playground yAxis.forceZeroInRange  * @playground yAxis.lowerBound (min=-100,max=0,step=1)  * @playground yAxis.upperBound (max=200,step=1)  * @playground yAxis.tickUnit (step=1)  * @playground yAxis.minorTickCount (max=16)  * @playground yAxis.minorTickLength (max=15)  * @playground yAxis.minorTickVisible  *   * @playground yAxis.animated  * @playground yAxis.side  * @playground yAxis.tickLabelFill  * @playground yAxis.tickLabelGap  * @playground yAxis.tickLabelRotation (min=-180,max=180,step=1)  * @playground yAxis.tickLabelsVisible  * @playground yAxis.tickLength  * @playground yAxis.tickMarkVisible  *   * @playground - (name="chart")  * @playground chart.horizontalGridLinesVisible  * @playground chart.horizontalZeroLineVisible  * @playground chart.verticalGridLinesVisible  * @playground chart.verticalZeroLineVisible  *   * @playground chart.animated  * @playground chart.legendSide  * @playground chart.legendVisible  * @playground chart.title  * @playground chart.titleSide  */ public class ImageBarChartApp extends Application {          private BarChart chart;     private CategoryAxis xAxis;     private NumberAxis yAxis;      public Parent createContent() {         xAxis = new CategoryAxis();         yAxis = new NumberAxis();         chart = new BarChart(xAxis, yAxis);         chart.setLegendVisible(false);         chart.getStylesheets().add(ImageBarChartApp.class                 .getResource("ImageBarChart.css").toExternalForm());          chart.getData().add(                 new XYChart.Series<>("Sales Per Product",                     FXCollections.observableArrayList(                         new XYChart.Data<>("SUV", 120),                         new XYChart.Data<>("Sedan", 50),                         new XYChart.Data<>("Truck", 180),                         new XYChart.Data<>("Van", 20)                     )                 )         );         return chart;     }               @Override public void start(Stage primaryStage) throws Exception {         primaryStage.setScene(new Scene(createContent()));         primaryStage.show();     }      /**      * Java main for when running without JavaFX launcher      * @param args command line arguments      */     public static void main(String[] args) {         launch(args);     }     }
"The following program refuses to compile with ECJ in all modes and compiles with JDK in all modes. There is no type safety compromise here:  // -- class Reference<T> { 	ReferenceQueue<? super T>  queue; } class ReferenceQueue<T> { } public class X {     public static void main(String args[]) {             Reference<Object> r = null;             ReferenceQueue<Object> q = r.queue;     } }   This is blocking ECJ8 from building JRE8."
Created attachment 239995 [details] This is the file that has the compile error.  This bug is impacting openJFX project builds.  The attached file compiles properly under 1.7 but fails under 1.8.  Make sure that you compile against JDK8 or have jfxrt.jar on the class path.    The compiler has trouble with ListExpressionHelper.addListener() and ListExpressionHelper.removeListener().
"Created attachment 239997 [details] WinMsiBundler.java shows the problem  This bug is impacting openJFX project builds.  The attached file compiles properly under 1.7 but fails under 1.8.  Make sure that you compile against JDK8 or have jfxrt.jar on the class path.  Here is the exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:162) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:289) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.generateCode(AllocationExpression.java:214) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.generateCode(FieldDeclaration.java:130) 	at org.eclipse.jdt.internal.compiler.ast.Clinit.generateCode(Clinit.java:305) 	at org.eclipse.jdt.internal.compiler.ast.Clinit.generateCode(Clinit.java:117) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:927) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:966) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
This bug is impacting OpenJFX project builds.  The following snippet shows a method that fails (//FAILS) to compile under Eclipse compiler but works under the JDK8.  It can be worked around by assigning to a local variable.  package junk;  import java.util.Collection; import java.util.List; import java.util.stream.Collectors;   public class Junk5 {      class TestTouchDevice {         public Object [] points;     }          public static List<TestTouchDevice> getTouchDevices() {         return null;     }      //WORKS     public static Collection<Object[]> getTouchDeviceParameters2(int minPoints) {         Collection c = getTouchDevices().stream()                 .filter(d -> d.points.length >= minPoints)                 .map(d -> new Object[] { d })                 .collect(Collectors.toList());          return c;     }          //FAILS     public static Collection<Object[]> getTouchDeviceParameters3(int minPoints) {         return getTouchDevices().stream()                 .filter(d -> d.points.length >= minPoints)                 .map(d -> new Object[] { d })                 .collect(Collectors.toList());     } }
Using this CR as the home, I'll shortly release a patch that fixes a bunch of  loose ends with the present synthetic static factory based <> inference. Many of these problems show up while building JRE8 from source zip.  Basically,       - Type variables from enclosing types are not handled correctly.     - Rawness of enclosing type is lost (static nested generic class sees its       outer as raw.)     - Certain scenarios result in NPEs while diagnosing redundant type        argument specification.     - Outer rawness gets dropped during substitutions     - Static factory method's return type is not encoded properly.  These problems do not affect the most common scenarios, but are important enough to fix because these impact the inference in non so uncommon scenarios.
We get an error:   The method getDirectlyAndIndirectlyPresent(Map<Class<? extends Annotation>,Annotation>, Class<A>) in the type AnnotationSupport is not applicable for the arguments (Map<Class<capture#9-of ? extends Annotation>,Annotation>, Class<T>)
"This happens with the latest BETA_JAVA8 plugins built from HEAD. One more for bug 428305 ?  What steps will reproduce the problem? 1. The source below gives NPEs when the second addAll3-method call is uncommented in editor.   -- Error Details -- Date: Mon Feb 17 15:25:28 EET 2014 Message: Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package npe_oejica_AllocationExpression_analyseCode_line105;  import java.util.Collection; import java.util.List; import java.util.function.Consumer; import java.util.function.Function;  class OperationsPile<B> {   OperationsPile(Function<B, ?> handler) {}    private static <T> void addAll3(Collection<T> c, T t) {}    static <S> void adaad3(List<OperationsPile<?>> combined, Consumer<S> handler) {     addAll3(combined, new OperationsPile<>(null));     addAll3(combined, new OperationsPile<>(handler));   } }  ----------------------------------- SOURCE END ------------------------------------- Severity: Error Product: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=4.3.0.M20130911-1000 java.version=1.8.0 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64  Exception Stack Trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCode(AllocationExpression.java:105) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:174) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:128) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:741) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:265) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:120) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:924) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:196) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:522) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1083) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
This bug is impacting openJFX project builds.  The following code fragment compiles under JDK8 but not the Eclipse IDE:  package junk;  import javafx.beans.binding.Bindings; import javafx.beans.property.ListProperty;  public class Junk6 {     private ListProperty<Object> property;     public void testValueAt_Variable_NullIndex() {         Bindings.valueAt(property, null);     } }  NOTE:  I am using the update site here:  http://build.eclipse.org/eclipse/builds/4P/siteDir/eclipse/downloads/drops4/P20140216-1600/java8patch-P20140216-1600-repository.zip
The default Java formatter seems to handle empty type arguments incorrectly if the second part of an assignment is placed after a newline.  Steps to reproduce     1. Launch Eclipse, create workspace and new Java project     2. Keep using the default formatter settings     3. Create a new class with a method.     3. Enter the following code fragment into the just created method:         List<String> wrong =                 new ArrayList<>();         System.out.println( wrong );     4. Select entire file, press Ctrl+i for correct indentation  Expected outcome:     No change  Actual outcome:     List<String> wrong =             new ArrayList<>();             System.out.println( wrong ); // Incorrect indentation  Reproducibility:     Always  Eclipse versions:     4.3.1-5 for Fedora 19 (32 bit)     Every recent build of 4.3.1 for Windows 64-bit  Workaround (which I don't like a lot):     List<String> wrong     = new ArrayList<>();     System.out.println( wrong );  Bye, G.
"We have started accepting the following:  // -- public class X {     public static void main(String[] args) { 	int x = (int) ""Hello"";     } }   probably due to the fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=428274 being too permissive - certain provably impossible false are not rejected."
I wanted to capture the finishing touches in this ticket, so we don't goof up and miss something in the last stages. This is to be taken up post RC2 (March 7th 2014)   Here is the list I came up with:  Core + APT:      1. Remove JCP disclaimer from all files.     2. Update @since 3.9 BETA_JAVA8 tags with appropriate values.     3. Does bundle versions/qualifier need change ?      4. Check if batch compiler version strings need to bumped up.     5. Build state identifier needs bump up ?     6. Make BETA_JAVA8 the master branch.  UI:            7. Do what is applicable from 1-6.     8. Change compliance string from 1.8_BETA to 1.8     9. Remove JCP disclaimer from dialog boxes.  10. Open up a bottle of champagne :)
"To reproduce, run the following code with ""Preserve unused local variables"" option turned off:  public class X {     public static void main(String args[]) {     	long l = (long) ((Object) 100L);     } }  This is a recent regression."
"Created attachment 240103 [details] Example class and NPE Stack in Event Details  When using a Class Constructor Ref ""TheClass::new"" and ""TheClass"" is using a default no-arg constructor the JDT fails with NPE.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding.<init>(SyntheticMethodBinding.java:385) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.addSyntheticFactoryMethod(SourceTypeBinding.java:687)  when using  		Supplier<WithoutNoArgConstructor> error = WithoutNoArgConstructor::new; 		System.err.println(error.get()); ... 	private static class WithoutNoArgConstructor { 	}"
An API could be provided in ITypeBinding to get the single abstract method (SAM) of a functional interface type corresponding to the internal implementation of ReferenceBinding#getSingleAbstractMethod and relevant checks from ReferenceBinding.isFunctionalInterface.  The API ITypeBinding#isFunctionalInterface can be replaced with the new API returning SAM and at the client side a null check for SAM will tell if the type is a functional interface.  The new API will help in avoiding with these checks at the client in the interface hierarchy (JSR 335 - 9.8 Functional Interfaces): - excluding methods that are also public methods in Object. - The signature of m is a subsignature (8.4.2) of every method's signature in M. - m is return-type-substitutable (8.4.5) for every method in M.  See also bug 424509.
"For lambdas created using a method reference of the form Type::MethodName instead of a lambda expression of the form (arg)->expression the Serialization does not work.  They will be compiled like non-Serializable lambdas ignoring if the functional interface extends Serializable.  import java.io.*; public class SimpleTestCase { 	interface Example extends Serializable 	{ 		String convert(Object o); 	} 	public static void main(String[] args) throws IOException { 		Example e=Object::toString; 		try(ObjectOutputStream os=new ObjectOutputStream(new ByteArrayOutputStream())) { 			os.writeObject(e); 		} 	} }  Produces  Exception in thread ""main"" java.io.NotSerializableException: Non-serializable lambda 	at SimpleTestCase$$Lambda$1/2536472.writeObject(Unknown Source)"
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=428552#c3:  The following program throws an exception when executed:  import java.io.*; import java.util.function.IntConsumer;  public class QuickSerializedLambdaTest { 	interface X extends IntConsumer,Serializable{} 	public static void main(String[] args) throws IOException, ClassNotFoundException { 		X x1 = i -> System.out.println(i);// lambda expression 		X x2 = System::exit; // method reference 		ByteArrayOutputStream debug=new ByteArrayOutputStream(); 		try(ObjectOutputStream oo=new ObjectOutputStream(debug)) 		{ 			oo.writeObject(x1); 			oo.writeObject(x2); 		} 		try(ObjectInputStream oi=new ObjectInputStream(new ByteArrayInputStream(debug.toByteArray()))) 		{ 			X x=(X)oi.readObject(); 			x.accept(42);// shall print ""42"" 			x=(X)oi.readObject(); 			x.accept(0);// shall exit 		} 		throw new AssertionError(""should not reach this point""); 	} }"
Completion is missing at "|":  class Person {    String getLastName() { ... } } ... void test1 (List<Person> people) {     // want to see getLastName():     people.stream().forEach(p -> System.out.println(p.|)); // NOK }   In the next example completion works OK:  void test2(List<Person> people) {     people.sort((x,y) -> x.|);  // OK }  but when I continue, the second attempt yields nothing:  void test2(List<Person> people) {     people.sort((x,y) -> x.getLastName().compareTo(y.|));  }  If there's a pattern behind, it could be - completion works on the initial token of a lambda body - completion fails on tokens nested in some expression inside a lambda body  more failing examples:     people.sort((x,y) -> x.getLastName()+y.|);      people.sort((x,y) -> ""+x.|);   At first I thought this might be limited to type elided lambdas, but adding parameter types doesn't seem to help (didn't test all cases).
Now that bug 427169 works nicely (thanks!) "wouldn't it be cool" if the next level of conversion be supported, too:  from   people.map(Person::getLastName) to   people.map(p -> p.getLastName())  This direction shouldn't require too much analysis (just needs a new name 'p').  The opposite direction would be even cooler, but for that you'd need to analyse which lambdas are amenable to this conversion. That could be tricky.  I believe such quick assists would be highly educational for J8 newbies :)
The following code compiles under JDK8 but not under Eclipse:  package junk;  import java.util.ArrayList; import java.util.Collections; import java.util.List;   public class Junk9 {     class Node {         public double getLayoutY() {return 12;}     }     void junk() {         List<Integer> visibleCells = new ArrayList<>(20);         Collections.sort(visibleCells, (Node o1, Node o2) -> Double.compare(o1.getLayoutY(), o2.getLayoutY()));     } }
I am getting an  Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)  with this code:  import java.net.NetworkInterface; import java.util.Optional;  public class Tutego {   public static void main( String[] args )   {     Optional.ofNullable( NetworkInterface.getByIndex( 2 ) ).ifPresent( ni -> {       Optional.ofNullable( ni.getDisplayName() ).ifPresent( name ->         System.out.println( name.get().toUpperCase() )       );     } );   } }
"Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140221-1402 JDK 8 b129 64-bit  -----  import java.util.AbstractList; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.stream.Collector;  public class MoreCollectors {     public static void main (String[] args) {         ImmutableList<String> list = Arrays.asList(""a"", ""b"", ""c"").stream().collect(toImmutableList());                  System.out.println(list);     }          public static <T> Collector<T, ?, ImmutableList<T>> toImmutableList () {         return Collector.of(ArrayList<T>::new,                 List<T>::add,                 (left, right) -> { left.addAll(right); return left; },                 ImmutableList::copyOf);     }          private static class ImmutableList<T> extends AbstractList<T> {         public static <T> ImmutableList<T> copyOf (Collection<T> c) {             return new ImmutableList<>(c.toArray());         }          private Object[] array;                  private ImmutableList (Object[] array) {             this.array = array;         }          @Override @SuppressWarnings(""unchecked"")         public T get(int index) {             return (T)array[index];         }          @Override         public int size() {             return array.length;         }     } }  -----  The Eclipse compiler requires the Collector.of method in toImmutableList to have a type witness of <T, List<T>, ImmutableList<T>> to compile, while the JDK8 compiler does not. I'm not 100% sure whether it should be required, but I would think javac is correct.  (If you're wondering, I'm using Guava's ImmutableList. I made the one here to keep the example self-contained.)"
Not sure if this is a dup of bug 340506 or bug 427719, but here is a small example where eclipse fails to report ambiguous method invocation. Almost looks like jdt compiler is confused about newAbstractClass() return type and uses IInterface interface instead of AbstractClass abstract class. The error is correctly flagged by javac  Tested with eclipse 4.4M5 (I20140123-1600) and javac from jdk 1.7.0_45-b18 on command line.  ------------------------------------- package ambiguous;  import java.io.File;  public class AmbiguousTets {    static interface IInterface {     public void method(File file);   }    static abstract class AbstractClass implements IInterface {      public void method(File file) {       System.err.println("file");     }      public void method(String string) {       System.err.println("string");     }   }    private static AbstractClass newAbstractClass() {     return new AbstractClass() {};   }    public static void main(String[] args) {     // this should be flagged as ambiguous, but is not     // correctly reported by javac as an error     newAbstractClass().method(null);   } } -------------------------------------
"Consider the below code snippet: package p1; public interface Change<T, R, E extends Exception> {  	R apply(T t) throws E;  	default <V> Change<V, R, E> from(Change<? super V, ? extends T, E> before) { 		// extract method 		return /**/(V v) -> apply(before.apply(v));/**/ 	} }  Invoke Extract method on ""(V v) -> apply(before.apply(v));"" The resultant code after refactoring has compiler error: ""Unhandled exception type E"""
Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140223-2022 JDK 8 b129 64-bit  ----------  import java.util.Arrays; import java.util.List; import java.util.function.Function;  public class Raw {     public static void main (String[] args) {         Function<List<String>, String> func = List::toString;                  System.out.println(func.apply(Arrays.asList("a", "b")));     } }  ----------  Eclipse warns about the raw type List in List::toString with the warning: "List is a raw type. References to generic type List<E> should be parameterized." As far as I can tell -- compiling with -Xlint:rawtypes -- javac accepts this without a warning.
"Using  Kepler SR2 + Java 8 RC1 + Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140223-2022, consider the below code snippet: package p1; import java.io.*; import java.util.function.IntConsumer;  public class QuickSerializedLambdaTest { 	interface X extends IntConsumer,Serializable{} 	public static void main(String[] args) throws IOException, ClassNotFoundException { 		X x1 = i -> System.out.println(i);// lambda expression 		X x2 = System::exit; // method reference 		ByteArrayOutputStream debug=new ByteArrayOutputStream(); 		try(ObjectOutputStream oo=new ObjectOutputStream(debug)) 		{ 			oo.writeObject(x1); // TODO: Add breakpoint in this line 			oo.writeObject(x2); 		} 		try(ObjectInputStream oi=new ObjectInputStream(new ByteArrayInputStream(debug.toByteArray()))) 		{ 			X x=(X)oi.readObject(); 			x.accept(42);// shall print ""42"" 			x=(X)oi.readObject(); 			x.accept(0);// shall exit 		}catch(Exception e){ 			e.printStackTrace(); 		} 		throw new AssertionError(""should not reach this point""); 	} }  Add a breakpoint inside the main method and debug as Java Application. When the breakpoint is hit, a popup dialog is displayed saying: ""Unable to install breakpoint in p1.QuickSerializedLambdaTest$X due to missing line number attributes. Modify compiler options to generate line number attributes. Reason: 	Absent Line Number Information"" As mentioned in bug 135027, executed  ""javap -l"". Below is the result:  Compiled from ""QuickSerializedLambdaTest.java"" public class p1.QuickSerializedLambdaTest {   public p1.QuickSerializedLambdaTest();     LineNumberTable:       line 5: 0     LocalVariableTable:       Start  Length  Slot  Name   Signature           0       5     0  this   Lp1/QuickSerializedLambdaTest;    public static void main(java.lang.String[]) throws java.io.IOException, java.l ang.ClassNotFoundException;     LineNumberTable:       line 8: 0       line 9: 6       line 10: 12       line 11: 20       line 11: 26       line 13: 36       line 14: 42       line 15: 48       line 16: 107       line 16: 113       line 18: 133       line 19: 143       line 20: 152       line 21: 162       line 22: 170       line 23: 231       line 25: 236     LocalVariableTable:       Start  Length  Slot  Name   Signature           0     246     0  args   [Ljava/lang/String;           6     240     1    x1   Lp1/QuickSerializedLambdaTest$X;          12     234     2    x2   Lp1/QuickSerializedLambdaTest$X;          20     226     3 debug   Ljava/io/ByteArrayOutputStream;          36      37     6    oo   Ljava/io/ObjectOutputStream;         133      62     6    oi   Ljava/io/ObjectInputStream;         143      27     7     x   Lp1/QuickSerializedLambdaTest$X;         231       5     4     e   Ljava/lang/Exception; }  Why is this dialog coming up?"
"When a non-public method from a class is pulled up to an interface, a protected method is created in the interface and hence results in compiler error in both source and destination files. package com.p1;  public interface I {  }  package com.p2;  import com.p1.I;  public class C1 implements I{ 	private String foo() { // Pull up to I 		return null; 	} } Two points to be taken care off; 1. When a method is pulled up to an interface, the method should be made public. 2. Since the overriding method cannot reduce the visibility of the inherited method, the method in C1 also should be changed to public visibility."
"This example gives a wrong warning:  // --- import org.eclipse.jdt.annotation.*;  interface NNFunc { 	@NonNull String a(@NonNull String i); } public class PolyNull { 	@NonNull String extract1(NNFunc f, @NonNull String s) { return f.a(s); } 	@NonNull String test1() { 		return extract1(i -> i, ""hallo""); // bogus warning 	} } // ---  Warning is: Null type safety (type annotations): The expression of type '@NonNull String' needs unchecked conversion to conform to '@NonNull String'  The warning is wrong because the lambda argument 'i' is actually @NonNull."
"Consider examples like this:  //--- import org.eclipse.jdt.annotation.*;  interface Func<T>  { 	T a(T i); } public class PolyNull { 	<X> X extract(Func<X> f, X s) { return f.a(s); } 	@NonNull String test() { 		return extract(i -> i, ""hallo""); 	} //---  Type inference will infer X to String, fine. But the target type is actually '@NonNull String'.  While null analysis should not affect the basic outcome of type inference, we actually have sufficient leeway to improve the exact inferred type:  Inference comes up with   X#0 :> String   X#0 <: @NonNull String knowing that both bounds are compatible since incorporation didn't fail.  During resolution X#0 is instantiated just from the lower bound, which has no null annotation. If we add to this result just the nullness findings from the upper bounds we can indeed produces the result '@NonNull String'.  I'll look for more tests, to see this is already makes for a consistent solution. Another option would be to add nullness hints to TypeBounds during incorporation.  Obviously, any such magic will be controlled by the option to enable null annotations in the first place."
"The search engine should support a new 'limitTo' option in IJavaSearchConstants to limit matches to Java-8-style method reference expressions.  E.g. only one reference to Integer#toHexString(int) should be found in this code when the flag is set:  	Function<Integer, String> hexer= Integer::toHexString; // yep 	System.out.println(hexer.apply(666)); 	System.out.println(Integer.toHexString(666)); // nope"
"Copied from bug 427122 comment #9:  When the Java project was on 1.6, hovering over the error marker on @NonNull did not show the Quick Fix for the below scenario: package test1;  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.List;  public class CheckCompiler { 	@Target(ElementType.TYPE_USE) 	static @interface NonNull { }  	List<@NonNull String> foo(List<@NonNull String> arg) { 		return arg; 	} }  If we use ""Ctrl+1' to invoke the Quick Fix, then the fix was available. On analysis found that, when we invoke Quick Fix(Ctrl+1) JavaCorrectionProcessor#computeQuickAssistProposals is invoked which collects all the problem ids and suggest the proposal, but when we hover JavaCorrectionProcessor#collectCorrections is invoked with just one problem Id and that id (IProblem.DisallowedTargetForAnnotation) we are suppressing currently."
Compiling the following code causes an exception inside the compiler:   import java.io.Serializable; import java.util.function.IntFunction;  public class ArrayConstructorReference {   interface IF extends IntFunction<Object>, Serializable {}   public static void main(String[] args)   {     IF factory=String[]::new;   } }  produces  Errors occurred during the build. Errors running builder 'Java Builder' on project '…'. org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding  Note that this problem only occurs when the functional interface is Serializable.
"I ran into this when I hovered on something in JRE sources: Don't quite know what, but it should be easy to make progress without it.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.binding(AllocationExpression.java:720) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.acceptPendingPolyArguments(InferenceContext18.java:1468) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1412) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1397) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:553) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5101) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:5023) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:581) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:627) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:550) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:490) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:605) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:334) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:829) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:622) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:740) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:692) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:96) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getMethodOverrideTester(SuperTypeHierarchyCache.java:105) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:171) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)"
From https://bugs.eclipse.org/bugs/show_bug.cgi?id=425134#c0:  I have extracted   --------- - CodeSelect should resolve the lambda element when the caret is on the '->'. Currently, there's no easy way to see the contract of the functional interface method that the lambda implements. We should show a Javadoc hover for lambdas. ------  into the present ER.  This is unrelated to the requirement in that bug - see that the model element needed to be returned when hovering on -> or :: is the one for the SAM and not  the lambda.  i.e we would treat it somewhat analogous to hovering on a message send and show the binding that corresponds to the method.  We need enablement from UI : presently ICodeAssist.codeSelect is not invoked apparently when the cursor is not an identifier. I'll raise a bug shortly.
Manoj has collected some profiles that show that ~70% of time spent in indexing goes into the new method SourceIndex.indexedResolvedDocument.  We need to find ways to speed this up:  Some obvious candidates looking at the profile (Manoj - please attach)      - Disabling task tag processing     - Setting a bit in those methods that have a functional type and only populating those methods's bodies in the parse tree (others will have the skeleton built by diet parser)  etc.
"4.4.0.I20140225-1430  Content assist doesn't show any Javadoc proposals after ""@see #"" when the next line is ""@deprecated"", e.g. here:  /**  *   * @see #  * @deprecated  */ public class Depr { 	public void foo() { } }"
Null type annotations are not correctly analyzed for various situations like    List<? extends @Nullable A> la = new ArrayList<@NonNull B>();  Since passing B for "? extends A" is legal (if B extends A), the same statement should also allow to specialize from @Nullable to @NonNull.  Obviously, this has to be considered also when analyzing usage of reference with bounded-wildcard type carrying null type annotations:    List<? extends @NonNull A> la1 = ...   la1.add(null); // should be error   List<? super @NonNull A> la1 = ...   @NonNull A a = la1.get(0); // should be error  etc. pp.
"This non-compiling method snippet copy-pasted from a larger class still causes the same ArrayIndexOutOfBoundsExceptions being thrown. Easiest reduction by far, ever! The code:  package aioobe_oejica_AbstractMethodDeclaration_createArgumentBindings_line_107;  import java.util.function.BiFunction; import java.util.function.Supplier; import java.util.function.ToIntFunction; import java.util.stream.IntStream; import java.util.stream.Stream;  public interface Foo { static <BT, T extends BT, IS extends IntStream, E extends Exception> IntStreamy<E> internalFlatMapToInt(Functionish<BT, IS, E> mapper, Class<E> classOfE, Supplier<Stream<T>> maker) { BiFunction<Stream<T>, ToIntFunction<BT>, IntStream> func = (Stream<T> t, ToIntFunction<BT, IS> m) -> t.flatmmapToInt(m); return IntStreamy.fromFlatMap(func, mapper, classOfE, maker); } }  The installation: eclipse.buildId=4.4.0.I20140123-1600 java.version=1.8.0 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64 -data C:\Users\Timo\workspace  The stack trace: java.lang.ArrayIndexOutOfBoundsException: 0 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.createArgumentBindings(AbstractMethodDeclaration.java:107) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:393) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:251) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:549) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:542) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:485) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Created attachment 240434 [details] Hierarchical perf figures rooted at getParameterizedType()  27% of the total time for build was found to be spent inside this function hierarchy. On its own, this function accounts for 11%.  To reduce to whatever possible.
We don't report IProblem.undefinedType but report UndefinedName because the grammar does not allow us to discriminate.  // -- import java.util.Arrays; import java.util.List; import java.util.function.Function;  public class X {     public static void main (String[] args) {         Function<List<String>, String> func = ArrayList::toString;                   System.out.println(func.apply(Arrays.asList("a", "b")));     } }
An assignment like this is correctly flagged in most locations but not against a field initializer:     List<@NonNull Person> l = new ArrayList<@Nullable Person>();
Java Development User Guide > Getting Started > Basic Tutorial > Editing Java elements > Organizing import statements says,  "Delete the import declarations by selecting them in the Outline view ..."  but they aren't there anymore. This was mentioned in a forum post, 28.11.2012, where Dani Megert promptly replied, saying they're now hidden by default and requesting a bug be filed against the doc. I just ran into this in build 4.3.0.M20130911-1000. I couldn't find a bug, so I'm filing one.  Please see forum: http://www.eclipse.org/forums/index.php/mv/msg/440736/987918/#msg_987918 and http://www.eclipse.org/forums/index.php/mv/msg/440736/987885/#msg_987885   Paul Robinson  P.S. Just downloaded eclipse.buildId=4.3.2.M20140221-1700 and checked. Problem is still there.
"Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140302-1952  ----------  public class X {     public static void main (String[] args) {         List<String> list = new ArrayList<>();         list.addAll(X.newArrayList());         System.out.println(list);     }          public static <T> List<T> newArrayList () {         return new ArrayList<T>();     } }  ----------  The list.addAll method gives this warning: ""Problem detected during type inference: (Recovered) Internal inconsistency while checking invocation ambiguity"". Of course, giving X.newArrayList() the type witness of <String> fixes things, as does (strangely?) changing the type of ""list"" to Collection<String>."
Java development user guide > Getting Started > Basic Tutorial > Editing Java elements > Extracting a new method 1. shows  ... addTestMethod(methods[i], names, constructor); ...  while the screenshot under 2. and the actual source we work with has  ... addTestMethod(methods[i], names, theClass); ...  Paul
See below for code. It compiles in JDK 8 build 129 but fails to compile in JDT with the error message "Unhandled exception type IOException". Based on the quick-fix suggestions, JDT seems to have inferred X as RuntimeException.  CAVEAT: I do not know if the "broken" lines adhere to the spec, so it's possible the JDK is in error.  java version "1.8.0" Java(TM) SE Runtime Environment (build 1.8.0-b129) Java HotSpot(TM) Server VM (build 25.0-b69, mixed mode)   Eclipse version: Version: Kepler Service Release 2 Build id: 20140224-0627  Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140302-1952 org.eclipse.jdt.java8patch.feature.group  Include jdt.annotation 2.0 support in patch feature. 1.0.0.v20140220-1916 org.eclipse.jdt.a2.java8patch.feature.group  Eclipse Plug-in Development Environment Patch for Java 8 Support (BETA) 1.0.0.v20140228-2041 org.eclipse.pde.java8patch.feature.group   import java.io.*; public class Main {   public static interface Closer<T, X extends Exception> {     void closeIt(T it) throws X;   }    public static <T, X extends Exception> void close( Closer<T, X> closer, T it ) throws X {     closer.closeIt(it);   }    public static void main(String[] args) throws IOException {     InputStream in = null;     close( x -> x.close(), in ); // eclipse: NO, javac: YES     close( InputStream::close, in ); // eclipse: NO, javac: YES     close( (Closer<InputStream, IOException>)InputStream::close, in ); // eclipse: YES, javac: YES     // JDT reports: "Unhandled exception type IOException" in "NO" cases   } }
"interface I {     public int doit(); }  public class X {    @SuppressWarnings(""unused"") void zoo() { 	    I i = () /*1*/-> {                  I i2 = () /*2*/-> Y.foo(() -> Y.foo(()->Y.foo(()->10)));                  final Y y = new Y() {                 		@Override                 		public int doit() {                 			I i = () -> 10;                 			return i.doit();                 		}                  };                  return 0;        };    } }  class Y implements I{  	static int foo(I i) { return 0;} 	@Override 	public int doit() { 		// TODO Auto-generated method stub 		return 0; 	}	   }  /* Press F4 for I, and check out the lambdas listed. same LEs are highlighted multiple times in the expression: I i2 = () /*2*/-> Y.foo(() -> Y.foo(()->Y.foo(()->10))); */"
The following code compiles under JDK8 but not under Eclipse 8:  package junk;  public class Junk11 {     class Observable<T> {}     class ObservableValue<T> {}     interface InvalidationListener {         public void invalidated(Observable observable);     }     public interface ChangeListener<T> {         void changed(ObservableValue<? extends T> observable, T oldValue, T newValue);     }     class ExpressionHelper<T> {}     public static <T> ExpressionHelper<T> addListener(ExpressionHelper<T> helper, ObservableValue<T> observable, InvalidationListener listener) {         return helper;     }     public static <T> ExpressionHelper<T> addListener(ExpressionHelper<T> helper, ObservableValue<T> observable, ChangeListener<? super T> listener) {         return helper;     }     void junk() {         addListener(null, null, new InvalidationListener () {             public void invalidated(Observable o) {throw new RuntimeException();}         });         addListener(null, null, (o) -> {throw new RuntimeException();});     } }   NOTE:  This is a recent regression.  I updated this morning and got the compile error.  A guess: The single abstract method invalidated() should be selected based on the number of arguments?
"interface I {     public void doit(); }  public class X { 	I i = () -> {}; }   Change I.doit()'s signature - the lambda does not compile anymore.  Now that declarations in hierarchy correctly tags the lambda as implementing I.doit, expectation is that this should work."
"public class X extends Y {     public static void main(String [] args) { 	I<Y> c = () /* foo */ -> () /* bar */ -> {}; 	I<Y> y = args.length < 1 ? (() /* true */-> 42) : (() /* false */ -> 23); 	Object o = (I) () /* cast */ -> 42; 	} } interface I<T> { 	public T foo(); } class Y { 	public void bar() {} } /* Code has errors - these errors are required to get the bug reproduced */  Press F4 for I and NPE with the following stack occurs:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:41) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:217) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:171) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:492) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:824) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProject(IndexBasedHierarchyBuilder.java:227) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPotentialSubtypes(IndexBasedHierarchyBuilder.java:307) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:132) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRefresh(TypeHierarchyLifeCycle.java:336) 	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRefreshBackground(TypeHierarchyLifeCycle.java:271) 	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle$2.run(TypeHierarchyLifeCycle.java:224) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
In order to check parameter compatibility, the method compatibilityLevel18FromInner may perform inner inference and if successful calls innerPoly.updateBindings(..). Since at this point selection of the most specific method for the outer invocation hasn't happened, we should try to avoid this side effect. But then we need to ensure that final binding update always happens for all inners.
Currently if I use an API release as x-internal I get the following error message:  Discouraged access: The method ..... from the type .... is not accessible due to restriction on required  project ....  This is always confusing to the participants of my plug-in and RCP training sessions.  Can we change it to something like:  Discouraged access: The method ..... from the type .... is not released as official API in project ....
IMethod should expose a public API like isLambda() to know if a method is of the LambdaMethod
"Running this snipped in Eclipse JAVA_BETA8 produces an error (see below). Running it on the command-line with jdk8 works fine.  public class Main { 	 	public static void main(String[] args) { 		test(new Some<>(1.1d)); 	}  	static <S> void test(Option<S> value) { 	} 	 	static interface Option<T> { 	} 	 	static class Some<T> implements Option<T> { 		Some(T value) { 		} 	}  }  Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     Main.main([Ljava/lang/String;)V @7: invokespecial   Reason:     Type double_2nd (current frame, stack[3]) is not assignable to 'java/lang/Object'   Current Frame:     bci: @7     flags: { }     locals: { '[Ljava/lang/String;' }     stack: { uninitialized 0, uninitialized 0, double, double_2nd }   Bytecode:     0000000: bb00 1059 1400 12b7 0014 b800 17b1       	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688) 	at java.lang.Class.getMethod0(Class.java:2937) 	at java.lang.Class.getMethod(Class.java:1771) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)"
"package one.test;  @FunctionalInterface interface Foo { 	int foo(int x); }  public class T { 	// Select 'x' in lambda body and press Ctrl+G. 	Foo f1= x -> x; //[1] 	Foo f2= (int x) -> x; //[2] } -----------------------------------------------------  - Select 'x' in lambda body. - Go to the menu: Search > Declarations > Workspace. Or, press Ctrl+G. - Works at [2] but shows no result at [1]."
some of the test cases of bug 400899 are disabled currently. Enable the following test cases: test400899g18,19,22. Remove incorrect tests. and correct and output to the rest.
"Hi, one more finding (jdk8 compiles, eclipse not):  public class Main {  	public static void main(String[] args) {  		// * 		// * ERROR MESSAGE: 		// * Lambda expression's signature does not match 		// * the signature of the functional interface method get() 		// * 		final int i = new Test<Integer>().test("""", (String s) -> 1);  	}  	static class Test<R> {  		<T> R test(T t, Supplier<R> s) { 			return s.get(); 		}  		<T> R test(T t, Function<T, R> f) { 			return f.apply(t); 		} 	}  }"
"stumbled upon this one...  public class Main {  	public static void main(String[] args) { 		 		// does not compile 		final int i = new Test<Integer>().test((Byte b) -> (int) b); 		 	} 	 	static class Test<R> { 		 		<T> R test(Function<T,R> f) { 			return null; 		} 		 	} 	 }"
Since we are using new APIs from jdt.core we need to update the minimum required version of jdt.core to the version that contains the new APIs being used.
"The signatures returned by lambda IMethod APIs should be dot-based. Currently, getReturnType() and getParameterTypes() return slash-based signatures.  This needs to be fixed to make Javadoc hovers on Lambda expressions work (once codeSelect on ""->"" returns the lambda method and not the SAM).  Example:  interface I { 	/** 	 * Does it! Really. 	 * @param number the int 	 * @param str the String 	 */ 	Object doit(int number, String str); }  class X {     I i = (i, s) -> {         return null;     }; }  E.g. use the JavaElement view to inspect the local variable ""s"" and then check its declaring member.  - second parameter type is ""Ljava/lang/String;"". Should be ""Ljava.lang.String;"". - return type is ""Qjava/lang/Object;"", which is wrong. An unresolved signature (""Q"") cannot be qualified. Should be ""Ljava/lang/Object;"" - please also check the other API methods"
IMethodBinding#getJavaElement() should return the IMethod for a lambda method binding.  Just for consistency; I currently don't have an urgent use case.
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=425152#c8  -------------------------------------------- package bug; interface I1 { int foo(String i); } class Y { 	I1 i = (a) -> {  		a.charAt(0); 	}; } --------------------------------------------  Place caret at end of ""String"" and press Backspace to delete 'g'. We get this exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123) 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:52) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:485) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.analyseCode(FieldDeclaration.java:91) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:703) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:265) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:122) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1211) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) ..."
"F4 works fine in this case, but (menu) Search + Implementors + Workspace brings up nothing after selecting Foo.  // -- @FunctionalInterface interface Foo { 	int foo(int x); }  public class T { 	// Select 'x' in lambda body and press Ctrl+G. 	Foo f1= x -> x; //[1] 	Foo f2= (int x) -> x; //[2] }"
"package pkg.test;  @FunctionalInterface interface FI { 	int foo(); }  class C1 { 	void fun1(int x) { 		FI test= () -> { 			for (int k=0;k<1;) ; 			for (int k=0;k<1;) ; 			try { 				 			} catch (Exception ex) { 				 			} 			return 0; 		}; 	} } ---------------------------------------------------------------  Hover over ""ex"" in catch clause. We get the following exception:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.ForStatement cannot be cast to org.eclipse.jdt.internal.compiler.ast.LambdaExpression 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeLambdaExpression(Parser.java:7975) 	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.consumeLambdaExpression(SelectionParser.java:765) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6827) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11023) 	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1628) 	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1466) 	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:308) 	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:271) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:964) 	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:375) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:118) ..."
Tracks the work of merging the beta Java 8 work back into master.  I created a BETA_JAVA8_LUNA branch off master and cherry-picked all the work into it: http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/log/?h=BETA_JAVA8_LUNA
Created attachment 240672 [details] Patch 1  Superinterfaces of lambda element's IType are missing type arguments. The effect of this is that method override computations in JDT UI fail (e.g. in Ctrl+T and to render Javadocs for the lambda IMethod).  Example:      Function<List<String>, List<String>> sup = (arg) -> {         return new ArrayList<>(arg);     };      Function<List<String>, List<String>> suppe =                 new Function<List<String>, List<String>>() {         @Override         public List<String> apply(List<String> arg) {             return new ArrayList<>(arg);         }     };  IType#getSuperInterfaceTypeSignatures() on the IType for the lambda returns "QFunction;". This signature is missing type arguments.  The corresponding anonymous type always returns the supertype via IType#getSuperclassTypeSignature(). Here, it returns the correctly parameterized signature "QFunction<QList<QString;>;QList<QString;>;>;".  For the lambda IType, resolved supertypes would be also be better than unresolved ones.  The attached patch fixes this, but I don't really understand the difference between the LambdaExpression and ResolvedLambdaExpression types.
"Search for references to the functional interface type of a lambda with an (illegal!) 'this' parameter throws AIIOBE.  Search for references to type ""Function"" here:  	Function<String, String> f1= (String s, Function this) -> s; 	Function<String, String> f2= (Function this, String s) -> s;  The line numbers in the stacktrace may not be accurate, since I had some pending changes in my workspace. The AIOOBE happens in line 	String signature = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));  I think the ""length"" variable should be set to min(lambdaExpression.descriptor.parameters.length,lambdaExpression.arguments.length). Note that ""length"" is currently written twice.  !ENTRY org.eclipse.core.jobs 4 2 2014-03-08 14:06:23.938 !MESSAGE An internal error occurred during: ""Java Search"". !STACK 0 java.lang.ArrayIndexOutOfBoundsException: 1 	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:62) 	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:49) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.createHandle(MatchLocator.java:457) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2226) 	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:216) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:637) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.traverse(FieldDeclaration.java:343) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2612) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2845) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2572) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1755) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1164) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1205) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1322) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"This is a recent regression:   // -- public class X { 	public static void main(String[] args) { 		I i = (I s) -> s;  	}  }  results in  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.collectMissingTypes(MethodBinding.java:378) 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.missingTypeInLambda(ProblemReporter.java:6190) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:425) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:251) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591)"
"I use Eclipse Support for Java 8 (https://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_(BETA)).  Installation details:  - Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140308-1731  - Eclipse Plug-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140303-1740 - Eclipse Standard/SDK	2.0.2.20140224-0000	epp.package.standard  I can't run following code from Eclipse. This code works fine with JDK javac and java command.  ------------------------------------------------------------------------------------ package xxx;  import java.util.function.Supplier;  public class Main {  	public static void main(String[] args) { 		execute(() -> { 			executeInner(() -> { 			}); 			return null; 		}); 		System.out.println(""done""); 	}  	static <R> R execute(Supplier<R> supplier) { 		return null; 	}  	static void executeInner(Runnable callback) { 	} }  ------------------------------------------------------------------------------------ eclipse.buildId=4.3.2.M20140221-1700 java.version=1.8.0 java.vendor=Oracle Corporation BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=ja_JP Framework arguments:  -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocation Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocation  Error Sun Mar 09 11:20:45 JST 2014 Unhandled event loop exception  java.lang.UnsupportedOperationException 	at org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.constantPoolName(InferenceVariable.java:50) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.signature(ReferenceBinding.java:1734) 	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:54) 	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:47) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:217) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:216) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:171) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:492) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:824) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:624) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:741) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:693) 	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.hasSuperclass(JavaLaunchableTester.java:467) 	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.test(JavaLaunchableTester.java:610) 	at org.eclipse.core.internal.expressions.Property.test(Property.java:58) 	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68) 	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.IterateExpression.evaluate(IterateExpression.java:150) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.WithExpression.evaluate(WithExpression.java:72) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.evalEnablementExpression(LaunchShortcutExtension.java:287) 	at org.eclipse.debug.ui.actions.ContextualLaunchAction.isApplicable(ContextualLaunchAction.java:295) 	at org.eclipse.debug.ui.actions.ContextualLaunchAction.fillMenu(ContextualLaunchAction.java:218) 	at org.eclipse.debug.ui.actions.ContextualLaunchAction$1.menuShown(ContextualLaunchAction.java:137) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:255) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4166) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1489) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1474) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1279) 	at org.eclipse.jface.action.ActionContributionItem.copyMenu(ActionContributionItem.java:1268) 	at org.eclipse.jface.action.ActionContributionItem.handleShowProxy(ActionContributionItem.java:1248) 	at org.eclipse.jface.action.ActionContributionItem.access$4(ActionContributionItem.java:1237) 	at org.eclipse.jface.action.ActionContributionItem$8.handleEvent(ActionContributionItem.java:1210) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4166) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1489) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1470) 	at org.eclipse.swt.widgets.Menu.menuWillOpen(Menu.java:806) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5610) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSMenu.popUpContextMenu(NSMenu.java:77) 	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:278) 	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4089) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3644) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:140) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:611) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)"
With bug 392245 being resolved for BETA_JAVA8, we still need to evaluate the new annotation attribute of type DefaultLocation. While an implementation under test exists, this is too big a change for BETA_JAVA8 at this point. Hence separating this implementation from the API release.
"From bug 429948 comment 5:  Digging deeper the following root cause looks suspicious to me, see this block in LE.resolveType():  if (this.expectedType != null && this.original == this) {  // final resolution. 	this.ordinal = blockScope.referenceCompilationUnit().record(this); }  This check misses the fact, that we might be within a copy-resolve process of an enclosing lambda, i.e., our entire universe is only fake, still the current lambda is final resolved, sure, but still this final resolve in a fake universe shouldn't count and shouldn't be recorded in the CUD.  In fact in test429948() the CUD contains 4 elements in CUD#functionalExpressions, although the source has only two lambdas."
"[Eclipse 4.3.2, Jdk 1.8 build 132, BETA_JAVA8 1.0.0.v20140309-1413]  ECJ does not compile the following class. I had to open it explicitly, otherwise the Eclipse GUI did not complain. Jdk8 (b132) does compile and run it.   import java.util.Arrays; import java.util.Optional;   public class Test { 	     public static void main(String[] args) {         final String s = Arrays.asList(""test"").stream().reduce(null, (s1,s2) -> {                 // THE FOLLOWING LINE CAUSES THE PROBLEM                 require(s1 != null || s2 != null, ""both strings are null"");                     return (s1 != null) ? s1 : s2;             }, (s1,s2) -> (s1 != null) ? s1 : s2); 	         System.out.println(s);      }      static void require(boolean condition, String msg) throws RuntimeException {         if (!condition) {             throw new RuntimeException(msg);         }     }  }   ERROR MESSAGE: Type mismatch: cannot convert from Object to String"
"Using Eclipse 4.3.2, BETA_JAVA8 JDT plugins 1.0.0.v20140309-1413, Eclipse.org, jdk1.8 build 132,  ECJ compiler fails with the ERROR MESSAGE: ""The target type of this expression must be a functional interface"".  This worked a few days before. Jdk8 compiles fine.    import java.util.function.Supplier;  public class Main {  	public static void main(String[] args) { 		 		// This does not compile with ECJ 		test(() -> ""hi""); 		 	} 	 	// Note: when removing this code the main function compiles with ECJ 	static void test(String message) { 	}  	static void test(Supplier<String> messageSupplier) { 	} 	 }"
"NPE trying to disassemble classfile with lambda method and MethodParameters.  ------------------------------ package jsr335.funint;  import java.lang.reflect.Method; import java.lang.reflect.Parameter; import java.util.Arrays; import java.util.function.IntConsumer;  public class Snippet {     IntConsumer xx(int a) {         return i -> { };     }          public static void main(String[] args) {         Method[] methods = Snippet.class.getDeclaredMethods();         Parameter[] parameters = methods[2].getParameters();         System.out.println(Arrays.asList(parameters));     } } ------------------------------  For this snippet, ecj produces a classfile in which the lambda$xx$0(int) method has a MethodParameters attribute whose single parameter has a zero name and the ""synthetic"" flag.  Problems:  1.) Should we really produce a MethodParameters attribute for the lambda? Javac doesn't produce one. 1.1) If yes, should the parameter really be synthetic? The lambda method is already synthetic, and I don't think that should make everything inside it synthetic as well.  2.) Disassembler should not throw an NPE in this case. JVMS8 4.7.24 allows a zero parameter name. javap also supports it, but reflection is broken in 1.8.0-b131.  !ENTRY org.eclipse.e4.ui.workbench 4 0 2014-03-10 14:54:23.741 !MESSAGE  !STACK 0 java.lang.NullPointerException 	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:504) 	at java.lang.StringBuffer.append(StringBuffer.java:314) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:604) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:910) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassembleTypeMembers(Disassembler.java:2382) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:1154) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:261) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.updateCodeView(ClassFileEditor.java:410) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.createControl(ClassFileEditor.java:210) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.verifyInput(ClassFileEditor.java:797) 	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.createPartControl(ClassFileEditor.java:747) 	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:142)"
package jsr335.funint6; interface MyFunction<T, R> {     R apply(T t);      default <V> MyFunction<V, R> compose(MyFunction<? super V, ? extends T> before) {         return (V v) -> apply(before.apply(v)); //        return (v) -> apply(before.apply(v)); // OK     }  }   The lambda parameter v has MyFunction#compose(..) as parent element. If you use the "// OK" variant where v's type V is not explicitly declared, then the parent becomes a LambdaExpression as expected.
- select java.util.function.Function#apply(T) - Search > References > In Hierarchy -> NPE  AFAICS, the problem happens with the lambda in java.util.function.Function#compose(..). The LambdaExpression extends SourceType, although that lambda is actually fo
Spawned from https://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c2  For binary types, the problem from bug 430026 shows up no matter if the lambda parameter does or doesn't declare the type.  Example in java.util.function.IntPredicate:      default IntPredicate and(IntPredicate other) {         Objects.requireNonNull(other);         return (value) -> test(value) && other.test(value);     }  See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c3
"import java.util.function.Consumer;  public class LambdaWithBridge {     interface StringConsumer extends Consumer<String> {         void accept(String t);     }     static void m(String s) { System.out.println(""m(""+s+"")""); }      public static void main(String... x) {       StringConsumer c = LambdaWithBridge::m;       c.accept(""direct call"");       Consumer<String> c4b=c;       c4b.accept(""bridge method"");     } }  and  import java.util.function.Consumer;  public class LambdaWithBridge {     interface StringConsumer extends Consumer<String> {         void accept(String t);     }     public static void main(String... x) {       StringConsumer c = s->System.out.println(""m(""+s+')');       c.accept(""direct call"");       Consumer<String> c4b=c;       c4b.accept(""bridge method"");     } }  produce  m(direct call) Exception in thread ""main"" java.lang.AbstractMethodError: Method LambdaWithBridge$$Lambda$1.accept(Ljava/lang/Object;)V is abstract 	at LambdaWithBridge$$Lambda$1/2536472.accept(Unknown Source) 	at LambdaWithBridge.main(LambdaWithBridge.java:13)  which indicates that the necessary bridge method has not been generated. The compiler must emit code which invokes altMetafactory with FLAG_BRIDGES and the bridge method signatures. An alternative would be creating the bridge method as synthetic default method inside the interface, however, if the interface is not on the build path and originates from a non-Java8 project, the bridge method must be generated for the lambda."
Ref Bug 429571 comment 13. The following needs to be modified/moved to address the issue that these tests cannot run in 1.8  jdt.core.tests.build.IncrementalTests18 (5)- all errors(5) jdt.core.tests.compiler(2) - all failures(2) - GRT_1.7.429203, CDT.test429110 jdt.core.tests.model(8) -All Errors (all tests in NullAnnotationModelTests)
See https://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c0 and https://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c6
"import org.eclipse.jdt.annotation.NonNullByDefault; @NonNullByDefault public class X { 	Y() {}  }  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.fillInDefaultNonNullness18(MethodBinding.java:540) 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:155) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.createArgumentBindings(SourceTypeBinding.java:2004) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1971) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1465) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:853) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1201) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
I have some code that create a Java class that extends a specific interface.  By default the created class and the interface have the same names (though different packages).  Since migrating our product from Indigo to Kepler, it does not produce the same code anymore.  In Indigo, the code produced would be: package pkg1;  class A implements pkg2.A {   ... } => the wizard noticed the type names are the same hence it uses the full classname for the implements.  Now in Kepler we get:  package pkg1;  import pkg2.A  class A implements A {   ... } => error on the import ("The import pkg2.A conflicts with a type defined in the same file" ) and on the implemented A ( "Cycle detected: the type Initial cannot extend/implement itself or one of its own member types" )  The code we use to open the wizard is this: final OpenNewClassWizardAction wizardCreator = new OpenNewClassWizardAction(); final NewClassWizardPage page = new NewClassWizardPage(); page.setTitle(...); page.setDescription(...); page.addSuperInterface("pkg2.A"); page.setTypeName("A", true); final IPackageFragmentRoot root = jproject.getPackageFragmentRoot(jproject.getElementName() + "/src"); page.setPackageFragmentRoot(root, true); final IPackageFragment fragment = root.getPackageFragment("pkg1"); page.setPackageFragment(fragment, false); page.setEnclosingTypeSelection(false, false); page.setMethodStubSelection(false, false, true, false); page.setModifiers(page.F_PUBLIC, false); wizardCreator.setConfiguredWizardPage(page); wizardCreator.run();
JavaElement.JEM_LAMBDA_METHOD should not use '*' and '>' as memento delimiter.  I just saw that the fix for bug 425134 had to make adjustments in MementoTests. That's not good. Existing JavaElement handles should stay as stable as possible, see Javadoc of IJavaElement#getHandleIdentifier(). '*' and '>' were already used by existing mementos, and such stored mementos cannot be parsed any more now.  I see that most "safe" ASCII characters are already used as token delimiters or in token data, but these look free:  &')`  Forbidden character groups: - identifier characters - characters used in Signature (at least for parameter type signatures) - , is IMO risky as well (often used by clients to separate data)  We should also have a test for lambda type and lambda method mementos. I don't think these will be stored often (since they are inherently unstable), but they can be used locally (e.g. to put an element on the clipboard, or for hyperlinks in Javadoc hovers).
"interface I { 	void doit(); }  interface J extends I { 	 }  public class X { 	public static void main(String[] args) { 		J j  = () -> { System.out.println(""Lambda""); }; 		j.doit(); 	} }  Given the above, neither the hierarchy rooted at I nor one rooted at J show the lambda expression."
When writing a generic class as     class Foo<T> {    } we want to be able to instantiate this class as either    Foo<@NonNull String> nns; or    Foo<@Nullable String> nus;  Inside Foo usage of the type variable T should be checked more strictly to reflect that not only the type but also its nullness is unknown. To enable the desired genericity, dereferencing a T value must assume @Nullable and assignment to a T variable must ensure @NonNull.
ATM, under some situations that call for "special" handling, for expediency, we turn a method/constructor into an implicit lambda expression.   See ReferenceExpression.shouldGenerateImplicitLambda(BlockScope) for the situations.  Comment from there says:   // these cases are either too complicated, impossible to handle or result in significant code duplication   We need to revisit this part and arrange for a more direct and so more efficient code generation.
Created attachment 240793 [details] test case as a JavaSearchBugs8Test function  follow up of bug 429498.
API problems in the IType for a lambda:  - getElementName() should return an empty name, like for anonymous types (this is currently specified in the Javadoc of IType, but that should be copied or moved to getElementName()). The current "Lambda(FunctionalInterfaceName)" violates the "simple name" statement in IType#getElementName(). And it make sense not to perform some ad-hoc rendering in jdt.core.  Caveat: Implementation of SourceType#isAnonymous() is:     return this.name.length() == 0  - specify getTypeQualified*(..) APIs for lambda types  - add API isLambda()  - add note in IType Javadoc that ITypes for lambda expressions are pseudo-elements like ILocalVariable that are not returned by getChildren() on their parent
"import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class X { 	void foo(int @NonNull [] x) {} }  Null Pointer Exception. Stack Trace.  LookupEnvironment.createAnnotatedType(TypeBinding, AnnotationBinding[]) line: 976	 	MethodBinding.fillInDefaultNonNullness18(AbstractMethodDeclaration, LookupEnvironment) line: 524	 	ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding, AbstractMethodDeclaration, boolean, Scope) line: 155	 	SourceTypeBinding.createArgumentBindings(MethodBinding, CompilerOptions) line: 2004	 	SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1971	 	SourceTypeBinding.methods() line: 1465	 	SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 853	 	CompilationUnitScope.faultInTypes() line: 424	 	AbstractRegressionTest$26(Compiler).process(CompilationUnitDeclaration, int) line: 764	 	AbstractRegressionTest$26.process(CompilationUnitDeclaration, int) line: 2601	 	AbstractRegressionTest$26(Compiler).compile(ICompilationUnit[]) line: 471	 	NullAnnotationTest(AbstractRegressionTest).runTest(boolean, String[], String[], String[], Map, boolean, ICompilerRequestor, boolean, String, String[], boolean, String[], String, String, ASTVisitor, AbstractRegressionTest$JavacTestOptions) line: 2610	 	NullAnnotationTest(AbstractRegressionTest).runTest(boolean, String[], String[], Map, boolean, ICompilerRequestor, boolean, String, boolean, String[], String, String, AbstractRegressionTest$JavacTestOptions) line: 2429	 	NullAnnotationTest(AbstractRegressionTest).runNegativeTest(String[], String, String[], boolean) line: 2126	 	NullAnnotationTest(AbstractNullAnnotationTest).runNegativeTestWithLibs(String[], String) line: 114	 	NullAnnotationTest.testNullNPETest() line: 7013	 	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	 	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	 	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	 	Method.invoke(Object, Object...) line: 483	 	NullAnnotationTest(TestCase).runTest() line: 176	 	NullAnnotationTest(TestCase).runBare() line: 141	 	TestResult$1.protect() line: 122	 	TestResult.runProtected(Test, Protectable) line: 142	 	TestResult.run(TestCase) line: 125	 	NullAnnotationTest(TestCase).run(TestResult) line: 129	 	RegressionTestSetup(TestSuite).runTest(Test, TestResult) line: 255	 	RegressionTestSetup(TestSuite).run(TestResult) line: 250	 	RegressionTestSetup(CompilerTestSetup).run(TestResult) line: 55	 	TestSuite.runTest(Test, TestResult) line: 255	 	TestSuite.run(TestResult) line: 250	 	JUnit3TestReference.run(TestExecution) line: 131	 	TestExecution.run(ITestReference[]) line: 38	 	RemotePluginTestRunner(RemoteTestRunner).runTests(String[], String, TestExecution) line: 467	 	RemotePluginTestRunner(RemoteTestRunner).runTests(TestExecution) line: 683	 	RemotePluginTestRunner(RemoteTestRunner).run() line: 390	 	RemotePluginTestRunner.main(String[]) line: 62	 	CoreTestApplication.run(Object) line: 23	 	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	 	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	 	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	 	Method.invoke(Object, Object...) line: 483	 	EclipseAppContainer.callMethodWithException(Object, String, Class[], Object[]) line: 587	 	EclipseAppHandle.run(Object) line: 198	 	EclipseAppLauncher.runApplication(Object) line: 110	 	EclipseAppLauncher.start(Object) line: 79	 	EclipseStarter.run(Object) line: 354	 	EclipseStarter.run(String[], Runnable) line: 181	 	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	 	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	 	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	 	Method.invoke(Object, Object...) line: 483	 	Main.invokeFramework(String[], URL[]) line: 636	 	Main.basicRun(String[]) line: 591	 	Main.run(String[]) line: 1450	 	Main.main(String[]) line: 1426   ------------------------------------------------------------------ I will put up the fix in a few minutes."
"The following program does not require bridges, but we request one:  // -- interface K extends I, J { } interface I {     Comparable<Integer> foo(); } interface J {     Comparable foo(); }  public class X { 	public static void main(String[] args) { 		K k = () -> null; 		k.foo(); 	} }  Problem in comparing return types as is to see if they differ - we should compare the erasures - fix will follow shortly."
"Given the following code:  static String readFirstLineFromFile(String path) throws IOException { 	try (BufferedReader br = new BufferedReader(new FileReader(path))) { 		return br.readLine(); 	} }  When using Extract Method on the body of the method, the required parameter ""path"" is not passed to the extracted method:   static String readFirstLineFromFile(String path) throws IOException { 	return readLine(); }  private static String readLine() throws IOException, FileNotFoundException { 	try (BufferedReader br = new BufferedReader(new FileReader(path))) { 		return br.readLine(); 	} }"
Adapt to APIs from bug 430195.
This is what I had during editing:  //--- import java.lang.annotation.*; import java.util.*; import java.util.function.*; import java.util.stream.*; interface MyCollector<T, A, R> extends Collector<T, A, R> { }  public abstract class AnnotationCollector {         abstract <T, K, U, M extends Map<K, U>>      MyCollector<T, ?, M> toMap(Function<? super T, ? extends K> km, BinaryOperator<U> mf);                  void test(Stream<Annotation> annotations) {                 annotations                         .collect(toMap(Annotation::annotationType,                                         (Annotation first, Annotation second) -> first));         }                  Map<String, Person> test2(Stream<Person> persons) {                 return persons.collect(Collectors.toMap((Person p) -> p.getLastName(),                                                                 Function::identity,                                                         (p1, p2) -> p1));         } }  class Person {         String getLastName() { return ""; } } //---  The compiler answer with  java.lang.StackOverflowError at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18.isCompatibleWith(CaptureBinding18.java:123)
"I encountered this problem when I closed and reopened a Type Hierarchy view, but the scenario is not well reproducible because the E4 workbench is very unreliable (bug 430306).  Easier steps in the JavaElement View:  package jsr335.funint6; import java.util.function.IntConsumer; class Test {     void foo() {         IntConsumer c = (i) -> { };     } }  - set input to 'i' and then follow > PARENT > PARENT to get the LambdaExpression - show Properties and copy the handleIdentifier. Mine is this: =zz1.8/src<jsr335.funint6{Test.java[Test~foo)Lambda\(IntConsumer\)""Ljava.util.function.IntConsumer;!125!134!130 - open JavaElement View's view menu and run ""Create from Handle..."" - try to re-create the copied handleIdentifier => fails when trying to access the children of the LambdaExpression element  The problem is that LambdaExpression is not prepared to be restored from a handle memento, since that doesn't restore its lambdaMethod field.  org.eclipse.jdt.internal.core.Member#getHandleFromMemento(..) does this:  LambdaExpression expression = new LambdaExpression(this, name, interphase, sourceStart, sourceEnd, arrowPosition); if (!memento.hasMoreTokens() || (token = memento.nextToken()) != MementoTokenizer.LAMBDA_METHOD)  	return expression;  The end of the called LambdaExpression constructor has a comment // Method is in the process of being fabricated, will be attached shortly. , but the lambdaMethod field is never initialized when the plain LambdaExpression is returned.  I guess the solution has to be that a LambdaExpression always stores the lambda method as well, but we have a different formatting for the LambdaExpression's handleIdentifier (e.g. an additional JEM_LAMBDA_EXPRESSION appended).  !ENTRY org.eclipse.e4.ui.workbench 4 0 2014-03-13 16:19:33.484 !MESSAGE  !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.JavaElement.getChildrenOfType(JavaElement.java:226) 	at org.eclipse.jdt.internal.core.SourceType.getMethods(SourceType.java:418) 	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.isLambdaType(JavaElementLabelComposer.java:1099) 	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendTypeLabel(JavaElementLabelComposer.java:987) 	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendElementLabel(JavaElementLabelComposer.java:287) 	at org.eclipse.jdt.ui.JavaElementLabels.getElementLabel(JavaElementLabels.java:518) 	at org.eclipse.jdt.ui.JavaElementLabels.getElementLabel(JavaElementLabels.java:491) 	at org.eclipse.jdt.internal.ui.typehierarchy.HistoryAction.getShortLabel(HistoryAction.java:111) 	at org.eclipse.jdt.internal.ui.typehierarchy.HistoryAction.getElementLabel(HistoryAction.java:93) 	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.restoreState(TypeHierarchyViewPart.java:1697) 	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.createPartControl(TypeHierarchyViewPart.java:1006) 	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:142) ..."
"interface Func1<T1, R> {         R apply(T1 v1);         void other();     }     @FunctionalInterface // spurious error: F1<T, R> is not a functional interface     interface F1<T1, R> extends Func1<T1, R> {         default void other() {}     }  or more simply:      @FunctionalInterface // spurious error: F2<T, R> is not a functional interface     interface F2<T1, R> extends Func1<T1, R> {     	R apply(T1 v1);         default void other() {}     }  Tested with:    Version: Kepler Service Release 1   Build id: 20130919-0819    Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140312-1826	org.eclipse.jdt.java8patch.feature.group	Eclipse.org"
-------------------- package test1; import java.util.Collection; public class E {     void foo(Collection collection) {         collection     } } --------------------  In BETA_JAVA8, the compiler reports 3 errors for this snippet:  Pb(240) Syntax error, 
Created attachment 240921 [details] This is the project that shows the incremental compile error.  This problem is critical to compiling OpenJFX under Eclipse 8.  0) Start Eclipse 1) Ensure that you have JDK8 with JavaFX as the default JRE    - jfxrt.jar must be on the class path for the project to compile clean 2) Import 'Junk3', the attached project into Eclipse 3) Ensure that it compiles cleanly 4) Edit the method StyleConverter (change "fred55" to "fred5") 5) BUG: Type mismatch: cannot convert from StyleConverter<ParsedValue[],Insets> to StyleConverter<ParsedValue[],Insets> 6) Project->Clean…->Clean all projects 7) The compile error goes away  From memory, I have seen this issue come and go, however, it might be that I was running a really old Eclipse that never had the problem.
"Create in a root of a project a new file called jots.jpage and paste the following in it: String s = ""foo""; s.  On the line ""s."" press Ctrl+Space. This causes an NPE to be logged. I am using fairly recent BETA_JAVA8 plugins and it's possible this might have been fixed in the latest. I'll test this again once I'm up-to-date.  org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.NullPointerException) 	at org.eclipse.swt.SWT.error(SWT.java:4441) 	at org.eclipse.swt.SWT.error(SWT.java:4356) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:139) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1122) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1006) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:146) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:615) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.collectOverriddenMethods(ImplicitNullAnnotationVerifier.java:190) 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.findAllOverriddenMethods(ImplicitNullAnnotationVerifier.java:173) 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:100) 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:112) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.createArgumentBindings(SourceTypeBinding.java:2004) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1971) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1465) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:853) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1920) 	at org.eclipse.jdt.internal.eval.EvaluationContext.complete(EvaluationContext.java:187) 	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:112) 	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:100) 	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:88) 	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.codeComplete(JavaSnippetEditor.java:722) 	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetCompletionProcessor.computeCompletionProposals(JavaSnippetCompletionProcessor.java:104) 	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494) 	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:378) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) 	... 23 more"
Created attachment 240928 [details] Patch to fix failing tests  The following tests are failing with JRE 1.8. They fail because the in 1.8, Iterable.toString has a surrounding "[]". The patch fixes the failing ones:   test002_dash_d_option test003_dash_d_option test005_dash_d_option_custom_file_manager
The Rename Method refactoring breaks lambda expressions (overwrites parameters list and "->").
From here: http://mail.openjdk.java.net/pipermail/type-annotations-spec-comments/2014-March/000071.html  We have a bug that parameter annotations and names don't make it to class files.
"@FunctionalInterface interface FI { 	default int getID() { 		return 11; 	}  	void print(); }  class T { 	FI f2 = () -> System.out.println(super.toString()); // Hover on 'super'	 }  -----------------------------------------  Hover over 'super' in the above"
"class Test { 	void m(int arg) { } } ----------------  - Invoke Change method signature refactoring on method #m. - Select 'arg' in the Name column of wizard (see attached screenshot). - Click 'Close' on wizard with focus on the selected arg.  We get this exception: org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTException: Widget is disposed) 	at org.eclipse.swt.SWT.error(SWT.java:4441) ... ... Caused by: org.eclipse.swt.SWTException: Widget is disposed 	at org.eclipse.swt.SWT.error(SWT.java:4441) 	at org.eclipse.swt.SWT.error(SWT.java:4356) 	at org.eclipse.swt.SWT.error(SWT.java:4327) 	at org.eclipse.swt.widgets.Widget.error(Widget.java:476) 	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348) 	at org.eclipse.swt.widgets.Control.getVisible(Control.java:1661) 	at org.eclipse.jface.viewers.CellEditor.isActivated(CellEditor.java:499) 	at org.eclipse.jface.viewers.CellEditor.focusLost(CellEditor.java:721) 	at org.eclipse.jdt.internal.ui.dialogs.TableTextCellEditor.focusLost(TableTextCellEditor.java:103) 	at org.eclipse.jdt.internal.ui.dialogs.TableTextCellEditor$7$1.run(TableTextCellEditor.java:254) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) 	... 23 more"
"http://download.eclipse.org/eclipse/downloads/drops4/N20140317-2000/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html  testInterfaceUnimplementedMethodBreakpoint	Error	N/A  java.lang.NullPointerException at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:118) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34) 	0.120 testInterfaceStaticMethodBreakpoint	Error	N/A  java.lang.NullPointerException at org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84) at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55) at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255) at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215) at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081) at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053) at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978) at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34) 	0.046 testInterfaceLineBreakpoint	Error	N/A  java.lang.NullPointerException at org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84) at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55) at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255) at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215) at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081) at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053) at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978) at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34) 	0.001 testInterfaceDefaultMethodBreakpoint	Error	N/A  java.lang.NullPointerException at org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84) at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55) at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255) at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215) at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081) at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053) at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995) at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978) at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34)"
"package p1;  import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List;  public class Test { 	public void bar() { 		List<Person> people = new ArrayList<>(); 		Collections.sort(people, Comparator.comparing(Person::get|));  	} }  class Person { 	String getLastName() { 		return null; 	} } -------------------------------------------------------  Replace '|' with caret in the above code and press Ctrl+space.  No proposals are shown."
"public class D_DemoRefactorings { 	 	D_FI fi1= (String value, int n) -> { 		for (int j = 0; j < n; j++) { 			System.out.println(value); 			 		} 	};  	D_F| 	 }  interface D_FI { 	void print(String value, int n); } -------------------------------------------------------------- public class D_DemoRefactorings { 	         D_F|  	D_FI fi1= (String value, int n) -> { 		for (int j = 0; j < n; j++) { 			System.out.println(value); 			 		} 	}; }  interface D_FI { 	void print(String value, int n); } --------------------------------------------------------------  In the above cases, we don't get any proposal on Ctrl+space."
The following snippet does not compile with Java 1.8 using (Java Development Tools) Patch with Java 8 support 1.0.0.v20140317-1956.  It does compile using javac 1.8.0 from Oracle JDK though. (And it also compiles in Eclipse with compatability level 1.7.)  The given error message is added as a comment to the respective line in the code.  public class TestClass {     private static class Alice<A extends Alice<A, B>, B extends Bob>     {     }      public static class Bob     {     }      public void callingMethod()     {         calledMethod(); // error: The method calledMethod() in the type TestClass is not applicable for the arguments ()     }      private <A extends Alice<A, B>, B extends Bob> A calledMethod()     {         return null;     } }
Installed https://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler  Now I get an error  Internal compiler error: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to   org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding at   org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.addConstraintsFromTypeParameters(ConstraintTypeFormula.java:348)  and my project won't compile any more.
Created attachment 241037 [details] Eclipse log containing Java source and error informatino  I wanted to try out functionality of Java 8 in Eclipse.  However a simple Java file makes the compiler crash with an Internal compiler error. Log file is attached which also contains the Java source forcing the crash.  I'm using Java JDK 1.8.0 and Kepler 4.3.2. I have added Java 8 support as described on https://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler
"Given the following code:  public class Main {  	private static class Cls implements Interface { 	}  	private static interface Interface { 		default void hello() { 			System.out.println(""Hello""); 		} 	} }   Do the following:  1. Put the cursor in the body of Cls 2. Type ""hello"" and invoke content assist 3. Select ""Override method in 'Interface'""   Expected: The following is generated:  		@Override 		public void hello() { 		}  Actual: The following is generated:  		@Override 		public default void hello() { 		}  Which leads to the following error (which is confusing, but that's bug 421477):    Default methods are allowed only in interfaces with source level 1.8 or greater."
"Given this:   public class Main {  	private static interface Foo { 		default void hello() { 			System.out.println(""Hello""); 		} 	}  	private static interface Bar extends Foo { 	}  }   Do the following:  1. Put the cursor in the body of Bar 2. Type ""hello"" and invoke content assist 3. Select ""Override method in 'Foo'""   Expected: The following is generated:  		@Override 		public default void hello() { 		}  Actual: The following is generated:  		@Override public default void hello();  Which has the following error:    This method requires a body instead of a semicolon   See also bug 430802 for the case where Bar is a class that implements Foo.  Eclipse: I20140318-0830"
"package com.test;  public class Debug1 {  	public static void main(String[] args) { 		System.out.println(FI.getID()); 	} }  @FunctionalInterface interface  FI { 	static int getID() { 		return 0; 	} 	void foo(); } ------------------------------------------------------  Add a breakpoint at sysout line in #main.  While debugging, select ""FI.getID()"" and press Ctrl+Shift+I to inspect.  We get the message:  ""Cannot send a static message to a non class type object"""
Build ID: N20140320-2000 Platform Windows. Test Results:  http://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_win32.win32.x86_7.0.html  test429110 - 1.7 junit.framework.ComparisonFailure: Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in X.java (at line 7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n 2. ERROR in X.java (at line 7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n  ------------ but was ------------ ----------\n 1. ERROR in X.java (at line 5)\n @Target(ElementType.TYPE_USE)\n ^^^^^^^^\n TYPE_USE cannot be resolved or is not a field\n ----------\n 2. ERROR in X.java (at line 7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n 3. ERROR in X.java (at line 7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n  --------- Difference is ---------- expected:<... in X.java (at line [7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n 2]. ERROR in X.java (a...> but was:<... in X.java (at line [5)\n @Target(ElementType.TYPE_USE)\n ^^^^^^^^\n TYPE_USE cannot be resolved or is not a field\n ----------\n 2. ERROR in X.java (at line 7)\n List<@NonNull String> foo(List<@NonNull String> arg) {\n ^^^^^^^^\n Syntax error, type annotations are available only when source level is at least 1.8\n ----------\n 3]. ERROR in X.java (a...> at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:250) at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:226) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:1074) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2624) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2425) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:2063) at org.eclipse.jdt.core.tests.compiler.parser.ComplianceDiagnoseTest.test429110(ComplianceDiagnoseTest.java:3382) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34)   ==========================================================================  The issue is nightly is run with the JRE 1.7. Generally while 1.8 defects we run the tests with JRE 1.8.   Different set of errors are thrown up in both cases.
Build ID: N20140320-2000 Test Results: http://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html  http://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.model_macosx.cocoa.x86_5.0.html  TestCase AllJavaModelTests TestCase RunAllTests TestCase RunFormatterTests  java.lang.Exception: Could not find plugin "org.eclipse.jdt.core.tests.model"  org.eclipse.test.EclipseTestRunner$TestFailedException: java.lang.Exception: Could not find plugin "org.eclipse.jdt.core.tests.model" at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:587) at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:516) at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1462) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: java.lang.Exception: Could not find plugin "org.eclipse.jdt.core.tests.model" at org.eclipse.test.EclipseTestRunner.loadSuiteClass(EclipseTestRunner.java:604) at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:513)
"Created attachment 241113 [details] The video that records my problem, in .wmv format, in a .zip package.  I was debugging on something like this, there are 3 method breakpoints. The first one didn't work, it seems that Eclipse didn't see it existed. The 2nd and the 3rd worked fine.  I submitted a video attachment as the supplementary description of the problem that I met.  Hope to receive a reply in the near future, Thanks!  public class Foo { 	 	public static <T extends Comparable<T>> int func(T[] arr, int m, int n) { // method breakpoint on func(T[],int,int) 		int i = 0; 		++i; 		++i; 		++i; 		return i; 	} 	 	public static <T extends Comparable<T>> int func(int m, int n) { // method breakpoint on func(int,int) 		int i = 0; 		++i; 		++i; 		++i; 		return i; 	} 	 	public static <T extends Comparable<T>> int func(T t, int m, int n) { // method breakpoint on func(int,int) 		int i = 0; 		++i; 		++i; 		++i; 		return i; 	}  	public static void main(String[] args) { 		int pivot = 0; 		String[] ss = new String[]{""a"",""b""}; 		pivot++; 		pivot++; 		func(ss, 1, 2); // should hit in func(T[],int,int), but unfortunately, no hit 		pivot++; 		pivot++; 		func(1, 2); // hits in func(int,int) 		pivot++; 		pivot++; 		func(""s"", 1, 2); // hits in func(T,int,int) 		pivot++; 		pivot++; 	} 	 }"
"Here's an example demonstrating this issue:  class Constants { 	static final String EXT2_CLASS = "".class""; 	static final String EXT2_JAVA = "".java"";  	enum Replacer2 { 		NILL1(EXT2_CLASS), // inlining EXT2_CLASS doesn't work  		// inlining works here but only within ""EXT2_JAVA""  		NILL2(Constants.EXT2_JAVA);   		String s;  		Replacer2(String s) { 			this.s = s; 		} 	} }  Trying to inline EXT2_CLASS gives a confused info message ""Select a method declaration, a method invocation, a static final field or a local variable that you want to inline."" This happens whether the caret is inside EXT2_CLASS without any text selected or if the EXT2_CLASS text is selected.  Trying to inline EXT2_JAVA works but only within the range mentioned above. Selecting the whole ""Constants.EXT2_JAVA"" text and trying to inline fails with the above message.  Tested with Eclipse Version: Luna (4.4) Build id: Y20140315-2100"
Created attachment 241252 [details] Source file  When running the following class, you get a verify error:  public class Java8VerifyError {     public static class Foo {         public Object get() {             return new Object();         }     }          @FunctionalInterface     public static interface Provider<T> {         public T get();     }          public static void main(String[] args) {         Provider<Foo> f = () -> new Foo();                  Provider<Provider<Object>> meta = () -> f.get()::get;         System.out.println(meta);     } }  Exception in thread "main" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     Java8VerifyError.lambda$1(LJava8VerifyError$Provider;)LJava8VerifyError$Provider; @6: invokedynamic   Reason:     Type 'java/lang/Object' (current frame, stack[0]) is not assignable to 'Java8VerifyError$Foo'   Current Frame:     bci: @6     flags: { }     locals: { 'Java8VerifyError$Provider' }     stack: { 'java/lang/Object' }   Bytecode:     0000000: 2ab9 0033 0100 ba00 3a00 00b0  Work around:          Provider<Provider<Object>> meta = () -> {             Foo foo = f.get();             return foo::get;         };
When JavaElement8Tests is run with JRE 1.7, test430033() is failing because it's 1.8 specific test. These tests being specific to 1.8 level, are better disabled at levels 1.7 and below.
In Luna builds, we only generate Javadoc for the org.eclipse.jdt.annotation project (2.0.0), but not for the old 1.1.0 version.  We can't just add org.eclipse.jdt.annotation_v1 to jdtOptions.txt, since the Javadoc tool can't handle multiple versions (second version just overrides previous files).  I see two possible solutions:  a) generate Javadoc for 1.1.0 separately, and then try to insert links into the generated TOC from the main Javadoc build  b) add a link to the old version to the the current Javadocs, e.g.:  * <p>  * <b>Note:</b> Since org.eclipse.jdt.annotation 2.0.0, the  * <code>@Target</code> is <code>{TYPE_USE}</code>. See  * <a href="http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html">  * <code>@NonNull</code> in 1.1.0</a>  * </p>  I prefer (b), but I'd like to hear others' opinions.  See also bug 431236 (need to use Java 8 to generate Javadocs).
Test org.eclipse.jdt.apt.tests.ReadAnnotationTests.test1() is failing, the results being here:  http://download.eclipse.org/eclipse/downloads/drops4/N20140325-2000/testresults/html/org.eclipse.jdt.apt.tests_macosx.cocoa.x86_64_7.0.html  The testcase involved is: /org.eclipse.jdt.apt.tests/src-resources/question/AnnotationTest.java  Expected value for one of the annotations used is:  @RTVisibleAnno(name = Foundation, boolValue = false, byteValue = 16, charValue = c, doubleValue = 99.0, floatValue = 9.0, intValue = 999, longValue = 3333, shortValue = 3, colors = {RED, BLUE}, anno = @SimpleAnnotation(value = core), simpleAnnos = {@SimpleAnnotation(value = org), @SimpleAnnotation(value = eclipse), @SimpleAnnotation(value = jdt)}, clazzes = {java.lang.Object, java.lang.String}, clazz = java.lang.Object)  But actual is: @RTVisibleAnno(name = Foundation, boolValue = false, byteValue = 16, charValue = c, doubleValue = 99.0, floatValue = 9.0, intValue = 999, longValue = 3333, shortValue = 3, colors = {}, anno = @SimpleAnnotation(value = core), simpleAnnos = {@SimpleAnnotation(value = org), @SimpleAnnotation(value = eclipse), @SimpleAnnotation(value = jdt)}, clazzes = {java.lang.Object, java.lang.String}, clazz = java.lang.Object)  Notice the attribute 'colors' being an empty array. Investigated a bit and found out that in the failing case, the ElementValuePair#value is a UnresolvedEnumConstant. Back in the history when it was passing, it was a FieldBinding.  And this is a very recent regression caused by this commit:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=43cdae5117454d896e9e9cf435f63b0b509e3a4c  Stephan, please let me know if you have some clues on what might be happening.
"Eclipse Kepler with Java 8 compiler installed. Changing an annotation threw:  java.lang.StackOverflowError         at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:130)         at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:114)         at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:505)         at java.lang.StringBuffer.append(StringBuffer.java:314)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1099)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)         at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.nullAnnotatedReadableName(TypeVariableBinding.java:728)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1116)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.nullAnnotatedReadableName(ParameterizedTypeBinding.java:1085)  etc. The annotation that was changed during the save was the @Nonnull annotation also configured to do null checking.  After restart the problem persists, with the problems log showing: Description	Resource	Path	Location	Type Internal compiler error: java.lang.StackOverflowError at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.appendNullAnnotation(ReferenceBinding.java:1593)	ConfigNodeFragment.java	/to.etc.saram.core/src/to/etc/saram/xtool/ui	line 0	Java Problem"
An adopter product (IBM) than runs in headless mode is hitting a deadlock with monitors org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo and org/eclipse/jdt/internal/core/DeltaProcessingState. This product started to hit this deadlock with JDT 3.6.50.v_B79_R36x_J7 (org.eclipse.jdt.core_3.6.50.v_B79_R36x_J7.jar). They did not see this deadlock when they were using 3.6.4.v_A79_R36x (org.eclipse.jdt.core_3.6.4.v_A79_R36x).   I noticed that the patch in bugzilla https://bugs.eclipse.org/bugs/show_bug.cgi?id=338006 was put into the stream between those two versions (although the bugzilla was targeted to 3.7. maybe was backported), and the code added there appears in all the stack traces I have collected (specifically, the call to the new method DeltaProcessor.addPackageFragmentRoot in DeltaProcessor.addToParentInfo).   BTW, I compared the code with the latest code in master, and the code path involved in these stacks has not changed, so I believe this could happen in master as well.   Below are the stack traces.   Thread Name Worker-2 State Deadlock/Blocked Monitor Owns Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8  Waiting for Monitor Lock on org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008 Java Stack at org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1956)  at org/eclipse/jdt/internal/core/PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:563)  at org/eclipse/jdt/internal/core/DeltaProcessor.addPackageFragmentRoot(DeltaProcessor.java:325)  at org/eclipse/jdt/internal/core/DeltaProcessor.addToParentInfo(DeltaProcessor.java:297)  at org/eclipse/jdt/internal/core/DeltaProcessor.elementAdded(DeltaProcessor.java:1156)  at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2483)  at org/eclipse/jdt/internal/core/DeltaProcessingState.updateRoots(DeltaProcessingState.java:621)  at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2479)  at org/eclipse/jdt/internal/core/DeltaProcessor.traverseDelta(DeltaProcessor.java:2206)  at org/eclipse/jdt/internal/core/DeltaProcessor.processResourceDelta(DeltaProcessor.java:1894)  at org/eclipse/jdt/internal/core/DeltaProcessor.resourceChanged(DeltaProcessor.java:2067)  at org/eclipse/jdt/internal/core/DeltaProcessingState.resourceChanged(DeltaProcessingState.java:470)  at org/eclipse/core/internal/events/NotificationManager$2.run(NotificationManager.java:291)  at org/eclipse/core/runtime/SafeRunner.run(SafeRunner.java:42)  at org/eclipse/core/internal/events/NotificationManager.notify(NotificationManager.java:285)  at org/eclipse/core/internal/events/NotificationManager.broadcastChanges(NotificationManager.java:149)  at org/eclipse/core/internal/resources/Workspace.broadcastPostChange(Workspace.java:327)  at org/eclipse/core/internal/resources/Workspace.endOperation(Workspace.java:1181)  at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1984)  at org/eclipse/core/internal/events/NotificationManager$NotifyJob.run(NotificationManager.java:40)  at org/eclipse/core/internal/jobs/Worker.run(Worker.java:54)    Thread Name main State Deadlock/Blocked Monitor Owns Monitor Lock on org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008  Waiting for Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8 Java Stack at org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.addClasspathChange(JavaModelManager.java:1209)  at org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setClasspath(JavaModelManager.java:1190)  at org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setResolvedClasspath(JavaModelManager.java:1229)  at org/eclipse/jdt/internal/core/JavaProject.resolveClasspath(JavaProject.java:2859)  at org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1991)  at org/eclipse/jem/workbench/utility/JemProjectUtilities.collectClasspathURLs(JemProjectUtilities.java:452)  at org/eclipse/jem/workbench/utility/JemProjectUtilities.getClasspathAsURLArray(JemProjectUtilities.java:436)  ... (Adopter code) ... at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1975)  at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1957)  ... (Adopter code) ... at sun/reflect/NativeMethodAccessorImpl.invoke0(Native Method)  at sun/reflect/NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)  at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)  at java/lang/reflect/Method.invoke(Method.java:611)  at org/eclipse/equinox/internal/app/EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)  at org/eclipse/equinox/internal/app/EclipseAppHandle.run(EclipseAppHandle.java:198)  at org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)  at org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.start(EclipseAppLauncher.java:79)  at org/eclipse/core/runtime/adaptor/EclipseStarter.run(EclipseStarter.java:369)  ... (Adopter code)
org.eclipse.jdt.core search API got wrong result, when searching for method references, where the parameter is a member type of another type.  For example:  interface MyIF {     // Search result of method query(Foo.InnerKey) returns the method query(Bar.InnerKey) too     public void query(Foo.InnerKey key);      public void query(Bar.InnerKey key); }   class Foo {     static class InnerKey  {} }  class Bar {     static class InnerKey {} }    * Here is a discussion on stackoverflow: http://stackoverflow.com/questions/22317878/eclipse-open-call-hierarchy-got-wrong-result  * It seems that the bug was introduced by fixing JDT Bug 41018. https://bugs.eclipse.org/bugs/show_bug.cgi?id=41018
"Using this code:  import java.util.function.Predicate;  public class Snippet { 	private static void writeIt(Object list) { 		list = replace(s -> true); 		Object asList = null; 		if(Boolean.TRUE) { 			// activating content assist on ""asli"" causes NPE 			Object s = removeAll(asli); 		} 	}  	private static Object replace(Predicate<String> tester) { return tester; } 	Object removeAll(Object o1) { return o1; } }  Trying to complete asli to asList causes a warning message dialog to show up and an NPE is logged in error view.  Tested with Eclipse SDK Version: Luna (4.4) Build id: Y20140315-2100  Here is the stack trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.triggerRecoveryUponLambdaClosure(AssistParser.java:483) 	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.consumeInvocationExpression(CompletionParser.java:4010) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeMethodInvocationName(Parser.java:5283) 	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.consumeMethodInvocationName(AssistParser.java:562) 	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.consumeMethodInvocationName(CompletionParser.java:2925) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6955) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11019) 	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.parseSomeStatements(CompletionParser.java:4842) 	at org.eclipse.jdt.internal.codeassist.UnresolvedReferenceNameFinder.findBefore(UnresolvedReferenceNameFinder.java:210) 	at org.eclipse.jdt.internal.codeassist.UnresolvedReferenceNameFinder.findBefore(UnresolvedReferenceNameFinder.java:176) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findUnresolvedReferenceBefore(CompletionEngine.java:11348) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findUnresolvedReference(CompletionEngine.java:11248) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3276) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1712) 	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1938) 	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357) 	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345) 	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244) 	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:206) 	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63) 	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333) 	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337) 	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:325) 	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:282) 	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494) 	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:183) 	at org.eclipse.ui.texteditor.ContentAssistAction$1.run(ContentAssistAction.java:82) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.texteditor.ContentAssistAction.run(ContentAssistAction.java:80) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:153) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:222) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:505) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:556) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:377) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:323) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:85) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)"
I'm using Eclipse 4.3.2 with the Java 8 patch. We have the following code, which compiled just fine in Eclipse 4.3.2 with Java 7. This also compiles fine with the Oracle JDK 8 compiler using Maven.  protected <V> CustomNamedTypedProperty<V, ? extends CustomType<V>> parseHeaderField(int fieldIndex, String headerField) throws FileFormatException {   CustomNamedTypedProperty<V, ? extends CustomType<V>> prop = super.parseHeaderField(fieldIndex, headerField);  Eclipse gives the following error:  Type mismatch: cannot convert from CustomNamedTypedProperty<Object,capture#1-of ? extends CustomType<Object>> to CustomNamedTypedProperty<V,? extends CustomType<V>>  Obviously if I call the superclass version of a method, I expect to be able to store its return value in a variable of the same type as the return type. This should be self-evident, even without know the hierarchy of the types in question. But to help track down the bug, here are some more (abridged) definitions:  public class CustomNamedTypedProperty<V, T extends CustomType<V>> extends DefaultNamedTypedProperty<V> implements NamedTypedProperty<V>  interface CustomType<V> extends NamedTypedProperty<V>  interface NamedTypedProperty<V> extends Named, TypedProperty<V>  interface TypedProperty<V> extends Property, Typed<V>  (Note that there are several other lines in our that exhibit similar generics compatibility problems, even though they compiled fine in Java 7.)
A year ago I stumbled upon a bug in JDT, analyzed it and filed an issue at https://bugs.eclipse.org/bugs/show_bug.cgi?id=414285 I believed the solution to be trivial but did not dare to try fixing the bug because I could not build and test my solution. When I saw that this bug was removed from Eclipse 4.4 plans, I tried again and after about an hour managed to submit a patch to gerrit. However, I'm still unable to build and verify the patch.  There are two contributor guides I've found so far:  - http://wiki.eclipse.org/Debug/Developers  - https://wiki.eclipse.org/JDT_Core_Committer_FAQ  - http://wiki.eclipse.org/Platform-releng  The first one starts with a suggestion to connect to CVS which is plain pathetic. The second one is somewhat useful, but suggests to directly clone eclipse.jdt.*.git repos which won't work since all pom.xml:s contain ../eclipse-platform-parent reference. I'm now trying to follow instructions at http://wiki.eclipse.org/Platform-releng/Platform_Build#Build_environment_setup and will see how they would work out. However, I'm still not sure if it is possible to build Eclipse outside eclipse.org build servers without spending a lot of time on tweaking environment and writing scripts.  All-in-all, I've now spent several hours searching for information and testing different approaches. I believe this is too much for an average person to even bother contributing to JDT, which means the project looses would-be contributors. A proper contributor guide should answer all the questions above, and make it easier to contribute to JDT Debug. I think a common guide for Platform + JDT + PDE would also make sense but since my problem was specific to JDT debug, I file it here.  For inspiration see these guides:  - http://wiki.eclipse.org/Tycho/Contributor_Guide  - http://wiki.eclipse.org/EGit/Contributor_Guide  - http://wiki.eclipse.org/EMF_Compare/Contributor_Guide  - http://wiki.eclipse.org/GEF/Contributor_Guide  - https://www.kernel.org/doc/Documentation/HOWTO
Add UI for finegrain IJavaSearchConstants#JAVA8_METHOD_REFERENCE from bug 429012 and test the functionality.
Please see: Bug 405026, Comment 30  Consider the test case TypeResolveTests#test405026b  The following API call fails to return the correct result:  itype = nameLookup.findType("test1", packageFragments[0], true, NameLookup.ACCEPT_ALL, false, false); assertEquals("test13", itype.getElementName());  // Fails Here  -------------------------------------------- itype.getElementName() -> test13Outer --------------------------------------------  This is invalid as considerSecondaryTypes is set to false.  Once this is resolved please add the two test cases which were removed as part of http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=8aae944f1fec216ec7aa5c56aa9511065ae60c18.  This defect is reproducible with 1.7 32 bit JRE.  Thanks
"package test1;  class C1 { 	void fun1(int x) { 		int c; 		class Inner { 			FI test = () -> { 				try { 				} catch (Exception c) { 					int x; 				} 			}; 		} 	} }  interface FI { 	void foo(); } --------------------------------------------------------------------------  The above code compiles with b132 but gives compilation error with ECJ at ""int x;"" in catch clause: Lambda expression's local variable x cannot redeclare another local variable defined in an enclosing scope."
The documentation from bug 364820 & bug 380074 must be updated to reflect that in 1.8 these are now type annotations. Also needed: - migration hints - documentation of the attribute of @NonNullByDefault  Some of this can be handled by referring to the annotations' javadoc.
"Running this snipped in Eclipse Kepler SR2 with official JAVA8 plugins produces an error (see below). Running it on the command-line with 1.8.0_20-ea-b05 works fine.   import java.util.function.Function; import java.util.function.IntFunction;  public class Test<R> {  	public static void main(String[] args) { 		new Test<>().test((Integer i) -> null); 	}  	// this method should be called 	<T> void test(Function<T, R> f) { 	}  	// BUG: the presence of this method causes problems 	void test(int i, IntFunction<R> f) { 		// WORKAROUND: casting i to (Integer) i 		new State<>(new Val<>(i)); 	} 	 	static class State<R> { 		State(Val<?> o) { 		} 	} 	 	static class Val<T> { 		Val(T t) {} 	}  }"
Created attachment 241421 [details] test file  Hello  My version of Eclipse compiles the file but it's wrong  Version: Luna (4.4) Build id: I20140325-0830
"package npe_oejic_LambdaMethod_getTypeSignature_line_97; With this code having compile errors, trying to inline method toLongFunction results in an NPE:  package npe_oejic_LambdaMethod_getTypeSignature_line_97;  import java.util.function.ToLongFunction; import java.util.stream.Stream;  public interface Streamy<T> { 	public static <T> ToLongFunction<? super T> toLongFunction() { 		return null; 	}  	default void asIntStream(Stream<T> makerget) { 		makerget.mapToInt((long l) -> (int) l); 		// trying to inline this method results causes NPE 		toLongFunction(); 	} }  Originally the asIntStream method was two separate methods in the same order, but for a shorter test case this wasn't a necessary thing to keep. I am using all warnings (almost), in case it makes a difference.  Tested with Eclipse SDK Version: Luna (4.4) Build id: I20140325-0830 and JDT Core plugin build from from HEAD in the last few days.  Here is the full stack trace:  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:423) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:637) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455) 	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:466) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:619) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:832) 	at org.eclipse.jface.window.Window.open(Window.java:808) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122) 	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38) 	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startInlineMethodRefactoring(RefactoringExecutionStarter.java:330) 	at org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.tryInlineMethod(InlineMethodAction.java:148) 	at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:124) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.GeneratedMethodAccessor51.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:209) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:505) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:556) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:377) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:323) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:85) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529) 	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722) 	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1116) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1000) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1462) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438) Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.LambdaMethod.getTypeSignature(LambdaMethod.java:95) 	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:51) 	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:45) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:213) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:167) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:488) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:822) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProject(IndexBasedHierarchyBuilder.java:227) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPotentialSubtypes(IndexBasedHierarchyBuilder.java:329) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:132) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:829) 	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:787) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkOverridden(InlineMethodRefactoring.java:471) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:285) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)"
Javadoc links to classes within the Javadoc of overridden methods in my Eclipse Workspace do not active when built from a .jar file. Instead, they go to a "This page can't be displayed" screen in my Javadoc window and Javadoc tooltips.  These same links work perfectly in the browser for my documentation (I'm using Chrome) and when the project is not built from the .jar but is viewed in the developer's workspace. This problem is critical because users building from a .jar file cannot view public documentation intentionally made available to them in their Eclipse Workspace.
Created attachment 241511 [details] Test project  We have a test in Xtext that fails on the current 4.4 integration build because annotations on constructors are interpreted as type use annotations and as such no longer returned by IMethodBinding.getAnnotations(). The annotation does not have a @Target.  As we neither compile nor execute against Java8 this is a regression.   I've attached a test project: The (plug-in) test fails as long as the @Target is not defined on MyAnnotation.
Content assist should propose keyword 'super' in the places it appears in this snippet:  public class Main implements Intf {     class Inner {         {             Main.super.hashCode();         }     }     @Override     public void foo() {         Intf.super.foo();     } }  Implementation hint: Looks like keyword 'this' is implemented here: org.eclipse.jdt.internal.codeassist.CompletionEngine.findMembers(char[], ReferenceBinding, Scope, InvocationSite, boolean, Binding[], int[], int[], boolean)
With the solution in bug 390889 (if that strategy stays) much of the arduous tweak from bug 388800 comment 21 [1] might actually be obsolete now.  I'll use this bug to investigate what can be removed / reverted.  [1] http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=dd3bff4d99a5193497eb7e3c0e1bc46a32b7c36a
"From bug 420116 comment 9, consider the below code snippet: interface A { 	int foo2C(Object @NonNull [] @Nullable... o2); }   parameter#getTypeAnnotations() invoked on o2 returns only @NonNull annotation which results in:  class C implements A {  	@Override 	public int foo2C(Object[] @NonNull... o2) { // @Nullable is missing 		// TODO Auto-generated method stub 		return 0; 	} }"
"Paste the snippet below and then delete the line     /** that starts the Javadoc. => ASTParser crashes with an IAE  Originally happened when I tried to edit org.eclipse.jdt.internal.corext.util.JavaModelUtil#getResolvedTypeName(String, IType)  Snippet:  package xy; public class Crashing {     /**      * Delete line '/**' above.      *      * @param a (for example 'QVector')      * @param declaringMember the context for resolving (made in)      * @return if      */     void foo() {     } }  java.lang.IllegalArgumentException 	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:506) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161) 	at ..."
The Javadoc tool for Java SE 8 changed the anchor syntax and now tries to avoid "strange" characters in URLs by replacing them with "-" or ":A" (for "[]").  This breaks all clients that directly create such URLs. We can't know what format is required (at least without pre-loading the generated Javadoc), so we just guess by the project's compiler compliance.
"Eclipse shows an error in the flatten2 method:  Type mismatch: cannot convert from Stream<Object> to Stream<? extends Integer>  The editor also shows this in the hover for the bug marker:  Multiple markers at this line   - Type mismatch: cannot convert from Stream<Object> to Stream<? extends Integer>   - (Recovered) Internal inconsistency detected during lambda shape analysis  javac compiles the code with no warnings or errors.  $ java -version java version ""1.8.0"" Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode) $ javac -version javac 1.8.0   Eclipse Java EE IDE for Web Developers.  Version: Kepler Service Release 2 Build id: 20140224-0627  With:    Eclipse JDT (Java Development Tools) Patch with Java 8 support (for Kepler SR2)	1.0.0.v20140317-1956	org.eclipse.jdt.java8patch.feature.group	Eclipse.org   Eclipse PDE (Plug-in Development Environment) Patch with Java 8 support (for Kepler SR2)	1.0.0.v20140317-1956	org.eclipse.pde.java8patch.feature.group	Eclipse.org  Demonstration code follows ---  import java.util.List; import java.util.function.Function; import java.util.stream.Stream;  class Bug {     // fully inline     // compiles successfully     Stream<? extends Integer> flatten1(         final Stream<List<Integer>> input)     {         return input.flatMap(item -> item.stream().map(value -> value));     }      // lambda using braces     // compiles with error in eclipse, successfully with javac     Stream<? extends Integer> flatten2(         final Stream<List<Integer>> input)     {         return input.flatMap(item -> {             return item.stream().map(value -> value);         });     }      // without map step     // compiles successfully     Stream<? extends Integer> flatten3(         final Stream<List<Integer>> input)     {         return input.flatMap(item -> {             return item.stream();         });     }      // with map step, but not inline     // compiles successfully     Stream<? extends Integer> flatten4(         final Stream<List<Integer>> input)     {         return input.flatMap(item -> {             final Function<? super Integer, ? extends Integer> mapper = value -> value;             return item.stream().map(mapper);         });     }      // with map step, but outer lambda is not inline     // compiles successfully     Stream<? extends Integer> flatten5(         final Stream<List<Integer>> input)     {         final Function<? super List<Integer>, ? extends Stream<? extends Integer>> func = item -> {             return item.stream().map(value -> value);         };         return input.flatMap(func);     } }"
"I had imported ""org.eclipse.jdt.ui.tests"" in my runtime workspace. Open ReturnTypeQuickFixTest.java and hover over IJavaProject  in ""private IJavaProject fJProject1;"" the below exception is thrown. From the stack trace it looks like a regression from the recent fix for bug 432056. No exception is thrown when hovering over ""StringBuffer"" or ""List"". Whereas exception was consistently thrown when hovering over ""IJavaProject"", ""IJavaElement"", ""ICompilationUnit"" etc.  java.lang.IllegalArgumentException: URI is not absolute 	at java.net.URI.toURL(URI.java:1088) 	at org.eclipse.jdt.internal.corext.javadoc.JavaDocLocations.getJavadocLocation(JavaDocLocations.java:544) 	at org.eclipse.jdt.ui.JavaUI.getJavadocLocation(JavaUI.java:985) 	at org.eclipse.jdt.internal.corext.javadoc.JavaDocLocations.getBaseURL(JavaDocLocations.java:635) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:694) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:607) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:599) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
Consider this code:     public static  void method(Collection<? extends Number> coll) { /* ... */ }    public static void main(String[] args) {     method(Collections.EMPTY_LIST);   }  The "method" call comes with a warning: "Type safety: The expression of type List needs unchecked conversion to conform to Collection<? extends Number>". The quick fix (which, btw, I appreciate very much in non-generic situations) replaces it with      method(Collections.<? extends Number> emptyList());  which is a compile error. It should be Collections<Number>, or more generally the lower bound for the generic type parameter (e.g. Object in case of the type argument simply being <?>).   Of course, there is no obvious quick fix if there are multiple bounds as in the following line, so probably no quick fix should be attempted here:    public static <T extends Number & Comparable<?>> void method2(Collection<T> coll) { /* ... */ }
http://download.eclipse.org/eclipse/downloads/drops4/N20140406-2000/testresults/html/org.eclipse.jdt.ui.tests_win32.win32.x86_7.0.html  There are 4 test failures in AddUnimplementedMethodsTest which can be reproduced by running the tests locally in workspace also.  However, these are not reproducible while performing the Override methods action in runtime.
"Created attachment 241686 [details] workaround  Try to extract ""Collections.emptyList()"" into a local variable here:  package p; import java.util.*; public class C1 {     public static <T extends Number & Comparable<?>> void method2(Collection<T> coll) {}      public static void main(String[] args) {         method2(Collections.emptyList());     } }  java.lang.IllegalArgumentException: Invalid identifier : >Comparable & Number< 	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:199) 	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:2202) 	at org.eclipse.jdt.core.dom.AST.newName(AST.java:1929) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.createBaseType(ImportRewrite.java:1237) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:1291) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:756) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:1307) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:756) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempType(ExtractTempRefactoring.java:894) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempDeclaration(ExtractTempRefactoring.java:696) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createAndInsertTempDeclaration(ExtractTempRefactoring.java:667) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempDeclaration(ExtractTempRefactoring.java:760) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.doCreateChange(ExtractTempRefactoring.java:549) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.checkFinalConditions(ExtractTempRefactoring.java:492)   The underlying problem is bug 99931, but we should try to avoid the IAE when dealing with IntersectionCastTypeBindings. The easiest solution I see is to use the same workaround in TypeBinding#getName() as already done in IntersectionCastTypeBinding#constantPoolName() and visible via TypeBinding#getKey(): Just pick one of the intersectingTypes. While this is not correct, it at least meets the expectation of callers (get a single identifier)."
If I have the debugger running, and I use git to switch to a different branch, the "Hot Code Replace Failed" dialogue comes up. If I ignore it and continue working, and later switch to yet another branch (or back to the original), Eclipse will pop up another copy of the "Hot Code Replace Failed" dialogue, which completely occludes the original box.   At this point, only the original (hidden) dialogue box is active, but it's hidden. clicking on the second dialogue box gets no response.   You have to move the dialogue box in order to find the original.   This can happen multiple times, and the boxes have to be closed in FIFO order.
Javadoc for 1.3 and 1.4 has been archived at http://docs.oracle.com/javase/1.4.2/docs/api/ and http://docs.oracle.com/javase/1.3/docs/api/ , and the individual html pages are no longer available.  http://docs.oracle.com/javaee/1.4/api/javax/enterprise/deploy/shared/ActionType.html is still available, but the link to http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html also results in a 404 or timeout.
"I've installed the Kepler java 8 feature patch, and I'm using the latest null annotations jar (version 2.0.0, that came with the java 8 patch).  The following piece of code used to compile when my project was using Java 7, and the previous null annotations jar (1.1.0):   	public static @NonNull <T> T assertNotNull(@Nullable T object) { 		return assertNotNull(null, object); 	}  	public static @NonNull <T> T assertNotNull(@Nullable String message, @Nullable T object) { 		if (object == null) { 			throw new NullPointerException(message); 		} 		return object; 	}   After upgrading the project to Java 8, and upgrading the null annotations jar to 2.0.0, the statement  		return assertNotNull(null, object);  gives the following compiler error:  ""Contradictory null annotations: method was inferred as '@NonNull @Nullable T assertNotNull(@Nullable String, @Nullable T)', but only one of '@NonNull' and '@Nullable' can be effective at any location	""  If I replace the 2.0.0 jar with the 1.1.0 jar, it works again. This is not a solution however, since the old jar does not support type annotations."
The Javadoc 8 tool has replaced certain special characters in method anchors with other characters. This breaks the implementation of IMethod#getAttachedJavadoc(..) in JavadocContents.  I've filed a bug for Oracle for the breaking change (Review ID: JI-9011589).
"I have upgraded my project from Java 1.7 to 1.8, performing the following steps:  1) Select JavaSE-1.8 as system libraray in the build path 2) Set compiler compliance level to 1.8 3) Changed the JDT null annotations library from 1.1.0 to 2.0.0 4) Changed the version of the Java facet to 1.8  Building the project results in a seemingly endless popping up of 'Problem occurred' dialogs. In the error log, there is one error that keeps appearing that includes a hopefully useful stacktrace:  Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". Java Model Exception: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206) Caused by: java.lang.NullPointerException Caused by: java.lang.NullPointerException  What might be useful to know is that when I skip step 3 (I'm using the 1.1.0 null annotations library), these errors don't appear, but many errors about null type mismatches appear, which are not there when compiling against 1.7. But then, this might be caused by the illegal (?) combination of java 1.8 and null annotations library 1.1.0 -- I'm not sure.  One final remark: I've successfully upgraded other projects to 1.8, which are also using null annotations, but this project is the only one that is using facets. It might have something to do with it."
"Created attachment 241815 [details] error dialog  When compiling a piece of code (which contains errors) using jdk1.8.0 the compilation process stops with the attached error dialog.   I've noticed the following things: - Compilation using jdk1.6.0_45 is working. - Compilation works when the compiler compliance level is set to 1.6 (using jdk1.8.0). - Compilation works when the compiler compliance level is set to 1.7 (using jdk1.8.0).  I can reproduce this bug on a different computer (with the same eclipse version and sources)  The following stack trace was logged:  !ENTRY org.eclipse.core.resources 4 75 2014-04-10 09:56:07.706 !MESSAGE Errors occurred during the build. !SUBENTRY 1 org.eclipse.jdt.core 4 75 2014-04-10 09:56:07.706 !MESSAGE Errors running builder 'Java Builder' on project 'OffsiteSuite'. !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.computeConversion(MessageSend.java:378) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.computeConversions(ConditionalExpression.java:663) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.checkAgainstFinalTargetType(ConditionalExpression.java:723) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:738) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5131) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1294) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1880) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:668) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1317) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:771) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)"
"If I rename the mul() method to mulx() in following code: public class Test02 { 	private static class Multiplier { 		private final long mMul;  		public Multiplier(long iMul) {  			this.mMul = iMul; 		} 		public Long mul(Long iItem) { 			return iItem * mMul; 		} 	} 	private static void test(UnaryOperator<Long> iFn) { 	} 	public static void main(String[] args) { 		UnaryOperator<Long> mul = (new Multiplier(3))::mul;  		test((new Multiplier(3))::mul); 	} } it renames the 'Multiplier' constructor in both (new Multiplier(3))::mul occurrences. The result is (new mulx(3))::mul But preview during renaming looks good, i.e. all occurrences of method name are found well just final renaming fails.  Used Eclipse 4.3.2 with Eclipse JDT (Java Development Tools) Patch with Java 8 support (for Kepler SR2) 1.0.0.v20140317-1956"
"Created attachment 241841 [details] failing test case  If you try to run the attached code in eclipse it will fail with the following stacktrace:  Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception 	at java.lang.invoke.CallSite.makeSite(CallSite.java:328) 	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:296) 	at eclipsebug.DuplicateMethodBug.main(DuplicateMethodBug.java:8) Caused by: java.lang.ClassFormatError: Duplicate method name&signature in class file eclipsebug/DuplicateMethodBug$$Lambda$1 	at sun.misc.Unsafe.defineAnonymousClass(Native Method) 	at java.lang.invoke.InnerClassLambdaMetafactory.spinInnerClass(InnerClassLambdaMetafactory.java:324) 	at java.lang.invoke.InnerClassLambdaMetafactory.buildCallSite(InnerClassLambdaMetafactory.java:194) 	at java.lang.invoke.LambdaMetafactory.altMetafactory(LambdaMetafactory.java:473) 	at java.lang.invoke.CallSite.makeSite(CallSite.java:301) 	... 2 more  Compiling it with standard javac and running it works as expected. The problem is the generic interface Provider<T> which extends ParentProvider<T>.  As soon as you remove the extends clause from the Provider<T> interface everything works fine.  The version is Eclipse Kepler SR 2 with the Eclipse JDT Patch with Java 8 support version 1.0.0.v20140317-1956.  Best regards,  Florian"
"The following class will not load with due to:  Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     Y.<init>()V @2: invokedynamic   Reason:     Type uninitializedThis (current frame, stack[1]) is not assignable to 'Y'   Current Frame:     bci: @2     flags: { flagThisUninit }     locals: { uninitializedThis }     stack: { uninitializedThis, uninitializedThis }   Bytecode:     0000000: 2a2a ba00 0b00 00b7 000c b1              	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688) 	at java.lang.Class.getMethod0(Class.java:2937) 	at java.lang.Class.getMethod(Class.java:1771) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)     The class:  import java.util.function.Supplier;  class E { 	E(Supplier<Object> factory) { } }  public class Y extends E { 	Y() { 		super(() -> new Object() { 		}); 	} 	public static void main(String[] args) { 		new Y(); 	} }    If I convert the lambda to anonymous class, it works."
"I have the following error in my error log  eclipse.buildId=4.4.0.I20140318-0830  An internal error occurred during: ""Java Search"".  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.mentionsAny(ParameterizedTypeBinding.java:915)"
"Below code snippet was executed successfully using Java 1.8 b132 using javac, but it shows multiple compiler errors in Eclipse.  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class C2 {  	FI22 fi33= (String @T1[] @T1... x) -> {}; 	 	private void boo() { 				 		FI22 fi333= (String @T1[] @T1... x) -> {}; 	} 	public static void main(String[] args) { 		System.out.println(""Compiled and Executed using javac!""); 	} }  interface FI22 { 	void foo(String[]... x); }  @Target(ElementType.TYPE_USE) @interface T1 { }"
"Consider the below code snippet: package p1;  import java.io.IOException; import java.util.ArrayList;  public class C1 {	 	FI1 fi11 = (java.util.@T ArrayList<IOException> x) -> {  	};  }  interface FI1 { 	void foo(ArrayList<IOException> x); }  Put cursor before -> and invoke Ctrl+1, below exception is thrown:  org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$StaticFinalConstantChecker.visitName(ConstantChecks.java:192) 	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$StaticFinalConstantChecker.visit(ConstantChecks.java:156) 	at org.eclipse.jdt.core.dom.QualifiedName.accept0(QualifiedName.java:168) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759) 	at org.eclipse.jdt.core.dom.NameQualifiedType.accept0(NameQualifiedType.java:190) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759) 	at org.eclipse.jdt.core.dom.ParameterizedType.accept0(ParameterizedType.java:175) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759) 	at org.eclipse.jdt.core.dom.SingleVariableDeclaration.accept0(SingleVariableDeclaration.java:422) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) 	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:211) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$ExpressionChecker.check(ConstantChecks.java:44) 	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks.isStaticFinalConstant(ConstantChecks.java:202) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkAllStaticFinal(ExtractConstantRefactoring.java:320) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkExpression(ExtractConstantRefactoring.java:401) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkSelection(ExtractConstantRefactoring.java:337) 	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkInitialConditions(ExtractConstantRefactoring.java:290) 	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getExtractVariableProposal(QuickAssistProcessor.java:445) 	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getAssists(QuickAssistProcessor.java:273) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeAssistCollector.safeRun(JavaCorrectionProcessor.java:403) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:329) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectAssists(JavaCorrectionProcessor.java:509) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:287) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:242) 	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75) 	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494) 	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687) 	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:193) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:195) 	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1831) 	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:4975) 	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:428) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4642) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1135) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1016) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:635) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:578) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)"
"Created attachment 241873 [details] Source to Paste into Eclipse with 1.5 Source Project Setting  The following test starts an infinite loop with the attached document in CodeFormatter. I can also paste this into eclipse and get the same problem.  If I deactivate the option 1.5, it runs without the loop. the attached file is not syntactically correct, but shouldn't create such a loop anyway. I have Kepler SR2 64 bit with JDK 8 extension.   void test() throws IOException { 		StringBuffer src = new StringBuffer(); 		for (String line : Files 				.readAllLines(Paths 						.get("".../reformatExample.txt""))) { 			src.append(line); 		} 		String source = src.toString(); 		final Map<String, String> options = JavaCore.getOptions(); 		options.put(JavaCore.COMPILER_SOURCE, ""1.5""); 		final CodeFormatter codeFormatter = ToolFactory.createCodeFormatter(options); 		final TextEdit edit = codeFormatter.format(CodeFormatter.K_COMPILATION_UNIT, source, 0, 				source.length(), 0, ""\r\n""); 		assert edit != null; 	}"
Created attachment 241880 [details] An excerpt showing the error  The attached code fails to compile with ECJ but compiles successfully using javac. Some type information appears to be lost in the nested method call because extracting part of it into a new local variable makes the error go away.  Tested using Eclipse SDK  Version: Luna (4.4) Build id: I20140402-0100  and JDT Core built from HEAD yesterday.
"package test.one;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class C1 { 	FI fi1= (@T2 int i) -> {}; }  interface FI { 	void foo(@T1 int i); }  @Target(ElementType.TYPE_USE) @interface T1 {} @Target(ElementType.TYPE_USE) @interface T2 {} -------------------------------------------------------------  In the above example, lambdaExpression.resolveMethodBinding().getParameterTypes()[0] for the lambda expression, gives ""@T1 int"". It should be ""@T2 int"".  ""@T1 int"" is the type of the parameter in SAM."
"Using this code, ECJ reports 6 errors, all of them of the ""should be accessed in a static way"" kind. Compiling with javac works fine. For some reason removing the unused (not unused in the real version) type parameter E from the top-level interface makes the errors go away.  package snippet;  import java.util.Map; import java.util.stream.Collector;  public interface StreamInterface<E extends Exception> {  	static class DoubleCo {  		private static class Re2 {  			static <K, E extends Exception> Map<K, double[]> internalToMapToList2() { 				Collector<Double, double[][], double[][]> toContainer1 = Collector.of( 				//The method supply() from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way 				  StreamInterface.DoubleCo.Re2::supply, 				  //The method accumulate(double[][], Double) from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way 				  StreamInterface.DoubleCo.Re2::accumulate, 				  //The method combine(double[][], double[][]) from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way 				  StreamInterface.DoubleCo.Re2::combine); 				Collector<Double, double[][], double[][]> toContainer2 = 				//All 3 from above: 				  Collector.of(DoubleCo.Re2::supply, DoubleCo.Re2::accumulate, DoubleCo.Re2::combine); 				return null; 			} 			private static double[][] supply() { 				return new double[64][]; 			} 			private static void accumulate(double[][] container, Double value) {} 			private static double[][] combine(double[][] container, double[][] containerRight) { 				return new double[container.length + containerRight.length][]; 			} 		} 	} }"
"The Java 8 compiler that comes with Eclipse generates invalid bytecode for the following code:  ------------ import java.util.stream.Stream; public class MainClass {     public static void main(String[] args)     {         Stream<?> stream = Stream.of(""A"");         stream.map(x -> (String) x);     } } ------------  Running this program immediately fails with a ""bad return type"" VerifyError:  ------------ Exception in thread ""main"" java.lang.VerifyError: Bad return type Exception Details:   Location:     MainClass.lambda$0(Ljava/lang/Object;)Ljava/lang/String; @1: areturn   Reason:     Type 'java/lang/Object' (current frame, stack[0]) is not assignable to 'java/lang/String' (from method signature)   Current Frame:     bci: @1     flags: { }     locals: { 'java/lang/Object' }     stack: { 'java/lang/Object' }   Bytecode:     0000000: 2ab0                                     	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688) 	at java.lang.Class.getMethod0(Class.java:2937) 	at java.lang.Class.getMethod(Class.java:1771) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526) ------------  Compiling this class from the command line with jdk8 works fine.  Also, the problem does not occur in Eclipse if we replace the type ""Stream<?>"" with ""Stream<? extends Object>""."
Created attachment 241891 [details] Example code showing the bug before and after  This bug may be a duplicate of either bug 432605 or bug 432619 but it involves a compiler warning so maybe not.   Using the attached code, it shows two versions of the same method. The first one has redundant type arguments on the indicated line, which causes a warning to be shown, which is fine.   The second version is the same method after using Quick Assist to remove the arguments. The second version doesn't compile with ECJ but both versions compile with javac.
"Please see the summary within the source code for differences and agreements between the compilers. I tried asking in lambda-dev about what the ground truth should be but didn't really get any answers, so these are the those examples with some additional cleanup. Personally, I don't think any one of these should be an error, but that's not here or now.  Tested with the ECJ from latest JDT Core built from HEAD today, inside Eclipse IDE, and javac from java.runtime.version=1.8.0-b132 running on java.vm.version=25.0-b70 launched from Maven with the following configuration: 				<configuration> 					<source>1.8</source> 					<target>1.8</target> 					<verbose>false</verbose> 					<forceJavacCompilerUse>true</forceJavacCompilerUse> 					<fork>true</fork> 					<debuglevel>lines,vars,source</debuglevel> 					<showDeprecation>true</showDeprecation> 					<showWarnings>true</showWarnings> 					<compilerArgs> 						<arg>-version</arg> 						<arg>-Xlint:all</arg> 						<arg>-Xdiags:verbose</arg> 						<arg>-Xstdout</arg> 						<arg>C:\Users\Timo\workspaceI\Java8Tests2\libfilename.txt</arg> 					</compilerArgs> 				</configuration>  The source code:  package differences;  import java.util.function.BinaryOperator; import java.util.function.Consumer;  /*Q*/ @FunctionalInterface interface Subsumer<T> {	void accept(T t);   default                                 Subsumer<T> andThe1(                  Subsumer<? super T> afterT) { return (T t) -> {      accept(t); afterT.accept(t); }; }   default                                 Subsumer<T> andThe2(Subsumer<T> this, Subsumer<? super T> afterT) { return (T t) -> { this.accept(t); afterT.accept(t); }; }   static <U>                              Subsumer<U> andThe3(Subsumer<U> tihs, Subsumer<? super U> afterU) { return (U u) -> { tihs.accept(u); afterU.accept(u); }; }   static <S extends ISSUPER_S, ISSUPER_S> Subsumer<S> andThe4(Subsumer<S> tihs, Subsumer<ISSUPER_S> afterS) { return (S s) -> { tihs.accept(s); afterS.accept(s); }; } } public class JavacECJDiffer { 	static <T extends ISSUPER_T, ISSUPER_T> void method() { 		BinaryOperator<Consumer<? super T>> attempt_X_0 = Consumer::andThen; 		BinaryOperator<Subsumer<? super T>> attempt_X_1 = Subsumer::andThe1; 		BinaryOperator<Subsumer<? super T>> attempt_X_2 = Subsumer::andThe2; 		BinaryOperator<Subsumer<? super T>> attempt_X_3 = Subsumer::andThe3; 		BinaryOperator<Subsumer<? super T>> attempt_X_4 = Subsumer::andThe4; 		BinaryOperator<Consumer<ISSUPER_T>> attempt_n_0 = Consumer::andThen; 		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_1 = Subsumer::andThe1; 		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_2 = Subsumer::andThe2; 		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_3 = Subsumer::andThe3; 		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_4 = Subsumer::andThe4; 		// Summary: 		// ECJ error #1, javac no error 		// ECJ error #2, javac no error 		// ECJ error #3, javac no error 		// ECJ error #4, javac error #1 		// ECJ error #5, javac error #2 		// ECJ no error, javac no error 		// ECJ no error, javac no error 		// ECJ no error, javac no error 		// ECJ no error, javac no error 		// ECJ no error, javac no error 	}  /* ECJ errors: 1: The type Consumer does not define andThen(Consumer<? super T>, Consumer<? super T>) that is applicable here 2: The type Subsumer does not define andThe1(Subsumer<? super T>, Subsumer<? super T>) that is applicable here 3: The type Subsumer does not define andThe2(Subsumer<? super T>, Subsumer<? super T>) that is applicable here 4: The type Subsumer does not define andThe3(Subsumer<? super T>, Subsumer<? super T>) that is applicable here 5: The type Subsumer does not define andThe4(Subsumer<? super T>, Subsumer<? super T>) that is applicable here  javac errors: 1: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:18: error: incompatible types: invalid method reference 		BinaryOperator<Subsumer<? super T>> attempt_X_3 = Subsumer::andThe3; 		                                                  ^     method andThe3 in interface Subsumer<T#2> cannot be applied to given types       required: Subsumer<U>,Subsumer<? super U>       found: Subsumer<? super T#1>,Subsumer<? super T#1>       reason: inference variable U has incompatible bounds         equality constraints: CAP#1         upper bounds: T#1,Object   where U,T#1,ISSUPER_T,T#2 are type-variables:     U extends Object declared in method <U>andThe3(Subsumer<U>,Subsumer<? super U>)     T#1 extends ISSUPER_T declared in method <T#1,ISSUPER_T>method()     ISSUPER_T extends Object declared in method <T#1,ISSUPER_T>method()     T#2 extends Object declared in interface Subsumer   where CAP#1 is a fresh type-variable:     CAP#1 extends Object super: T#1 from capture of ? super T#1 2: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:19: error: incompatible types: invalid method reference 		BinaryOperator<Subsumer<? super T>> attempt_X_4 = Subsumer::andThe4; 		                                                  ^     method andThe4 in interface Subsumer<T#2> cannot be applied to given types       required: Subsumer<S>,Subsumer<ISSUPER_S>       found: Subsumer<? super T#1>,Subsumer<? super T#1>       reason: inference variable ISSUPER_S has incompatible bounds         equality constraints: CAP#1         lower bounds: S,CAP#2   where S,ISSUPER_S,T#1,ISSUPER_T,T#2 are type-variables:     S extends ISSUPER_S declared in method <S,ISSUPER_S>andThe4(Subsumer<S>,Subsumer<ISSUPER_S>)     ISSUPER_S extends Object declared in method <S,ISSUPER_S>andThe4(Subsumer<S>,Subsumer<ISSUPER_S>)     T#1 extends ISSUPER_T declared in method <T#1,ISSUPER_T>method()     ISSUPER_T extends Object declared in method <T#1,ISSUPER_T>method()     T#2 extends Object declared in interface Subsumer   where CAP#1,CAP#2 are fresh type-variables:     CAP#1 extends Object super: T#1 from capture of ? super T#1     CAP#2 extends Object super: T#1 from capture of ? super T#1  */ /*E*/}"
"I have a warning for unused object allocations turned on. Trying to invoke Quick Assist on such a warning inside a constructor causes NPE at  org.eclipse.jdt.internal.ui.text.correction.LocalCorrectionsSubProcessor.getUnusedObjectAllocationProposals(LocalCorrectionsSubProcessor.java:1264)  The line in question is:   				ITypeBinding returnTypeBinding= method.getReturnType2().resolveBinding();  The hover for method getReturnType2 says:  		Returns:  				the return type, possibly the void primitive type, or null if none  Since this happens inside a constructor I believe this is the reason for getting null from that method call. I can create reduced version for reproduction if necessary.  The full stack trace:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.ui.text.correction.LocalCorrectionsSubProcessor.getUnusedObjectAllocationProposals(LocalCorrectionsSubProcessor.java:1264) 	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:706) 	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:313) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:280) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:242) 	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75) 	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494) 	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687) 	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:193) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:195) 	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.GeneratedMethodAccessor37.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) 	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1831) 	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:4975) 	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:428) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4642) 	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5033) 	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) 	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1135) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1016) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)"
Delete and Copy context menu options in Project Explorer get disabled for a project on deselecting "Resource" contents  1. Create a normal project without any facet applied (File->New->Project... and selecting General->Project)  2. Right click on the Project in the Project Explorer:     Observe that the Delete Menu is visible  3. Select: Project Explorer->Customize View->Content    4. Deselect: Resources.                    5. Right click on the Project in the Project Explorer:  Observe that the Delete and Copy Menu is no longer visible  Note: This issue doesn't occur with Java Projects.
My project is using java 1.8 and null annotations. In some of my classes, whenever I make any change to the code, the compiler gives one or more "The type ... is not visible" errors, on places where this is not correct (in some cases, the 'invisible' type is String!).  I've also seen the error "The method ... is undefined for the type ..." appear.  The errors disappear when rebuilding the entire project (Project -> Clean...).  These errors only appear if "annotation-based null analysis" is enabled.
Blocker for bug 432515. Search for references to method reference expressions should report a MethodReferenceMatch whose range starts with the method name and doesn't include the qualifier. That's how all other kinds of method reference matches are reported.  package com.test;  import java.util.function.*;  public class Snippet<E> {     String searchForRefs() {         return "";     }     /**      * @see Snippet#searchForRefs()      */     public void bar() {         this.searchForRefs();         Supplier<String> v1 = new Snippet<Integer>()::searchForRefs;         Supplier<String> v2 = this::searchForRefs;         Function<Snippet<Integer>, String> v3 = Snippet<Integer>::searchForRefs;         Function<Snippet<Integer>, String> v4 = Snippet::searchForRefs;     } } class Sub extends Snippet<Object> {     Supplier<String> hexer3 = super::searchForRefs; }
"Let say we have a piece of code containing an anonymous class: 		Runnable runner = new Runnable() { 			public void run() { 				System.out.println(""Hello runner!""); 			} 		};  - Clicking anywhere in these lines - Selecting all the lines - selecting the first line + Quick Fix does not show the ""Convert to lambda expression"" fix. This makes this conversion fix difficult to discover.  Ideally, we could have a warning associated to this Lambda conversion."
"Trying to write a generic enum leads to error message popup, the file being marked with internal compiler error and lots of errors being logged. To reproduce just uncomment the rest of the line in this test-case:  package npe_oejica_AllocationExpression_checkTypeArgumentRedundancy_line_621;  public enum AutoCloser//<T>  { 	OBJ; }  Here's the full stack trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:621) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:548) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:488) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1143) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1317) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135) 	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
I am not sure about the version. It is the Java 8 Patch for Kepler.  I tried to use annnotation processor that worked before but now I get an NPE in AnnotationMirrorImpl.equals()  Looking into git repository, I assume that the following commit is the reason:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=dc36142c1b691365c62ee525109945bae71724d2    since this change is not null safe:  + return obj.equals(this); // obj could be wrapped by a proxy.
Content Assist should propose keyword 'new' after 'Type::', e.g. here:          IntFunction<Integer> s= Integer::new;
"- Have this CU *without* a newline at the end:  package p; import java.util.function.IntFunction; public class C implements IntFun  - Invoke Content Assist at the very end of the file  org.eclipse.jface.text.BadLocationException 	at org.eclipse.jface.text"
"package p1;  public class C1 { 	FI fi1 = (int i) -> {}; }  interface FI { 	void foo(int i); // Rename 'foo' to 'foo1' using Alt+Shift+R }  class Test { 	void foo1(int c){}	 } --------------------------------------------------------  In the above example, rename 'foo' to 'foo1' using Alt+Shift+R as mentioned in the comment. Renaming fails and we get the following exception:  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:423) 	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2075) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2071) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) 	at org.eclipse.jdt.ui.refactoring.RenameSupport.perform(RenameSupport.java:198) 	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.doRename(RenameLinkedMode.java:362) 	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode$EditorSynchronizer.left(RenameLinkedMode.java:119) 	at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341) 	at org.eclipse.jface.text.link.LinkedModeUI$4.run(LinkedModeUI.java:1193) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)  ... ...  Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.core.search.SearchPattern.createPattern(SearchPattern.java:1880) 	at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine.createOrPattern(RefactoringSearchEngine.java:201) 	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.batchFindNewOccurrences(RenameMethodProcessor.java:590) 	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.analyzeRenameChanges(RenameMethodProcessor.java:540) 	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.doCheckFinalConditions(RenameMethodProcessor.java:388) 	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameVirtualMethodProcessor.doCheckFinalConditions(RenameVirtualMethodProcessor.java:146) 	at org.eclipse.jdt.internal.corext.refactoring.rename.JavaRenameProcessor.checkFinalConditions(JavaRenameProcessor.java:48) 	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224) 	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80) 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5357) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)"
org.eclipse.jdt.internal.core.CompilationUnit#findElements(IJavaElement) doesn't find the corresponding element for a LambdaExpression.  The problem is that it calls Member#getType(String, int), which doesn't work for LambdaExpressions and returns a nonexistent SourceType. This eventually caused the NPE in bug 433373.  In that specific situation, the fix for bug 433373 will hide this problem.  Nevertheless, for 4.5, the findElements API should specify that it can't be used to find ITypes whose #isLambda() returns true, and the implementation should return null. It should also specify that it returns null for an ILocalVariable.
After upgrading to Luna, we notice the JDT code we are using to detect installed VM throw error on Oracle JRockit VM.   After some debugging, it seems caused by the logic in  StandardVMType.generateLibraryInfo(), where following command is executed with the JVM to list the libraries:  E:\WLS1036\jrockit_160_29_D1.2.0-10\bin\java.exe  -Xmx4m -classpath D:\kepler\workspace_luna_src\.metadata\.plugins\org.eclipse.pde.cor e\New_configuration\org.eclipse.osgi\489\0\.cp\lib\launchingsupport.jar org.eclipse.jdt.internal.launching.support.LibraryDetector  Notice the VM argument -Xmx4m is the one causing problem.  On Jrockit, it ends up with  [ERROR] Argument error: -Xmx4m [ERROR] Specified maximum heap size (4MB) is less than minimum required (16MB). Could not create the Java virtual machine.  To Reproduce: - Download and install JRockit from  http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-jrockit-2192437.html - In Preference \ Java \ Installed JRE - Add the JRockit from installation location
Not sure if this is a bug with Eclipse's Java implementation or Oracle's. Former compiler accepts the below code while latter rejects (Test.java:13: error: variable mComparator1 might not have been initialized).  -- import java.util.Comparator;  class Test {     // 'final' keyword causes error     final Comparator mComparator1;      Comparator mComparator2 = //   new Comparator() { //     public int compare(Object pObj1, Object pObj2) { //       return mComparator1.compare(pObj1, pObj2); //     } //   };      (pObj1, pObj2) -> mComparator1.compare(pObj1, pObj2);      Test() {mComparator1 = Comparator.naturalOrder();} }
"Created attachment 242301 [details] Test Case Copied from Bug 433063.  NPE in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:1237)  Stack Trace:  Please see: Bug 433063, Comment 3.  Call stack:  -------------------------------------------------------------------- java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:1237) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isCompatibleWith(TypeBinding.java:590) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.areReturnTypesCompatible(MethodVerifier.java:91) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.areReturnTypesCompatible(MethodVerifier.java:80) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAgainstInheritedMethods(MethodVerifier.java:163) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkAgainstInheritedMethods(MethodVerifier15.java:386) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkMethods(MethodVerifier15.java:586) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:970) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify(MethodVerifier15.java:999) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:979) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:2507) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:796) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:767) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744) ---------------------------------------------------------------  Thanks"
Created attachment 242323 [details] Concept of postfix templates  This bug discusses the implementation/extension of the Eclipse template system to support postfix code completion.  A summary of the concept of postfix code completion is described here: http://goo.gl/UdXIKF  I have regularly used IntelliJ for the last two month to determine if postfix code completion enables major increase in productivity. The bottom line is that some of the postfix templates of IntelliJ really save a lot of time and key strokes. Especially the templates .var, .field, .for and some others lead to a very good developer experience.  I'm aware of bugs like https://bugs.eclipse.org/bugs/show_bug.cgi?id=427201 and the discussed solutions using shortcuts for those purposes, but...  1.) Using shortcuts  needs the developer almost every time to leave the home position (asdf jkl; respectively asdf jklö) of the keyboard which costs a lot of time in the long run and also disrupts the typing flow  2.) Remembering dozens of advanced shortcuts is hard  3.) Discovering advanced shortcuts is sometimes even harder  Furthermore the existing template concept of Eclipse, to achieve auto code generation as described in the above-mentioned bug, is also inconvenient and not a time saving action (1. selecting the line, 2. invoking the content assist using Ctrl+Space, 3. selecting and applying the template using arrow keys)  Summing up, I really would love to see postfix code completion in Eclipse.  I am willing to implement this feature and therefore I have already  digged into the sources of the template system of Eclipse and JDT. The attached image may be considered as a rough concept of postfix templates. I will try to implement a prototype plug-in which meets these requirements, hopefully without the need to touch existing code and I will come up with a prototype/proof of concept or at least new findings within the next week.  Sidenote: Analyzing existing code completion techniques in general and Eclipse-specific techniques is the topic of my bachelor thesis, which is supervised by Marco Descher.  A major part of the bachelor thesis also describes the implementation of a postfix code completion plug-in for Eclipse.
Some jdt.core tests use an error-prone method to guarantee test execution order. E.g. JavaSearchBugsTests and JavaSearchBugs8Tests list all test methods again in the suite() method implementation.  1. This hack should not be applied without an understanding why the tests fail when they are executed in random order.  2. Instead of listing all test methods again, you should at least use a utility like     return new OrderedTestSuite(JavaSearchBugs8Tests.class); or just     return buildModelTestSuite(JavaSearchBugs8Tests.class, ALPHABETICAL_SORT) without the "if (TESTS_PREFIX != null || ..." before.
"This used to work earlier without warnings:  package nullwarnings; import java.util.function.Consumer; public class NullConversionWarning<T> {  	public Consumer<T> peek2(Consumer<? super T> action) { 		// Null type safety: parameter 1 provided via 		// method descriptor Consumer<T>.accept(T) needs 		// unchecked conversion to conform to 'capture#of ? super T' 		Consumer<T> action2 = action::accept; 		return action2; 	} }  Using Eclipse SDK Version: Luna (4.4) Build id: I20140422-0800 and JDT Core built from HEAD yesterday, I think."
"This is making my head hurt. This bug report was supposed to be about mark occurrences and find references disagreeing about whether a method was called or not but I must have made a mistake preparing the test case because it turned into this instead.  Using this code:  package mark.occurrences.find.references;  import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.function.Consumer; import java.util.stream.Stream;  public class Disagree {  	private interface StreamyBase<T, E extends Exception> {  		@SuppressWarnings(""unused"") 		default void forEachOrdered(Consumer<? super T> action) throws E {} 	} 	abstract private static class AbstractStream<T, E extends Exception, STREAM, SELF extends AbstractStream<T, E, STREAM, SELF, CONSUMER>, CONSUMER> 	  implements StreamyBase<T, E> {  		@SuppressWarnings(""unused"") 		public void forEachOrdered(CONSUMER action) throws E {} 		// remove this method with a warning about it being unused: 		public final @SafeVarargs void forEachOrdered(Consumer<? super T> action, Consumer<? super T>... actions) throws E {} 	} 	private static class UnStream<T> extends 	  AbstractStream<T, RuntimeException, Stream<T>, UnStream<T>, Consumer<? super T>> {} 	private static class IOStream<T> extends 	  AbstractStream<T, IOException, Stream<T>, IOStream<T>, IOConsumer<? super T>> {} 	@FunctionalInterface 	private interface ExConsumer<T, E extends Exception> {  		void accept(T t1) throws E; 	} 	@FunctionalInterface 	private interface IOConsumer<T> extends ExConsumer<T, IOException> {}  	public static void tests1(IOStream<String> lines1, UnStream<String> lines2) throws IOException { 		IOConsumer<? super String> action = s -> Files.isHidden(Paths.get(s)); 		Consumer<? super String> action2 = s -> System.out.println(s); 		lines1.forEachOrdered(action); 		lines1.forEachOrdered(action2); 		lines2.forEachOrdered(action2); 		// After removal these two become ambiguous: 		lines1.forEachOrdered(s -> Files.isHidden(Paths.get(s))); 		lines1.forEachOrdered(s -> System.out.println(s)); 	} }  Removing the method indicated in the code above causes two of the forEachOrdered method calls to become ambiguous.  Is there an undiagnosed problem in the code? Or is an unused method that is acting as a tie-breaker truly unused? You decide!"
"Convert anonymous to lambda considers overridden method as ambiguous target type after bug 423439.  One example is in org.eclipse.jface.viewers.SWTFocusCellManager#hookListener(ColumnViewer):  private void hookListener(final ColumnViewer viewer) { //... 	viewer.addSelectionChangedListener(new ISelectionChangedListener() { 		@Override 		public void selectionChanged(SelectionChangedEvent event) { 			if( event.selection.isEmpty() ) { 				setFocusCell(null); 			} 		} 	});  The addSelectionChangedListener(..) method is declared in ISelectionProvider and overridden in Viewer."
"Trying to inline the local variable indicated in this code causes an Internal Error caused by a NPE to be logged:  import java.io.IOException; import java.util.function.Predicate;  class DeadBeef {  	private interface IOPredicate<T> {  		boolean test(T t1) throws IOException; 	} 	@SuppressWarnings(""unused"") 	private static abstract class AbstractStream<T, SELF extends AbstractStream<T, SELF, PREDICATE>, PREDICATE> {  		@SuppressWarnings(""null"")     SELF filter(PREDICATE allowed) { 			return null; 		}     @SuppressWarnings(""null"")     final @SafeVarargs SELF filter(Predicate<? super T> allow, Predicate<? super T>... allowed) { 			return null; 		} 	} 	private static class IOStream<T> extends AbstractStream<T, IOStream<T>, IOPredicate<? super T>> {}  	static IOStream<String> main(IOStream<String> a) { 		// Trying to inline this variable causes an Internal Error: 		IOPredicate<String> allowed = word -> true; 		return a.filter(allowed); 	} }  Here is the full stack trace:  Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.dom.ASTNodes$AmbiguousTargetMethodAnalyzer.visit(ASTNodes.java:727) 	at org.eclipse.jdt.internal.corext.dom.ASTNodes.isTargetAmbiguous(ASTNodes.java:679) 	at org.eclipse.jdt.internal.corext.dom.ASTNodes.getExplicitCast(ASTNodes.java:606) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.getModifiedInitializerSource(InlineTempRefactoring.java:383) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.getInitializerSource(InlineTempRefactoring.java:349) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.inlineTemp(InlineTempRefactoring.java:327) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.createChange(InlineTempRefactoring.java:308) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:124) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)  Tested with Eclipse SDK  Version: Luna (4.4) Build id: I20140422-0800  and JDT UI built from HEAD just now."
"The following class is accepted by eclipse while it is rejected by javac with the error  cannot reference this before super type constructor has been called. ---------------------> import java.util.function.Supplier;  class E { 	E(Supplier<Object> factory) { } }  public class Y extends E { 	Y() { 		super( () -> { 			class Z extends E { 				Z() { 					super(new Supplier<Object>() { 						@Override 						public Object get() { 							// TODO Auto-generated method stub 							return new Object(); 						} 					}); 				} 			}  			return new Z(); 			}); 	} 	public static void main(String[] args) { 		new Y(); 	} } -----------------------------> Not sure if it's a bug in eclipse or javac."
The Eclipse Java Compiler allows to annotate the package in package-info.java with annotations of ElementType.TYPE. With Java7 this was working fine but alo there the Oracle Java Compiler raised an error.  With Java8 the implementation of class Class does no longer load the annotations of ElementType.TYPE for the package-info. Only annotations of ElementType.PACKAGe are found and also accepted from the Oracle Java Compiler.
"Taken from bug 426967 comment #2:  class E { 	private void foo() { 		for (String str : new String[1]) { 		} 	} }  Press Ctrl+1 at ""str"", we get the exception:  java.lang.ClassCastException: org.eclipse.jdt.core.dom.SimpleType cannot be cast to org.eclipse.jdt.core.dom.ArrayType 	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getConvertEnhancedForLoopProposal(QuickAssistProcessor.java:2588) 	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getAssists(QuickAssistProcessor.java:281) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeAssistCollector.safeRun(JavaCorrectionProcessor.java:403) 	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339) ..."
"Created attachment 242527 [details] Source file  The attached java class crashes the compiler with an NPE (in Eclipse 3.8.2 and javac compiling works fine). Compiler Compliance Level has to be set to 1.8.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:525) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkAgainstFinalTargetType(AllocationExpression.java:728) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.checkAgainstFinalTargetType(ConditionalExpression.java:728) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:739) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5136) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2490) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2429) 	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:362) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:511) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:486) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
The following Java code:  Class<? extends Exception>[] exceptions;  try {     // some stuff here } catch (exceptions[0] e) {     // some more stuff here }  causes the following error:  Internal compiler error: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding at org.eclipse.jdt.internal.compiler.ast.TryStatement.verifyDuplicationAndOrder (TryStatement.java:1191)  "Help -> About Eclipse -> (Eclipse logo)" reports "3.9.1.v20130911-1000" as the version of the "Eclipse Java Development Tools (org.eclipse.jdt)" on my machine, but 3.9.1 was not available in the version-menu above, so I selected 3.8.2 instead (closest). I am using Kepler SR1.
"From bug 433586 comment 8: --------------------------------------------------- this case still shows a warning:  @FunctionalInterface public interface ExFunction<T, R, E extends Exception> { 	R apply(T t1) throws E;  	default <V>  ExFunction<V, R, E> compose(ExFunction<? super V, ? extends T, E> before) { 		Objects.requireNonNull(before); 		//warning on before.apply(v): 		//Null type safety (type annotations): The expression of type 'capture#of ? extends T' needs unchecked conversion to conform to 'T' 		return (V v) -> apply(before.apply(v)); 	} } ---------------------------------------------------"
"It is not possible to cancel moving a read-only resource. Selecting Cancel or No in the Check Move prompt result in InvocationTargetException wrapping this exception:  java.lang.ArrayIndexOutOfBoundsException: 0 	at org.eclipse.ltk.internal.core.refactoring.resource.MoveResourcesProcessor.getMoveDescription(MoveResourcesProcessor.java:186) 	at org.eclipse.ltk.internal.core.refactoring.resource.MoveResourcesProcessor.createChange(MoveResourcesProcessor.java:220) 	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.createChange(ProcessorBasedRefactoring.java:292) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:124)   It seems there is an error in the implementation of MoveResourcesProcessor.getMoveDescription() - if and else statements must be swapped."
Created attachment 242632 [details] Screenshot of incorrect validation in latest stable build of Luna.  class A<V> {     public static class Container {         public static class In<T> {             public static class Inner<U> {             }         }         public static <X> void doit() {             new In.Inner<X>(); // compilation error         }     } }  Mentioned piece of code is being reported by JDT to contain error with the following message:   * The member type A.Container.In must be parameterized, since it is qualified with a parameterized type (Java Problem)  However the code is syntactically correct and can be compiled via javac.   Tested on Eclipse Kepler, Juno and Luna (see attached screenshot) builds.  Originally asked as a question on StackOverflow - http://stackoverflow.com/questions/23416674/nested-generics-in-java
I have a single method on a generic parameterized class. A caller gets an instance of the class but thinks the method invocation is ambiguous:  The method doFoo() is ambiguous for the type capture#4-of ? extends EclipseJava8Generics.Foo<?>  I will attach a complete test case for reproducing this issue in a separate comment.  See similar Bug 431408.
"interface I { 	public static void bar(int i) { } 	public default void bar() {} }  class Y implements I{ 	     public static void main(String[] args) {     	new Y().ba(0);//Use quick assist for this error 	} }  quick fix changes just the ba to bar (without mentioning / changing the parameter), but bar(int i) being static is not applicable in the context of new Y()."
"interface I { 	public strictfp  void foo() { // Use quick assist -> remove method body 		System.out.println(""Hellow"");  	} }  quick fix suggests ""remove method body"" [one of the suggestions] for the above issue which would make foo an abstract method, for which strictfp modifier is not allowed and hence results in an error"
"@FunctionalInterface interface I { 	public int foo(I i); } public class X { 	public static int bar(I i) { return 0;} 	public int foo(I i) { 		I i1 = X::;// shows probable quick fix but says no suggestions. 		return 0; 	} }  [not java 8 specific]"
In bug 424283 we have added support to copy the JavaDoc from a private field unfortunately the JavaFX people are not consistent on where they put it - looking at BorderPane#center the documentation is on the BorderPane#centerProperty  I guess this is too late to get into Luna SR0?
"The following code causes the compiler to abort with an NPE. It compiles fine with javac  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.List;  public class CompilerCrashesWithNPE {      public void bla() {     boolean b = Boolean.TRUE.booleanValue();          List<String> c1 = new ArrayList<>();     Collections.sort(c1, b ? null : new Bar(new ArrayList<>(),Comparator.nullsLast((a,e) -> {return 0;})));   }    private static class Bar implements Comparator<String>{ 	  public <T> Bar(Collection<T> col, Comparator<T> comp) { 		   	  } 	@Override 	public int compare(String o1, String o2) { 		// TODO Auto-generated method stub 		return 0; 	}   } }  This is the stack trace  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:469) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:172) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCode(AllocationExpression.java:116) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.analyseCode(ConditionalExpression.java:119) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:172) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) ...."
I've just upgraded to M7. Disaster.  All my Java 6/7 source code complains that JDT annotations are only available with Java 8 or higher and demands that I change projhect compliance and JRE to 1.8  I have jdt.annotation 1.1.0.v20140129-1625 installed so surely this should preserve Juno/Kepler functionality.
For a while now (I think since Eclipse 3.3), our integration tests over at jOOQ (http://www.jooq.org) take forever to recompile. Using jstack on the Eclipse process shows that most of the time is spent here:  --------------------------------------------------------------- "Compiler Processing Task" #220 daemon prio=5 os_prio=0 tid=0x000000001a0e7800 nid=0x2628 runnable [0x00000000346ae000]    java.lang.Thread.State: RUNNABLE         at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:152)         at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:172)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:946)         at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:509)         at org.eclipse.jdt.internal.compiler.lookup.InferenceSubstitution.substitute(InferenceSubstitution.java:39)         at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.substitute(InferenceContext18.java:267)         at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.createInitialConstraintsForParameters(InferenceContext18.java:288)         at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.inferInvocationApplicability(ConstraintExpressionFormula.java:355)         at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:134)         at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:732)         at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:862)         at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:838)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:116)         at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:737)         at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:693)         at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1758)         at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659)         at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2925)         at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:867)         at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698)         at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:602)         at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:602)         at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:648)         at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018)         at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)         at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)         at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1317)         at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)         at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:771)         at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)         at java.lang.Thread.run(Unknown Source) ---------------------------------------------------------------  As our integration tests are quite big (https://github.com/jOOQ/jOOQ/jOOQ-test), this won't be easy to reproduce or to track down, but I would be more than willing to help you find potential bottlenecks if possible. There are two characteristics to our integration tests:  1. Test classes use a lot of generics like so:  --------------------------------------------------------------- public abstract class BaseTest<      // T_AUTHOR table     A extends UpdatableRecord<A> & Record6<Integer, String, String, Date, Integer, ?>,      // T_AUTHOR pojo     AP,      // T_BOOK table     B extends UpdatableRecord<B>,      // T_BOOK_STORE table     S extends UpdatableRecord<S> & Record1<String>,      // T_BOOK_TO_BOOK_STORE table     B2S extends UpdatableRecord<B2S> & Record3<String, Integer, Integer>,      // MULTI_SCHEMA.T_BOOK_SALE table     BS extends UpdatableRecord<BS>,      // V_LIBRARY view     L extends TableRecord<L> & Record2<String, String>,      // T_ARRAYS table     X extends TableRecord<X>,      // T_DATES table     DATE extends UpdatableRecord<DATE>,      // T_BOOLEANS table     BOOL extends UpdatableRecord<BOOL>,      // T_DIRECTORY table     D extends UpdatableRecord<D>,      // T_TRIGGERS table     T extends UpdatableRecord<T>,      // T_UNSIGNED table     U extends TableRecord<U>,      // T_1624_UUID table     UU extends UpdatableRecord<UU>,      // T_IDENTITY table     I extends TableRecord<I>,      // T_IDENTITY_PK table     IPK extends UpdatableRecord<IPK>,      // Various tables related to trac ticket numbers     T725 extends UpdatableRecord<T725>,     T639 extends UpdatableRecord<T639>,     T785 extends TableRecord<T785>,     CASE extends UpdatableRecord<CASE>> { ---------------------------------------------------------------  2. jOOQ is by itself a very "generic" API. We have lots of types like these:  --------------------------------------------------------------- public interface Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> extends Record {      /**      * Get this record's fields as a {@link Row13}.      */     @Override     Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> fieldsRow();      /**      * Get this record's values as a {@link Row13}.      */     @Override     Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> valuesRow(); ---------------------------------------------------------------
4.4 M7.  This was brought up by Noopur: "Store method parameter names" doesn't capture what's really stored, e.g. 'final' modifier is also written to the class file.  The spec talks about "information": "information about the formal parameters of a method, such as their names. "  Therefore we should rename our preference to: Store information about method parameters (usable via reflection)
Created attachment 242814 [details] sample project  At the moment you turn on NPE analysis you get strange errors
"The following code causes compilation error in eclipse but compiles fine with javac.  import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List;  public class InferenceProblem {   public void bla() {     boolean b = Boolean.TRUE.booleanValue();          List<String> c1 = new ArrayList<>();     Collections.sort(c1, new Foo(new State<>((b ? new Val<>(""AAAA"") : new Val<>(""BBBB""))))); // Cannot infer type arguments for State     Collections.sort(c1,new Foo(b ? new State<>(new Val<>(""AAAA"")) : new State<>(new Val<>(""BBBB"")))); // this is fine       }    static class Foo implements Comparator<String>{  	  public Foo(State<String> st) { 		  // 	  } 	@Override 	public int compare(String o1, String o2) { 		// TODO Auto-generated method stub 		return 0; 	} 	     } 	static class State<R> { 		State(Val<?> o) { 		} 	} 	static class Val<T> { 		Val(T t) {} 	} }"
"Created attachment 242860 [details] simple switch with enums  Exception in thread ""main"" java.lang.ClassFormatError: Illegal field modifiers in class ecj/tests/I: 0x100A 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:760) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:455) 	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:367) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:361) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:360) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:760) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:455) 	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:367) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:361) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:360) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)"
"The Eclipse compiler does not seem to pick up the inferred type correctly when given a reference method as parameter instead of a lambda with more explicit return type.  Given this class:  public class Foo { 	   // Similar to Guava's newLinkedList()   public static <E> LinkedList<E> newLinkedList() {     return new LinkedList<E>();   } 	   private final ThreadLocal<Queue<String>> brokenQueue = ThreadLocal.withInitial(Foo::newLinkedList); 	   private final ThreadLocal<Queue<String>> workingQueue = ThreadLocal.withInitial(() -> Foo.<String>newLinkedList());  }  Eclipse gives the following error on the brokenQueue line:  Type mismatch: cannot convert from ThreadLocal<Object> to ThreadLocal<Queue<String>>  The workingQueue line has no error.  javac does not give an error on the whole class.  Tested on: Eclipse Luna 4.4 M7 & STS 3.5.1 (based on Eclipse Kepler 4.3.2) Eclipse running on JDK 7 & JDK 8"
"package p1;  interface ISuper { 	void foo(FI1 fi1); }  interface ISub extends ISuper { 	void foo(FI2 fi2); }  // --- @FunctionalInterface interface FI1 { 	void abc(); }  @FunctionalInterface interface FI2 { 	void xyz(); }  // --- class Test1 { 	private void test1() { 		f1().foo(new FI1() { 			@Override 			public void abc() {	// [1] 				System.out.println(); 			} 		});  	} 	 	private ISub f1() { 		return null; 	} }  abstract class Test2 implements ISub { 	private void test2() { 		foo(new FI1() { 			@Override 			public void abc() { // [2] 				System.out.println(); 			} 		}); 	} }  class Test3 { 	void foo(FI1 fi1) {} 	void foo(FI2 fi2) {} 	private void test3() { 		foo(new FI1() { 			@Override 			public void abc() { // [3] 				System.out.println(); 			} 		}); 	} }  -----------------------------------------------------------------------  Apply the quick assist / cleanup at [1], [2], [3] in the above example. Bug 423439 handles only case [3]. [1] and [2] result in ambiguous method error.  ASTNodes.isTargetAmbiguous(Expression) uses methodBinding.getDeclaringClass() to look for overloaded methods.  For [1], the type of the expression in invocation should be used and for [2], the enclosing type should be used.  We should find the correct type to be visited by AmbiguousTargetMethodAnalyzer."
When bug 421017 was fixed, the compliance and target platform for jdt.core bundle were moved to 1.6. These changes should reflect in the scripts/build.xml. Right now, creating ecj.jar from the source jar fails with compiler errors, because of lack of support for annotations (we started using annotations since bug 421017 was fixed). This should be addressed in Luna.
"This came up in AspectJ bug 377096 but appears to be a JDT issue. Basically, create a project with this source inside:  import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy;  @Retention(RetentionPolicy.RUNTIME) @interface C { 	int i();  } public class A { 	   @C(b={},i=42)    public void xxx() {}      public static void main(String []argv) throws Exception { 	System.out.println(A.class.getDeclaredMethod(""xxx"").getAnnotations()[0]);     } }  There is a compile error against 'b={}' because b doesn't exist in the annotation.  However, a class file is generated regardless (that's ok). The body of the method 'xxx()' includes the message but the RuntimeVisibleAnnotation on xxx() is not correct. It breaks javap when attempting to decompile the class. Or to see the problem you can run the class above, which fails with:  Exception in thread ""main"" java.lang.reflect.GenericSignatureFormatError: Signature Parse error: Expected Field Type Signature 	Remaining input: i 	at sun.reflect.generics.parser.SignatureParser.error(SignatureParser.java:124) 	at sun.reflect.generics.parser.SignatureParser.parseFieldTypeSignature(SignatureParser.java:297) 	at sun.reflect.generics.parser.SignatureParser.parseFieldTypeSignature(SignatureParser.java:283) 	at sun.reflect.generics.parser.SignatureParser.parseTypeSignature(SignatureParser.java:485) 	at sun.reflect.generics.parser.SignatureParser.parseTypeSig(SignatureParser.java:188) 	at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:436) 	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:241) 	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) 	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) 	at java.lang.reflect.Executable.declaredAnnotations(Executable.java:546) 	at java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:539) 	at java.lang.reflect.Method.getDeclaredAnnotations(Method.java:615) 	at java.lang.reflect.AccessibleObject.getAnnotations(AccessibleObject.java:206) 	at A.main(A.java:14)  Although the code does have an error in it, I don't believe we want to generate illegal class files.  javap produces:    public void xxx();     descriptor: ()V     flags: ACC_PUBLIC Error: java.lang.reflect.InvocationTargetException       RuntimeVisibleAnnotations: length = 0x7        00 01 00 12 49 00 13    The first bit of the data is correct '00 01' => 1 annotation The remaining data is for the 'i=42' (00 12 49 00 13). The data is missing between them for the annotation type itself, something like '00 0d 00 01' => annotation type A (#0d in constant pool) and there is 1 annotation value."
"I installed eclipse-SDK-I20140509-2000-macosx-cocoa-x86_64.tar.gz and imported the Spring Framework projects into Eclipse with target and source set to 1.8.  java version ""1.8.0"" Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)  The spring-test module fails to compile with the following error:  Type mismatch: cannot convert from Class<InitializerWithoutConfigFilesOrClassesTests.EntireAppInitializer> to Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>[]	InitializerWithoutConfigFilesOrClassesTests.java	/spring-test/src/test/java/org/springframework/test/context/junit4/aci/annotation	line 41	Java Problem  This compiles fine with JDK 6, 7, & 8 using javac. Furthermore, this has compiled with previous versions of Eclipse when using target and source set to 1.7.  The following Example class reproduces this problem. The included interfaces and classes simulate the real ones from Spring.  Note: if @Config is removed from Example, the class compiles (even CompilationSuccess); however, whenever @Config is declared on Example, the following compiler error is generated:  Type mismatch: cannot convert from Class<Example.CustomInitializer> to Class<? extends Example.Initializer<? extends Example.ConfigurableContext>>[]	Example.java	/spring-test/src/main/java/example	line 7	Java Problem   package example;  import example.Example.Config; import example.Example.CustomInitializer;  @Config(initializers = CustomInitializer.class) public class Example {  	static interface Context { 	}  	static interface ConfigurableContext extends Context { 	}  	static abstract class AbstractContext implements ConfigurableContext { 	}  	static class GenericContext extends AbstractContext { 	}  	static interface Initializer<C extends ConfigurableContext> { 	}  	static @interface Config { 		Class<? extends Initializer<? extends ConfigurableContext>>[] initializers() default {}; 	}  	static class CustomInitializer implements Initializer<GenericContext> { 	}  	@Config(initializers = CustomInitializer.class) 	static class CompilationSuccess { 	}  }"
Created attachment 242935 [details] Example project with stack traces  I was trying to create a visitor for an AST which determines whether two trees are equal. Turns out adding @Nullable to a type parameter in some cases results in a NullPointerException somewhere in the JDT core.  The intended class header was  public class EqualsVisitor extends ConcreteNodeVisitor<Boolean, @Nullable Object>  But Eclipse doesn't like the @Nullable there.  I attached an example project with a text file with the stack traces. Most of the errors that showed up in the error log were repeats of these, or so they seemed.
Created attachment 242949 [details] Example project with bug as described  On Eclipse Luna M7, Build ID 20140508-1440, Java 1.8.0_05. Null analysis appears to ignore @NonNullByDefault in package-info.java, so type parameters in interfaces cause an error, stating "Null constraint mismatch: The type '@NonNull <subtype>' is not a valid substitute for the type parameter 'T' which is constrained as '@Nullable'". In addition, while an error might be shown in the editor, the null error does not prevent the program from launching.  Attached is an example project. I experienced an error in ExpressionNode.
I'm not sure if it's just me not understanding how null annotation inference works, but there's one particular case I'm not understanding.  In a package annotated with @NonNullByDefault, I have a generic method that returns @Nullable T, where T is defined as <T extends ExtendedNode>. When I try to call this method and assign the result to @Nullable ExtendedNode, the compiler complains about inferring @NonNull @Nullable <return type> <rest of method here>. I have no clue where the compiler is pulling @NonNull from, since the method is stated to return @Nullable and the returned object is being assigned to a @Nullable type.  This is on Eclipse 4.4 Build 20140508-1440, Java 1.8.0_05.
JDIModelPresentation extends IDebugModelPresentationExtension which extends IDebugModelPresentation , so IDebugModelPresentation can be removed from JDIModelPresentation's implements section
Created attachment 242956 [details] The project to reproduce the issue  After switching to 3.10.0.v20140501-0200 we got type mismatch errors for the code which is used to work.  The project to reproduce the issue is attached to the bug.
"(This issue is related to bug 424223)  When a ""Clean-up"", converting anonymous to lambda, is applied on this use case:  public class Test { 	interface FIOther { 		void run(int x); 	}  	public class TestOther { 		void init(String e) { 			String x; 			m(new FIOther() { 				@Override 				public void run(int e) { 					FIOther fi = new FIOther() { 						@Override 						public void run(int e) { 							return; 						} 					}; 				} 			}); 		}  		void m(FIOther fi) { 		};  	} }   ... one get:  public class Test { 	interface FIOther { 		void run(int x); 	}  	public class TestOther { 		void init(String e) { 			String x; 			m(e1 -> { 				FIOther fi = e1 -> { // Error 					return; 				}; 			}); 		}  		void m(FIOther fi) { 		};  	} }"
"Created attachment 242999 [details] Patch and Test example  In Following test case too much frames gets dropped without need:  1. In the follwoing test program (TestHCR1.java) set a breakpoint at the first line of TestHCR.test(); 2. After the breakpoint gets hit, change the content of run1.run() or run2.run() (e.g. add new println) 3. Save the file.   package application;  public class TestHCR1 { 	Runnable run1 = new Runnable() { // Anonymous class initializer 		public void run() { 			System.out.println(""Test run1 : run""); 			run2.run(); 		} 	}; 	 	Runnable run2 = new Runnable() { // Anonymous class initializer 		public void run() { 			// changing the content of this function during the debugging 			// will cause that many frames will be dropped and the program will continue 			// from the start of the (run1.run) method 			System.out.println(""Test run2 : run""); 			System.out.println(""Test run2: completed""); 		} 	}; 	 	public TestHCR1() { 		 	} 	 	public void test() { 		run1.run(); 	} 	 	public static void main(String[] args) { 		new TestHCR1().test(); 	} }  Because the anonymous class declarations have no qualified name (binding.getQualifiedName() returns """") they will be identified using the binary name of their binding type (TestHCR1$1 and TestHCR1$2. To avoid this problem we need to check the binary name of the class and not the qulified name."
"Created attachment 243009 [details] Bug ConditionalJump Instruction  The ASTEvaluationEngine  failed to execute the ConditionalJump instructions , when the condition is an instance of java.lang.Boolean object (not a primitive value).  Example (add TestHCR.java to any project) and apply the following steps: 1- add a breakpoint on the first line of the main method 2- open Display view in eclipse  3- copy the block        if (ifCondition) { 		System.out.println(""if condition true"");       }  and execute it. A new ClassCastException will be thrown.    /**  *   * @author j.Saoumi  *  */ package java8;  public class TestHCR { 	 	public static Boolean ifCondition = Boolean.TRUE; 	 	 	public static void main(String[] args) { 		System.out.println(""begin main""); 		if (ifCondition) { 			System.out.println(""if condition true""); 		} 		System.out.println(""end main""); 	} 	 }"
Add Clean Up options for one or both of - Remove unnecessary type arguments - Insert inferred type arguments  See bug 351956 and UI discussions there.
"If the command Quick Assist - Inline local variable is bound to Ctrl+Alt+Right in Preferences->General->Keys and that combination is activated and a local variable is thus inlined, pressing the Delete key afterwards has no effect. Delete key starts working again after some characters are selected with Shift+Any arrow key or the caret jumps to a different location by pressing Ctrl+Right, Ctrl+Left, Home, End.  To reproduce the bug, take this source:  import java.util.ArrayList; import java.util.function.Supplier; import java.util.stream.Collector; import java.util.stream.Collectors;  class DeleteKey<T> { 	public void inline() { 		// inline collectionFactory by pressing Ctrl+Alt+Right with the caret within it: 		Supplier<ArrayList<T>> collectionFactory = ArrayList<T>::new; 		Collector<T, ?, ArrayList<T>> collection = Collectors.toCollection(collectionFactory); 	} }  Steps: 1. Open Preferences -> General -> Keys and find Quick Assist - Inline local variable, bind it to the key combination Ctrl+Alt+Right Arrow, and press OK. 2. Move the caret in the middle of the name of the variable collectionFactory. 3. Press Ctrl+Alt+Right Arrow key combination. 4. Press Delete, but it doesn't delete anything.  Tested with Eclipse SDK Version: Luna (4.4) Build id: I20140510-1500"
"When annotation-based null analysis is enabled and the full JDK with sources is used, activating the Inline Method refactoring on Collectors.toCollection causes an ArrayIndexOutOfBoundsException to be thrown.  To reproduce, using this code:  import java.util.ArrayList; import java.util.HashSet; import java.util.function.Function; import java.util.function.Supplier; import java.util.stream.Collector; import java.util.stream.Collectors; import java.util.stream.Stream;  public abstract class InternalError<T> {  	public ArrayList<T> toList() { 		// active Inline... command with the caret here-------->| 		Collector<T, ?, ArrayList<T>> collection = Collectors.toCollection(ArrayList<T>::new); 		return terminalAsObj(s -> s.collect(collection), maker()); 	} 	public HashSet<T> toSet() { 		Collector<T, ?, HashSet<T>> collection = Collectors.toCollection(HashSet<T>::new); 		return terminalAsObj(s -> s.collect(collection), maker()); 	} 	protected abstract Supplier<Stream<T>> maker(); 	protected abstract <R> R terminalAsObj(Function<Stream<T>, R> consumption, Supplier<Stream<T>> supplier); }  Steps: 1. In Preferences -> Java -> Compiler -> Errors/Warnings -> Null analysis, turn on Enable annotation-based null analysis. 2. In Preferences -> Java -> Installed JREs, replace the default JRE with Java 8 JDK. 3. Move caret to the location indicated in the source code and activate the refactoring Inline... from either right-click menu or by pressing Shift+Alt+I. 4. Two error message dialogs are displayed.  Tested with Eclipse SDK Version: Luna (4.4) Build id: I20140510-1500  The stack trace: Caused by: java.lang.ArrayIndexOutOfBoundsException: 0 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.substitute(ParameterizedGenericMethodBinding.java:741) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:489) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:518) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:618) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:442) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.<init>(ParameterizedGenericMethodBinding.java:500) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedGenericMethod(LookupEnvironment.java:831) 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkNullSpecInheritance(ImplicitNullAnnotationVerifier.java:287) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkNullSpecInheritance(MethodVerifier15.java:418) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkConcreteInheritedMethod(MethodVerifier15.java:103) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkInheritedMethods(MethodVerifier.java:421) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkInheritedMethods(MethodVerifier15.java:342) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.checkMethods(MethodVerifier15.java:677) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:970) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify(MethodVerifier15.java:999) 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:979) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:2507) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildAnonymousTypeBinding(ClassScope.java:111) 	at org.eclipse.jdt.internal.compiler.lookup.BlockScope.addAnonymousType(BlockScope.java:94) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:538) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1311) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1106) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.corext.refactoring.util.RefactoringASTParser.parse(RefactoringASTParser.java:63) 	at org.eclipse.jdt.internal.corext.refactoring.util.RefactoringASTParser.parse(RefactoringASTParser.java:52) 	at org.eclipse.jdt.internal.corext.refactoring.util.RefactoringASTParser.parse(RefactoringASTParser.java:48) 	at org.eclipse.jdt.internal.corext.refactoring.util.RefactoringASTParser.parse(RefactoringASTParser.java:44) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.resolveSourceProvider(InlineMethodRefactoring.java:426) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkInitialConditions(InlineMethodRefactoring.java:252) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)"
"Place the following files in respective packages: //////////////////////////////// package p4a;  @FunctionalInterface public interface FI1<R> {     public R foo1(); }  //////////////////////////////// package p4a;  @FunctionalInterface public interface FI2 {     public void foo2(); } //////////////////////////////// package p4b;  import p4a.FI1; import p4a.FI2;  public class Test { 	{ 		FI1 fi1 = new FI1<FI2>() {             @Override             public FI2 foo1() {                 return new FI2() {                     @Override                     public void foo2() {}                 };             }         }; 	} } ////////////////////////////////  Apply clean-up on Test.java to use lambda where possible. The result is: //////////////////////////////// package p4b;  import p4a.FI1;  public class Test { 	{ 		FI1 fi1 = () -> new FI2() { 		    @Override 		    public void foo2() {} 		}; 	} } ////////////////////////////////  The issues are: - Only the outer anonymous class is converted to lambda - Import statement for FI2 is removed. - Hovering on FI2 in the resultant code does not provide the quick fix to import FI2."
"I'm using 4.4M7, and null annotations. After https://bugs.eclipse.org/bugs/show_bug.cgi?id=432223 has been fixed, I'm still getting compiler errors on a slightly different use case:  public class Assert { 	public static void caller() { 		assertNotNull(""not null"");	// Compiler error 		assertNotNull(null);		// Compiler error 	} 	private static @NonNull <T> T assertNotNull(@Nullable T object) { 		return object; 	} }  The two assertNotNull invocations both give the error   Contradictory null annotations: method was inferred as '@NonNull @Nullable Object assertNotNull(@Nullable Object)', but only one of '@NonNull' and '@Nullable' can be effective at any location"
"When the host Eclipse workbench is running with a Java 8 VM, Eclipse's java launching process fails on Windows if the Java executable is on a UNC path.  --- 8< --- This occurs because of a change to the argument processing in Java 8  http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/5ea5f5dfb96a/src/windows/classes/java/lang/ProcessImpl.java  If the JVM property jdk.lang.Process.allowAmbigousCommands is set to false then it works as expected. --- 8< ---  The problem is that running a quoted command succeeds iff the command is not on a unc path and is not on Java 8:  J7: c:\foo works J7: ""c:\foo"" works J7: \\host\share\foo works J7: ""\\host\share\foo"" works  J8: c:\foo works J8: ""c:\foo"" works J8: \\host\share\foo works J8: ""\\host\share\foo"" fails  The solution which fixes it (other than the above system property) is not to escape the command itself in AbstractVMRunner.java:  	private static String[] quoteWindowsArgs(String[] cmdLine) { 		// see https://bugs.eclipse.org/387504 , workaround for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6511002 		if (Platform.getOS().equals(Constants.OS_WIN32)) { 			String[] winCmdLine = new String[cmdLine.length]; 			for (int i = 0; i < cmdLine.length; i++) { 				winCmdLine[i] = winQuote(cmdLine[i]); 			} 			cmdLine = winCmdLine;  Changing it to ""for(int i=1 ...)"" fixes the issue."
"Consider the following:  public class BugExample{ 	public static final int CONSTANT = 5; 	 	public static void main(final String[] args)	{//...} }   In eclipse Kepler when sorting the members (Source -> Sort Members...) it would stay as is. In eclipse Luna (4.4M7) it changes to:  public class BugExample{ 		 	public static void main(final String[] args)	{//...}          public static final int CONSTANT = 5; }   The same workspace/project settings are used with both luna and kepler. I tried switching back and forth between kepler and luna and kepler always prefers the first variant while luna always prefers the second.    My Java->Appearance->Members Sort Order is like this: Types Static Fields Static initializers Static methods Fields Initializers Constructors Methods   Assuming ""static"" and ""static final"" fields are encompassed in ""Static Fields"", I think the correct behavior is the one in Kepler."
Here are a few cases where i don't get any code completion in closures using Luna M7  I've written the places where i trigger code completion in the line above .n means no proposals .y means completion works fine   Case 1                           .n  .n              .y    new Thread(() -> System.out.println("foo")).start();   Case 2     List<Integer> list = Arrays.asList(1, 2, 3);                                   .y                              :n    list.stream().map((x) -> x * x.hashCode()).forEach(System.out::println);  Case 3     List<Integer> costBeforeTax = Arrays.asList(100, 200, 300);    double bill = costBeforeTax.stream().map((cost) -> cost + 0.19 * cost)                                 .y                   .n             .y       .reduce((sum, cost) -> sum.doubleValue() + cost.doubleValue()).get();  That last case is particulary interesting as i don't even get an empty list of proposals. JDT doesn't seem to think you can trigger code completion here.
+++ This bug was initially created as a clone of Bug #435213 +++  > The hover is not shown. Instead of that a NPE is shown in the errorlog.  Manju, please prepare a patch that avoids the NPE in JavadocHover#addAnnotation(..). It's OK if the link is not re
"Place the following files in respective packages:  //////////////////////////////// package p4a;  @FunctionalInterface public interface FI1<R> {     public R foo1(); }  //////////////////////////////// package p4a;  @FunctionalInterface public interface FI2 {     public void foo2(); } //////////////////////////////// package p4b;  import p4a.FI1;  public class Test { 	{                 new FI2() {}; 		FI1 fi1 = () -> new FI2() { 		    @Override 		    public void foo2() {} 		}; 	} }  ////////////////////////////////  In class Test, hover on the error at second 'FI2'. No quick fix is provided to import 'FI2'.  Also, see bug 434884 comment #3: org.eclipse.jdt.internal.ui.text.correction.SimilarElementsRequestor#findSimilarElement(ICompilationUnit, Name, int) does get an anonymous class completion proposal with the caret after the first ""new FI2"", but not after the second one inside the lambda."
"Consider the below code snippet: package p1;  import java.util.function.Consumer;  public class Test {     static void run(Consumer<Integer> consumer) { // type '@' before Consumer<Integer>         System.out.println(""consumer"");     }     static {         run(new Consumer<Integer>() {             @Override             public void accept(Integer integer) {                 System.out.println(andThen(null));             }         });     } }  Type '@' as mentioned in the code and there are multiple NPE thrown.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.anonymousOriginalSuperType(LocalTypeBinding.java:89) 	at org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.sourceName(LocalTypeBinding.java:282) 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.illegalModifierForLocalClass(ProblemReporter.java:2776) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkAndSetModifiers(ClassScope.java:638) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildLocalType(ClassScope.java:204) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildAnonymousTypeBinding(ClassScope.java:62) 	at org.eclipse.jdt.internal.compiler.lookup.BlockScope.addAnonymousType(BlockScope.java:94) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:538) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
- Reproducing the Bug: Create a new Project with Java 8, make sure that "Enable Annotation-Based Null Analysis" is enabled and the configured Null Annotations are the new ones with @Target({ TYPE_USE })  - Create a Class Bug1: package bug;  import org.ecl
Eclipse Version: Kepler Service Release 2 Build id: 20140224-0627  I am interested to know why new CompositeStatement() and new Expr2() {} can be created at lines 17 and 31 but not at line 40.    import java.util.ArrayList;   public class Demo {                 static class ExprFactoryList extends ArrayList<Object> {                                 class Expr {}                 class Expr2 extends Expr {}           }                 final static ExprFactoryList arith =  new ExprFactoryList() {                   {                         add(new Object() {public Expr generate() {return new Expr() {};} }); // OK                         add(new Object() {public Expr generate() {return new Expr2() {};} }); // Ok                 }                         };                 final static ExprFactoryList statementFactory =  new ExprFactoryList() {                                 class Statement extends Expr {}                                 void m() {                                                 add(new Object() {                                 public void generate() {                                         new Statement(){}; // OK                                 }                         });                 }                                 {                         add (new Statement()); // OK                                                 add(new Object() {                                 public void generate() {                                         new Statement(); // OK                                                                                 // No enclosing instance of type new                                         // Demo.ExprFactoryList(){} is accessible to invoke the                                         // super constructor. Must define a constructor and                                         // explicitly qualify its super constructor invocation with                                         // an instance of new Demo.ExprFactoryList(){} (e.g.                                         // x.super() where x is an instance of new                                         // Demo.ExprFactoryList(){}).                                         new Statement(){}; // cannot compile                                                                         }                         });                                         }                         };         }  See formatted http://pastebin.com/61gyGE02 I would be surprised if this is not a bug.
"While testing bug 421479, found the following case where conversion of nested anonymous classes to lambda results in variable name conflict. (In the example, convert the inner anonymous class to lambda using the quick assist): ---------------------------------------------------------------- interface FI { 	int e= 0; 	void run(int x); }  class NewTest { 	{ 		 		FI fi = new FI() { 			@Override 			public void run(int e) { 				FI fi = new FI() { 					@Override 					public void run(int e) { 						return; 					} 				}; 			} 		}; 	} }  ----------------------------------------------------------------  It happens because in ScopeAnalyzer.DefaultBindingRequestor.acceptBinding(IBinding), we avoid adding a binding to the result if a binding with the same variable name was added earlier.  In the above example, binding for 'e' (from the field in FI) is added first in the result and when we try to add 'e' again (from the method param of outer anonymous class), it is not added to the result.  Hence, the resultant bindings contain the binding for field 'e' and not for the method parameter 'e'.  In ASTNodes.getVisibleLocalVariablesInScope(ASTNode node), we ignore field bindings due to which 'e' is ignored and the list of excluded names misses the name 'e'."
Update JDT T&T document with relevant items from Luna (4.4) N&N documents.
"The following code throws NPE.  From bug 433825 comment 18  import java.util.ArrayList; import java.util.Collection;  public class CompilerCrashesWithNPE {      public void bla() {     boolean b = Boolean.TRUE.booleanValue();     Collection<?> c1 = new ArrayList<String>();     new Bar(b ? new ArrayList<>(b ? new ArrayList<>() : c1) : c1);   }    private static class Bar {     public Bar(Collection<?> col) {     }   } }  Exception thrown:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:286) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:287) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.generateCode(AllocationExpression.java:215) 	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:278) 	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:287) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.generateCode(AllocationExpression.java:215) 	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:705) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:325) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:270) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)"
(This is mainly copied from a stackoverflow question I posted: http://stackoverflow.com/questions/23797972/type-error-using-generics-under-java-8-but-not-java-7)  I have a piece of code which used to compile under Java 7 (both with javac and Eclipse). After switching to Java 8, javac gives a type error, and Eclipse (I tried 4.3.2 with the Java 8 support feature patch, and also 4.4RC1) fails to build with an internal compiler error.  This is the javac error:      /path/to/Match.java:65: error: method transform in class Iterables cannot be applied to given types;                 return Joiner.on(", ").join(Iterables.transform(list, AstFunctions.prettyPrint()));                                                      ^       required: Iterable<F>,Function<? super F,? extends T#1>       found: List<CAP#1>,Function<ASTNode<?>,String>       reason: cannot infer type-variable(s) F,T#1,T#2         (argument mismatch; Function<CAP#1,String> cannot be converted to Function<? super CAP#1,? extends String>)       where F,T#1,T#2 are type-variables:         F extends Object declared in method <F,T#1>transform(Iterable<F>,Function<? super F,? extends T#1>)         T#1 extends Object declared in method <F,T#1>transform(Iterable<F>,Function<? super F,? extends T#1>)         T#2 extends ASTNode<?> declared in method <T#2>prettyPrint()       where CAP#1 is a fresh type-variable:         CAP#1 extends ASTNode<?> from capture of ? extends ASTNode<?>     1 error   The offending line is:      return Joiner.on(", ").join(Iterables.transform(list, AstFunctions.prettyPrint()));  [`Joiner`](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Joiner.html) and [`Iterables`](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterables.html) are from the latest version of Guava.  `list` is an instance of `ast.List<? extends ASTNode<?>>`, which is generated code I can't really control. The classes are declared like this:      public class ASTNode<T extends ASTNode> extends beaver.Symbol                                             implements Cloneable, Iterable<T>      public class List<T extends ASTNode> extends ASTNode<T> implements Cloneable  And `AstFunctions.prettyPrint()` is declared like this:      public static <T extends ASTNode<?>> Function<T, String> prettyPrint()  where again `Function` is the Guava `Function`.  Eclipse fails to build with this error:  An internal error occurred during: "Building workspace". java.lang.StackOverflowError  An error annotation is placed at the package declaration in that file, with this tooltip:      Internal compiler error: java.lang.StackOverflowError at       org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.substituteInferenceVariable(ParameterizedTypeBinding.java:856)
package bug;  import java.lang.annotation.Documented; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={}) public @interface Ann1 { } ---------------------------------------------- - Place the above code in a 1.8 java project. - Select the file and press Ctrl+H to bring up the Search dialog. - In Java Search, give Search string as '*', Search For as 'Method', Limit To as 'Match Locations' with ''::' method references' selected and Scope as 'Selected resources'. Click Search. - The result shows 'value' in the result from the given example.
"According to bug 411771 enum constants should not lead to warnings but it looks like this only works when the enum is declared in the same class as the usage happens.  package bla;  public enum Bla { 	A, 	B }   package bla;  import org.eclipse.jdt.annotation.NonNull;  public class Blo { 	public enum Bli { 		A, 		B 	} 	 	@NonNull 	public Bla bla = Bla.A; // warning 	 	@NonNull 	public Bli bli = Bli.A; // no warning }"
"//---- @org.eclipse.jdt.annotation.NonNullByDefault public class Test<E> { 	void test() throws E {} } //----  Error:  	void test() throws E {}                            ^ Nullness annotations are not applicable at this location"
"ImportReferencesCollector needs to support old AST levels, see bug 435540.  org.eclipse.jdt.ui.actions.OverrideMethodsAction#createRunnable(..) is a legal way to create an AddUnimplementedMethodsOperation, and there's no restriction on the AST level there. Most of JDT UI only uses the latest AST level, but in this case, we have to support older levels as well.  org.eclipse.jst.j2ee.ejb.annotation.model Error Thu May 22 19:26:03 EEST 2014 Operation only supported in JLS8 and later AST  java.lang.UnsupportedOperationException: Operation only supported in JLS8 and later AST 	at org.eclipse.jdt.core.dom.ASTNode.unsupportedIn2_3_4(ASTNode.java:1968) 	at org.eclipse.jdt.core.dom.AnnotatableType.annotations(AnnotatableType.java:99) 	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.visit(ImportReferencesCollector.java:203) 	at org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:197) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:469) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:212) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) 	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.collect(ImportReferencesCollector.java:68) 	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.collect(ImportReferencesCollector.java:62) 	at org.eclipse.jdt.internal.corext.codemanipulation.ContextSensitiveImportRewriteContext.getImportedNames(ContextSensitiveImportRewriteContext.java:226) 	at org.eclipse.jdt.internal.corext.codemanipulation.ContextSensitiveImportRewriteContext.findInContext(ContextSensitiveImportRewriteContext.java:99) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:941) 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:639) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createThrownExceptions(StubUtility2.java:509) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:349) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:315) 	at org.eclipse.jdt.internal.corext.codemanipulation.AddUnimplementedMethodsOperation.run(AddUnimplementedMethodsOperation.java:213) 	at org.eclipse.jst.j2ee.ejb.annotations.internal.classgen.EjbBuilder.createInheritedMethods(EjbBuilder.java:221) ..."
Update the F1 help and documentation for JDT features from Luna M1-M7 N&N documents.
"Version: Luna M7 Release (4.4.0M7) Build id: 20140508-1440  In the code below, on the second line code assist shows ""no default proposal"" when invoked at the |.  List<String> words = Arrays.asList(""hi"", ""hello"", ""hola"", ""bye"", ""goodbye""); List<String> list1 = words.stream().map(s -> s.|).collect(Collectors.toList());  Also no code assist when the type is specified like in this line. List<String> list2 = words.stream().map((String s) -> s.|).collect(Collectors.toList());   Note that in the second example the code assist worked in  Kepler (Version: 4.3.2, Build id: M20140221-1700) with Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20131108-0105_BETA_JAVA8. But a compilation error (Type mismatch: cannot convert from List<Object> to List<String>) was given in kepler when the line was completed as  List<String> list = words.stream().map((String s) -> s.toUpperCase()).collect(Collectors.toList()); In Luna this line compiles ok."
JDT fails to infer a type from a method reference inside a lambda expression in the following case:  static class Foo<T> {   <U> void apply(Function<T, Consumer<U>> bar) {} }  static class Bar {   void setBar(String bar){} }  new Foo<Bar>().apply(bar -> bar::setBar);  While this works with javac, a compile error message is given in Eclipse:  "The type FailingTestTest.Bar does not define setBar(Object) that is applicable here"  When explicitly parameterized things compile fine.  new Foo<Bar>().<String>apply(bar -> bar::setBar);
"Using Eclipse Kepler with the Java 8 update. Project uses Java 8 as language level and old-style annotations. This is a Java 7 project that used the nullness annotations extensively and that is being upgraded to Java 8.  The following code: package to.etc.saram;  import javax.annotation.*;  public class TestNulls { 	public void testCase(@Nullable String theValue) { 		int len = theValue.length();					// Is nullable, so should report error here. 	} } fails to report any error or warning on the dereference of theValue which can be null there.  The annotations are defined as java < 8 declaration style annotations (the JSR305 ones): package javax.annotation;  import java.lang.annotation.*;  @Documented @Retention(RetentionPolicy.CLASS) @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE}) public @interface Nullable { 	// marker annotation with no members }  When the above code is compiled with a JavaSE-1.7 on the project build path then the code reports an error properly. Switching the JDK to JavaSE-1.8 (and thereby also switching compliance level) makes the error disappear.  I know that these should be migrated to type use annotations, but that cannot ""just be done"" in a project that already uses the declaration style annotations a lot. As far as I can see moving from declaration style to type style annotations is a rather big effort: - the annotation's ""location"" needs to change wrt Java 8 rules. This leads to a lot of source code changes that all need to be tested. - There seems to be a rather big incompatibility with mixing old and new style annotations inside a workspace, so that @Nonnull definitions done in a java 7 project cause errors in a dependent project which moved to java 8 (xxx does not constrain that parameter). Similar seems to be the effect that things annotated as @Nonnull in a java 7 project are not recognized as @Nonnull in a Java 8 project that uses them.  Just switching to java 8 and updating the annotations to type_use for that project causes quite some problems: more than around 1000 in my not too big project. And having this bug means moving up to Java 8 is an all-or-nothing effort unless we completely disable the nullity annotations?"
"Created attachment 243519 [details] Test  Compile the attached code to get the following stack trace:  java.lang.ArrayIndexOutOfBoundsException: 800 	at org.eclipse.jdt.internal.compiler.ClassFile.generateBootstrapMethods(ClassFile.java:2962) 	at org.eclipse.jdt.internal.compiler.ClassFile.addAttributes(ClassFile.java:385) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:577) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1210) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
"I downloaded 4.4 RC2 to see if some previously reported bugs had been fixed. Upon opening Eclipse, multiple StackOverflowErrors popped up:  An internal error occurred during: ""Building workspace"". An internal error occurred during: ""Decoration Calculation"". Background Indexer Crash Recovery  These errors only seem to affect one of my projects, and happen for any of the following situations:   - Continuously while an editor window for one of the classes in the affected project is open  - When navigating in Package Explorer and an open package contains a .java file  - When Eclipse starts  - package-info.java with @NonNullByDefault is altered and saved  - Clicking on any element in the editor (e.g. a variable/type)  It all seems to be related to type annotations and/or null annotations, and from the stack traces, all seem to be related to the same lines of code.  Here are the stack traces in the same order I listed the errors:  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.kind(TypeVariableBinding.java:578) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.original(TypeBinding.java:1391) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.findSuperTypeOriginatingFrom(TypeBinding.java:379) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:205) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) ......(repeats)......  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:143) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) .......(repeats).......   java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.original(TypeBinding.java:1391) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.findSuperTypeOriginatingFrom(TypeBinding.java:376) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:205) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) .......(repeats)......  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.findSuperTypeOriginatingFrom(TypeBinding.java:338) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:205) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) ..........(repeats)......  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.areSameTypes(NullAnnotationMatching.java:240) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:143) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:161) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:215) ..........(repeats)  If it helps, the errors only occur when the Eclipse null analysis annotations are added to the build path. Currently working on producing a short example."
"Big of a minor bug, but kind of annoying when I want to try to get rid of all warnings from my project.  This is a little tricky to describe... I'm trying to use an enum to implement a singleton visitor for an AST. Eclipse warns about the use of the visitor as needing unchecked conversion to conform to @NonNull. I use @SuppressWarnings(""null"") to suppress that warning. Eclipse then warns that the just-added annotation is unnecessary. If I remove it, the original warning comes back. And so on and so forth.  An example project is attached. The warning occurs in Program.java, for execute(). My apologies for not being able to narrow down classes further. Making separate classes/enums into inner classes caused the warning to vanish. Removing ConcreteNodeVisitor caused the warning to vanish. I'm not sure what's going on...  Also, an exception occurred when moving interfaces from package to package while trying to get rid of unnecessary classes. I couldn't reproduce this reliably, though:  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:423) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:637) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153) 	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveWizard$MoveInputPage.performFinish(ReorgMoveWizard.java:122) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455) 	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:466) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:619) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4188) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1279) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4031) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:832) 	at org.eclipse.jface.window.Window.open(Window.java:808) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122) 	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38) 	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveStarter.run(ReorgMoveStarter.java:80) 	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.handleDropMove(SelectionTransferDropAdapter.java:283) 	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.performDrop(SelectionTransferDropAdapter.java:220) 	at org.eclipse.jdt.internal.ui.dnd.JdtViewerDropAdapter.drop(JdtViewerDropAdapter.java:246) 	at org.eclipse.jface.util.DelegatingDropAdapter$3.run(DelegatingDropAdapter.java:219) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50) 	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178) 	at org.eclipse.jface.util.DelegatingDropAdapter.drop(DelegatingDropAdapter.java:216) 	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:91) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4188) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1279) 	at org.eclipse.swt.dnd.DropTarget.drop(DropTarget.java:728) 	at org.eclipse.swt.dnd.DropTarget.outlineView_acceptDrop_item_childIndex(DropTarget.java:746) 	at org.eclipse.swt.dnd.DropTarget.dropTargetProc(DropTarget.java:471) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.dnd.DropTarget.dndCallSuper(DropTarget.java:210) 	at org.eclipse.swt.dnd.DropTarget.performDragOperation(DropTarget.java:739) 	at org.eclipse.swt.dnd.DropTarget.dropTargetProc(DropTarget.java:456) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.mouseDownSuper(Widget.java:1101) 	at org.eclipse.swt.widgets.Tree.mouseDownSuper(Tree.java:2044) 	at org.eclipse.swt.widgets.Widget.mouseDown(Widget.java:1093) 	at org.eclipse.swt.widgets.Control.mouseDown(Control.java:2563) 	at org.eclipse.swt.widgets.Tree.mouseDown(Tree.java:2012) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5628) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2105) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2329) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5692) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5129) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5278) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3655) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1152) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1033) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) Caused by: java.lang.ArrayIndexOutOfBoundsException"
+++ This bug was initially created as a clone of Bug #436048 +++  Bug 436048 fixed all major cases, but a few left in JDT:   eclipse.jdt/org.eclipse.jdt-feature/rootfiles/notice.html eclipse.jdt/org.eclipse.jdt/notice.html  Marking as minor, since these a
"Tested using Build id: I20140522-1330 Consider the below code snippet:  package p1; interface FI { 	void foo(ArrayList<IOException> x); // Invoke F4 on foo }  package p3;  import java.io.IOException; import java.util.ArrayList;  public class C1 {  	private Object patternChanged(ArrayList<IOException> x1) {  		FI f1 = new FI() {  			public void foo(ArrayList<IOException> x) { 			} 		}; 		return null; 	}  	private void someOtherMethod() { 		FI f2 = (x) -> { 			patternChanged(x); 		};  		FI f3 = new FI() { 			public void foo(ArrayList<IOException> x) { 			} 		}; 	} }  Invoking 'F4' to compute the Type Hierarchy of 'FI#foo' returns only 2 implementation, expected was 3. If 'f2' is commented out then 'f3' is revealed in the search."
Users can configure problem severity from the problem marker if they press F2. However, it seems that users are unaware of this [1]. Can we consider making this action a quick-fix?  [1] http://dev.eclipse.org/mhonarc/lists/ide-dev/msg00515.html
"package bug;  import org.eclipse.swt.widgets.Text;  class T2 { 	Text text = new Text(null, 0);  	private void bar() { 		text.setSelection(0); 	} } --------------------------------------------------  Place the caret at #setSelection in the above example and press Ctrl+T. The resulting quick type hierarchy pop-up is empty.  Place caret at ""Text"" and press F4.  Type Hierarchy view shows only ""Object"".  This used to work before Java 8 related code changes (up to I20140311-1200)."
While fixing bug 436219, and then testing it and finding buildnotes were no longer collected, I also happened to notice that the astview bundle has (and apparently old) "buildnotes" file:   .../eclipse.jdt.ui/org.eclipse.jdt.astview/buildnotes_astview.html  I suspect this is not worth fixing for "the last week of Luna" simply because that'd change the qualifier, which would effect the feature qualifier, etc., ... and we all know what trouble that's been lately.   But, suggest that it be removed (or .. updated?) in maintenance (and master) after we release Luna.
"Hello,  updating a complex Maven Project leads to the following error:  java.lang.NegativeArraySizeException 	at org.eclipse.jdt.internal.core.ClassFileInfo.generateMethodInfos(ClassFileInfo.java:273) 	at org.eclipse.jdt.internal.core.ClassFileInfo.readBinaryChildren(ClassFileInfo.java:420) 	at org.eclipse.jdt.internal.core.ClassFile.buildStructure(ClassFile.java:98) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259) 	at org.eclipse.jdt.internal.core.SourceRefElement.generateInfos(SourceRefElement.java:107) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557) 	at org.eclipse.jdt.internal.core.BinaryType.getElementInfo(BinaryType.java:287) 	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:280) 	at org.eclipse.jdt.internal.core.JavaElement.exists(JavaElement.java:198) 	at org.jboss.tools.common.util.EclipseJavaUtil.findType(EclipseJavaUtil.java:116) 	at org.jboss.tools.common.java.ParametedTypeFactory.getParametedType(ParametedTypeFactory.java:128) 	at org.jboss.tools.common.java.ParametedTypeFactory.getParametedType(ParametedTypeFactory.java:80) 	at org.jboss.tools.cdi.internal.core.impl.definition.ParameterDefinition.init(ParameterDefinition.java:43) 	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64) 	at org.jboss.tools.cdi.internal.core.impl.definition.ParameterDefinition.setLocalVariable(ParameterDefinition.java:37) 	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.loadParamDefinitions(MethodDefinition.java:87) 	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.init(MethodDefinition.java:63) 	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64) 	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.setMethod(MethodDefinition.java:48) 	at org.jboss.tools.cdi.internal.core.impl.definition.TypeDefinition.init(TypeDefinition.java:70) 	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64) 	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractTypeDefinition.setType(AbstractTypeDefinition.java:69) 	at org.jboss.tools.cdi.internal.core.impl.CDIProject.rebuildBeans(CDIProject.java:1310) 	at org.jboss.tools.cdi.internal.core.impl.CDIProject.update(CDIProject.java:1172) 	at org.jboss.tools.cdi.internal.core.impl.CDIProject.update(CDIProject.java:1199) 	at org.jboss.tools.cdi.internal.core.impl.definition.DefinitionContext.applyWorkingCopy(DefinitionContext.java:419) 	at org.jboss.tools.cdi.core.CDICoreBuilder.build(CDICoreBuilder.java:247) 	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246) 	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302) 	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358) 	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381) 	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143) 	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)  I have seen bug fixes for ArrayOutOfBoundsExceptions in this way but it seems the problem has not been fixed completely.  Regards,  Heiko   eclipse.buildId=4.4.0.I20140601-2000 java.fullversion=JRE 1.7.0 IBM J9 2.6 Windows 7 amd64-64 Compressed References 20140106_181350 (JIT enabled, AOT enabled) J9VM - R26_Java726_SR6_20140106_1601_B181350 JIT  - r11.b05_20131003_47443.02 GC   - R26_Java726_SR6_20140106_1601_B181350_CMPRSS J9CL - 20140106_181350 BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE Command-line arguments:  -os win32 -ws win32 -arch x86_64"
Created attachment 243774 [details] Code that demonstrates the bug  In the attached sample I have a Generic Interface which accepts generic objects, and a specialised subinterface which accepts specialised objects, and provides a default method for the generic interface's method, which delegates to the specialised implementation.  If I implement the specialised method in an anonymous class, and pass it to some code that calls the generic method, then the code correctly executes and passed through to the specialised method.  However, if, rather than implementing the anonymous class, I use a lambda expression, the code compiles fine, but at runtime I get an AbstractMethodError "java.lang.AbstractMethodError: Method LambdaBugDemo$$Lambda$1.reduce(Ljava/util/Iterator;)Ljava/lang/Object". Apparently, the default method is not picked up.  This code compiles and runs fine on Oracle JDK 1.8_05 for OsX. It compiles fine in eclipse, but the generated code throughs the error as specified.  The attached java file contains a full demonstration of the problem.
From bug 421601 comment 6:  It seems that the following call stack is disturbing evaluation of null annotations:          at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:776)           at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:767)           at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.resolveAnnotations(AnnotationDiscoveryVisitor.java:233)                                                           at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.visit(AnnotationDiscoveryVisitor.java:217)                                                                        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1338)                                                                                                   at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:745)                                                                              at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:706)                                                                              at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.<init>(RoundEnvImpl.java:58)                                                                                                    at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:148)                                                   at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:818)             at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434)                        at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:4129)              at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1694)                         at org.eclipse.jdt.internal.compiler.batch.Main.main(Main.java:1405)                     Normally in the compiler, ASTNode.resolveAnnotations would be invoked from STB.getAnnotationTagBits() and during this call we would also invoke STB.evaluateNullAnnotations().  With APT in the loop, however, ASTNode.resolveAnnotations sets TagBits.AnnotationResolved and whenever STB.getAnnotationTagBits() is called, we do nothing, so STB.evaluateNullAnnotations() is never invoked.
This bug has been reproduced with Eclipse 4.4RC3, both on Linux and on Mac.  Here are the steps to reproduce.  Make a new project called test in your workspace.  In a test.Utility class, paste this code (I trimmed the class down as best I could to just the problematic part):  ///// package test;  import java.util.Collection; import java.util.List; import java.util.function.Function; import java.util.stream.Collectors;  import javafx.collections.ListChangeListener; import javafx.collections.ObservableList;  public class Utility {          public static <T, R> List<R> mapList(Collection<T> original, Function<T, R> func)     {         return original.stream().map(func).collect(Collectors.toList());     }     /**      * "Binds" the destination list to the observable source list with a transformation function applied.      * Whenever the source list changes, the destination list is altered to match by applying      * the given function to each element in the source list.      */     public static <S, T> void bindMap(List<T> dest, ObservableList<S> src, Function<S, T> func)     {         dest.clear();         dest.addAll(mapList(src, func));                  src.addListener((ListChangeListener<S>) changes -> {             while (changes.next())             {                 if (changes.wasPermutated() || changes.wasUpdated())                 {                     // Same code for updated, replaced and permutation, just recalc the range:                     for (int i = changes.getFrom(); i < changes.getTo(); i++)                         dest.set(i, func.apply(src.get(i)));                 }                 else                 {                     for (int i = 0; i < changes.getRemovedSize(); i++)                         dest.remove(changes.getFrom());                     for (int i = 0; i < changes.getAddedSubList().size();i++)                         dest.add(i + changes.getFrom(), func.apply(changes.getAddedSubList().get(i)));                 }             }         });              }  }  //////  Let eclipse compile that class -- it should compile successfully, once your source level is set to Java 8.  In a terminal window, create this simple Import.java file:  ////// import test.Utility;  class Import { } //////  Then ask javac (I am using 8u5, the current latest javac release) to compile it, giving the classpath to the .class files from the Eclipse project:  javac Import.java -cp ~/workspace/test/bin/  I get back the following response:  Import.java:1: error: cannot access Utility import test.Utility;            ^   bad class file: /home/neil/workspace/test/bin/test/Utility.class     undeclared type variable: T     Please remove or make sure it appears in the correct subdirectory of the classpath.  If I get javac to compile both classes, everything works fine.  If I get eclipse to compile both classes, everything works fine.  But if eclipse compiles the Utility class and javac the Import class (which I need to do in my workflow), I get this message.  My best guess is that this is an eclipse bug (generating a bad class file), so I am filing it here.  If you think it is instead a javac bug (rejecting a valid class file) then let me know and I will file it against javac instead.
Build: http://download.eclipse.org/eclipse/downloads/drops4/I20140603-2300/testResults.php  There are failures in Linux as well as Windows all appear to be in TypeHierarchyTests. Perhaps related to the fix went for bug 436155 ?
4.4 RC4.  We should add quick fixes for 'Duplicate default methods' error which override the method and calls one of the available default methods.
"When the declaring class of enclosing instances is ""generic"", the precondition for checking references to enclosing instances does not work.  Applying move-instance-method to method m() results in an error below.  ------------------------------ BEFORE ------------------------------  class A<T> { 	int i;  	class C { 		B b = null; 		void m() { 			i = 0; 		} 	} }  ------------------------------ AFTER ------------------------------  class A<T> { 	int i;  	class C { 		B b = null; 	} }  import p.A.C;  class B{  	void m(C c) { 		i = 0;	//ERROR 	}  }  ------------------------------ Here is the error location.  JDT Classic version: 4.2.2  Class Name: org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor  Source code:  ...  public final class EnclosingInstanceReferenceFinder extends AstNodeFinder {  		...  		@Override 		public final boolean visit(final SimpleName node) { 			Assert.isNotNull(node); 			final IBinding binding= node.resolveBinding(); 			ITypeBinding declaring= null; 			if (binding instanceof IVariableBinding) { 				final IVariableBinding variable= (IVariableBinding) binding; 				if (Flags.isStatic(variable.getModifiers())) 					return false; 				declaring= variable.getDeclaringClass();    //getDeclaringClass() returns NULL when the declaring class is ""generic"".  		..."
"The following code compiles with javac:  import java.util.*;  public class ExecutorTests {     List<Runnable> tasks = Arrays.asList(             () -> {                 System.out.println(""task1 start"");             }     );      public void executeInSync(){         tasks.stream().forEach(Runnable::run);     } }   but not with ECJ:  The method asList(T...) in the type Arrays is not applicable for the arguments (() -> {})	ExecutorTests.java	line 4	Java Problem The target type of this expression must be a functional interface	ExecutorTests.java	line 5	Java Problem   It can be made to compile by changing it to ""Arrays.<Runnable>asList(...""  This was reported in http://stackoverflow.com/questions/24122672/ajc-wont-compile-lambda-as-an-vararg-argument originally against AspectJ but AspectJ is based on JDT and this is failing in Luna RC3 too."
"I'm not really sure if this is because I'm not understanding how multidimensional arrays are implemented in Java, but this warning seems a bit off to me.  I have @NonNullByDefault on the package level, yet for some reason new int[][] causes a unchecked conversion warning:  Null type safety (type annotations): The expression of type 'int[][]' needs unchecked conversion to conform to 'int @NonNull[] []'  For the class  public class Puzzle { 	private final int n; 	private final int[][] grid; 	 	Puzzle(final int size) { 		n = size; 		@NonNull 		final int[][] temp = new int[n][n]; 		grid = temp; 	} }  Seems that @NonNull is only applied to one of the dimensions (the inner dimension?), so the outer is left as Nullable which raises the warning.  In other cases where I have encountered something like this (e.g. Java's built-in methods, such as Integer.valueOf()), it makes sense as those classes don't have null annotations, so the null analyzer can't make any assumptions for those. In those cases, I just assign the result to a temporary variable and suppress the warning there (which I find strange, as given the presence of the @NonNullByDefault annotation I shouldn't need to use @NonNull explicitly):  @SuppressWarnings(""null"") @NonNull Integer temp = Integer.valueOf(x); target = temp  However, @NonNull has no effect on int[][] temp = new int[n][n];, as the warning persists unchanged."
From https://www.eclipse.org/forums/index.php/mv/msg/781682/1385694/#msg_1385694  For the following code:  String[] arguments = // Call to a library code with no annotations, could return anything. if (arguments != null) {     String @NonNull [] temp = arguments; }   The assignment (temp to arguments) gives the following warning:  Null type safety (type annotations): The expression of type 'String[]' needs unchecked conversion to conform to 'String @NonNull[]'
Follow-up to bug 391389. There are other scenarios where Eclipse asks for a new file name, and those should behave the same as the Rename dialog.  E.g. when you copy/paste a file in the Package Explorer, the dialog should also pre-select the file name without the extension.
Created attachment 244239 [details] test case exposing the bug  In a batched build, annotation processing may not run on all compilation units. Please take a look at the attached test case that exposes the problem.  In the test case there are 2 classes, Foo and Bar that have references to each other. The batch size is set to 1. Suppose that Foo is in the first batch. Foo has a reference to Bar, so both Foo and Bar are compiled in the first batch, but only Foo was actually passed to the compiler, so only Foo has annotation processing run on it. Then in the second batch, we detect that Bar was compiled in the first batch, so we are done with compiling. The problem is that then Bar never has annotation processing run on it.
When investigating differences between javac and ecj, we can identify situation(s) where ecj finds an acceptable solution, which javac does not find, while in fact JLS does not provide an explicit path towards that solution.  This bug shall collect deviations that match the above description. Users will typically *not* complain about these, but still being more in line with JLS is desirable.
Both javac and ECJ are missing a compile error in Java 8 mode for a field access of the form Interface.super.field:  interface T {     int f = 0;     void foo();     default String def() { return "T.def"; } } class S {     public static final int f = 0; }  class C extends S implements T {     @Override     public void foo() {         System.out.println(T.super.f); // no error in Java 8 (wrong)         System.out.println(T.super.def()); // new JLS8 15.12.1 form (OK)         System.out.println(S.super.f); // compile error (correct)     } }  class Test {     T f = new T() {         @Override         public void foo() {             System.out.println(T.super.f); // no error in Java 8 (wrong)         }     }; }  JLS 8 15.11.2 only defines T.super.f for cases where T is a lexically enclosing class, so the Interface.super.field form still needs to trigger a compile error. JLS 8 15.12.1 is not applicable here.  Thanks Noopur for coming up with the initial example for this problem.  Jay/Srikanth/Stephan: If you agree with my analysis, then we should report this to Oracle as well.
"While formatting the source code it gives following exception -  java.lang.ArrayIndexOutOfBoundsException: -1 	at org.eclipse.jdt.internal.formatter.Scribe.getNewLineString(Scribe.java:1137) 	at org.eclipse.jdt.internal.formatter.Scribe.getEmptyLines(Scribe.java:1062) 	at org.eclipse.jdt.internal.formatter.Scribe.printEmptyLines(Scribe.java:3050) 	at org.eclipse.jdt.internal.formatter.Scribe.preserveEmptyLines(Scribe.java:1584) 	at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2584) 	at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2414) 	at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:714) 	at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:3294)   With analysis I found out the root cause to be commented import statement as shown below - import org.hibernate.validator.HibernateValidator; import org.hibernate.validator.HibernateValidatorConfiguration;  //import javax.validation.*; import javax.validation.Configuration;"
Attempting to trigger Quick Type Hierarchy (Ctrl+T) on a blank line (or a line containing only comments) between two import declarations results in an empty Quick Type Hierarchy popup and an Error event in the log.  I would expect Quick Type Hierarchy triggered in this location either  a) to display the type hierarchy of the compilation unit's main type, as is done when QTH is triggered on other blank lines, b) to display the type hierarchy of one of the adjacent imports, or c) to do nothing (show no popup)  I've attached a minimal Java file where this issue occurs.  I've reproduced this on 4.3.2 and 4.4.RC4.  Here are the Event Details for the event that gets logged:  Severity: Error  Message: Element unsupported by the hierarchy: class org.eclipse.jdt.internal.core.ImportContainer  Exception Stack Trace: An exception stack trace is not available.
The following code compiles cleanly under JDK8 but has a compile error use the Eclipse compiler:  package junk;  public class Junk16 {      public static String junk(String format, Object... args) {         return null;     }      public static String junk(String... s) {         return null;     }          public static void main(String[] args) {                  // COMPILE ERROR IN ECLIPSE (none in JDK)         junk("fred");                  //NO COMPILE ERROR         junk("fred", 12);     } }
For the program below (which has no nullness annotation except for @NonNullByDefault), the compiler issues the warning "The nullness annotation is redundant with a default that applies to this location"  import org.eclipse.jdt.annotation.NonNullByDefault; import static org.eclipse.jdt.annotation.DefaultLocation.*;  @NonNullByDefault({ PARAMETER, RETURN_TYPE, FIELD, TYPE_BOUND, TYPE_ARGUMENT, TYPE_PARAMETER }) interface Bar<V> {     V getV(); }  By choosing the quick fix "remove redundant nullness annotation", one gets: An exception occurred while applying the quick fix: The fix 'Remove redundant nullness annotation' generated a null change.
"The luna final version that was released today still has problems with null annotations:  @NonNullByDefault public class Test {	 	private Fu<String> fu = new Fu<>();	 	public void foo() { 		fu.method();   // 'Contradictory null annotations' error 	} } class Fu<T> {		 	@Nullable T method() { 		return null; 	} }  The exact error is ""Contradictory null annotations: method was inferred as '@NonNull @Nullable String method()', but only one of '@NonNull' and '@Nullable' can be effective at any location""  They might be related to similar bugs I reported before: https://bugs.eclipse.org/bugs/show_bug.cgi?id=432223 https://bugs.eclipse.org/bugs/show_bug.cgi?id=434899"
For the following program (with annotation-based null analysis enabled), one get a NullPointerException from the compiler:  Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.contradictoryNullAnnotationsOnBounds(ProblemReporter.java:9522)  @org.eclipse.jdt.annotation.NonNullByDefault(org.eclipse.jdt.annotation.DefaultLocation.TYPE_BOUND) public interface FooBar {     <@org.eclipse.jdt.annotation.Nullable R extends Runnable> R foobar(R r); }
Created attachment 244578 [details] An internal error occurred during: "Building workspace".  I get this exception after the upgrade from Kepler to Luna when building my projects (maven, java, wtp)  Stacktrace attached.
With annotation-based null analysis enabled, there is a bogus warning for the following program:  import java.util.*; import java.util.function.Supplier; import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class Foo {     static void foo(Supplier<List<?>> f) { }          static void test() {         foo(ArrayList::new);     } }  The warning is: Null type safety at method return type: Method descriptor Supplier<List<?>>.get() promises '@NonNull List<?>' but referenced method provides 'void'  The referenced method doesn't provide 'void', it provides a @NonNull List<?> (it is impossible for a constructor to return null).
"I don't know if this is intentional, but when I have the following code, the IDE doesn't show the javadoc text if I hover over the getEnum() call in the main method:  public class JdocTest { 	interface Param { 		/** 		 * Returns an enumeration. 		 * @param name the name 		 * @param clazz the class 		 * @return the enumeration 		 */ 		<T extends Enum<T>> T getEnum(String name, Class<T> clazz); 	} 	static class ParamImpl implements Param { 		@Override 		public <E extends Enum<E>> E getEnum(String name, Class<E> clazz) { 			return clazz.getEnumConstants()[0]; 		} 	} 	enum E1 { 		A, B, C 	} 	public static void main(String[] args) { 		new ParamImpl().getEnum(""abc"", E1.class); 	} }  The hover just shows the method name and the @Override tag, but no other text or parameter list. If I change the interface parameter name to E:  <E extends Enum<E>> E getEnum(String name, Class<E> clazz);  the javadoc hover properly shows the documentation ""Returns an enumeration."" etc."
"Annotations on enum constants are interpreted by ECJ as type annotations when the annotation type specifies ElementType.TYPE_USE in @Target.  Being so, ECJ throws error ""Syntax error, type annotations are illegal here"" in this annotated code:  @ImprimirMensaje(""Tipo enumerado."") // OK public enum TipoEnumerado { 	 	@ImprimirMensaje(""Constante Tipo enumerado ConstanteEnum1."") // ERROR! 	ConstanteEnum1, 	@ImprimirMensaje(""Constante Tipo enumerado ConstanteEnum2."") // ERROR! 	ConstanteEnum2, 	ConstanteEnum3;  	// ... remaining code ... }  Initially surprised, I've checked this strange behavior with the JLS and I've not found that incompatibility.  I've compiled my code against javac compiler and it has been worked as expected: compiling and printing the right output in the annotation processor (simply printing elements, including the new parameter types annotations).  I'm including an attachment zipped with the 3 basic classes to reproduce the bug:  - ImprimirMensaje.java -> annotation type - ImprimirMensajeClaseAnotada.java -> annotated class - ImprimirMensajeProcessor.java -> annotation processor  Thank you very much."
After bug 430150 has introduced stricter null checking against type variables, some previous decisions need to be reconsidered. In particular the integration with type inference and type substitution need to be revisited.  The principles to follow are:  (A) A type parameter with a null type annotation does not participate in nullness inference, i.e., any inference solution must match exactly with the type annotation on the type parameter:   interface I1 <@NonNull T> { ... }   ...   <U> void m(I1<U> in) { ... }   ...   m(x); // inference here When inferring U as the type argument to I1, it must be ensured that U is a nonnull type.       (B) A null type annotation on a type variable (use) overrides any nullness associated with the type variable, be it declared on the type parameter or via client side substitution, i.e., the type after substitution has the same null type annotation as the declaration.   interface I1 <T> {      @Nullable T maybeGet(List<T> in);   }   ...   List<@NonNull String> strings = ...   x = someI1.maybeGet(strings); Here the substituted return type of maybeGet() must be '@Nullable String' even if x has a nonnull type and tries to direct inference into answering '@NonNull String'. The explicit type annotation on 'T' overrides the nullness of 'T' and excludes that particular occurrence of 'T' from null type inference.  As one consequence we will avoid inferring contradictory null type annotations in many cases (need to check if that error can still be triggered and when). Instead, we give precedence to null type annotations in the locations (A) and (B) and prefer blaming the client in terms of null type mismatch against the arguments or return of the given invocation.
On e.g. http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_type_annotations.htm, the hyperlink to JDT JavaDoc in "JDT's null type annotations _@NonNull_" which currently points to http://help.eclipse.org/help/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html is broken (that redirects to https://www.eclipse.org/documentation/).  This problem only affects the website (help.eclipse.org) - if you try the same in the InfoCenter in a Luna Help > Help Contents, the links works as expected (points to http://127.0.0.1:38506/help/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html).
The error marker:   "The method @Nullable (someMethod) from (someClass) cannot implement the corresponding method from (someInterface) due to incompatible nullness constraints"  has the line location of (someClass). In an ideal world, it would obviously be (someMethod) instead, to allow one to correct the problem more easily by double clicking and jumping to the correct line.  This is certainly a minor problem in the larger scheme of things of null analysis, but I thought I'd let you know anyways.
"When a functional interface extends another interface which overrides a method in a parent interface, eclipse tags the functional interface with an error ""Invalid '@FunctionalInterface' annotation; Bar is not a functional interface""  Ran into this with an interface which extended BaseStream (which redefines the close() method from AutoCloseable without providing an implementation).  Simple code which reproduces the issue:  // ""Invalid '@FunctionalInterface' annotation; Bar is not a functional interface"" @FunctionalInterface public interface Bar extends Overridden { 	void foo();  	@Override 	default void close() { 	} }  interface Overridden extends AutoCloseable { 	// Works without this overridden method 	@Override 	void close(); }  Removing the overridden close() method from the interface 'Overridden' makes 'Bar' compile correctly.  This code compiles correctly with javac."
JDT provides ability to filter out synthetic methods, static initializers, constructors and so on during debugging.   We need to filter out some methods which are generated by Xtend compiler. Our first attempt was to mark such methods as synthetic and enable Step Filtering -> Filter synthetic methods. But this approach does not work because these methods actually are not synthetic. They can be called from java files.  We would like to have an extension point to enhance methods step filtering. org.eclipse.jdt.internal.debug.core.model.JDIThread.StepHandler.locationIsFiltered(Method) method can delegate to such extension point if step filtering is enabled.
ECJ 3.10.0 (JDT 4.4) no longer generates the bridge methods expected when a method defined in an interface is overridden with a different return type in its indirect child classes.  For example, with the following code:      public interface A {         Iterable getIterable();     }          class B implements A {         public Collection getIterable() { return null; }     }          class C extends B {         public List getIterable() { return null; }     }  According to javap, ECJ 3.9.0 and javac generate these class files:      public interface A {       public abstract java.lang.Iterable getIterable();     }      class B implements A {       B();       public java.util.Collection getIterable();       public java.lang.Iterable getIterable();     }      class C extends B {       C();       public java.util.List getIterable();       public java.lang.Iterable getIterable();       public java.util.Collection getIterable();     }  with ECJ 3.10.0 we now get:      public interface A {       public abstract java.lang.Iterable getIterable();     }      class B implements A {       B();       public java.util.Collection getIterable();       public java.lang.Iterable getIterable();     }      class C extends B {       C();       public java.util.List getIterable();       public java.util.Collection getIterable();     }  The bridge method returning an Iterable is missing from C.class. It's only present in the .class file of its direct child B.
The org.eclipse.jdt.core project doesn't specify a file encoding, and different files in the project already use different encodings.  All projects should use UTF-8, see bug 399451 comment 4.
+++ This bug was initially created as a clone of Bug #408653 +++  The manpage for ecj has tons of formatting errors and a few content bugs.
In Eclipse 4.4, a possible compiler bug affects our codebase.  The trigger conditions seems to be (every class is declared in an exported packaged named the same as the bundle):   1. In bundle org.example.a:     a. Declare an interface A     b. Declare a nested interface A.Inner   2. In bundle org.example.b:     a. Import package org.example.a     b. Declare a class B     c. Use the type A.Inner as a type parameter in a private method return type or argument, e.g. Iterable<A.Inner>   3. In bundle org.example.c:     a. Import package org.example.b     b. Call a function in class B  Expected behavior: Since the type A.Inner is not exposed in the public interface of the class B, it should not be necessary to import org.example.a to use B.  Actual behavior: Compiler error: The type org.example.a.A$Inner cannot be resolved. It is indirectly referenced from required .class files  I have created a small project that illustrates this problem: https://github.com/glerup/eclipse-pde-indirectly-referenced-bug
Version: Luna 4.4.0 20140612-0600  Steps:  ensure default-configured eclipse (build-on-save primarily)  1) create a new Java class in a new Java project 2) paste the code included below 3) save the file  Expected result: save completes  Actual results: NullPointerException pop-up and logs that point to the JDT  Stack (hand-entered): !ENTRY org.eclipse.jdt.ui 4 0 2014-07-04 13:54:27.057 !MESSAGE Error in JDT Core during AST creation !STACK 0 java.lang.NullPointerException   at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.checkExpression(InferenceContext18.java:796)   at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.moreSpecificMain(InferenceContext18.java:746)   at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.isMoreSpecificThan(InferenceContext18.java:694)   at org.eclipse.jdt.internal.compiler.lookup.Scope.mostSpecificMethodBinding(Scope.java:4445) ...  Code: public class Test {     public static void error() {         test(Test::works);         test(Test::broken);     }      private static <T> void test(ToLongFunction<T> func) {}     private static <T> void test(ToIntFunction<T> func) {}      private static int broken(Object o) { return 0; }     private static long works(Object o) { return 0; } }  Workarounds: - do not overload (name the test() methods testInt / testLong) - OR make test() functions non-generic (remove the <T> and make the argument types ...Function<?> or ...Function<Object>)
"Created attachment 244836 [details] Eclipse plugins configuration  Code: (https://github.com/ceefour/gggettingstarted/tree/stackoverflow-traverse branch stackoverflow-traverse)  public static void main(String[] args) throws GridException { 	try (Grid grid = GridGain.start( 		System.getProperty(""user.home"") + ""/gridgain-platform-os-6.1.9-nix/examples/config/example-cache.xml"")) { 	final String msg = ""Java GridGain MapReduce""; 	int tot = grid.compute().execute(new GridComputeTaskSplitAdapter<String, Integer>() { 		@Override 		protected Collection<? extends GridComputeJob> split( 				int gridSize, String arg) throws GridException { 			String[] words = arg.split("" ""); 			return FluentIterable.from(Arrays.asList(words)) 				.<GridComputeJob>transform((it) -> new GridComputeJob() { 					@Override 					public Object execute() throws GridException { 						log.info(""Length of '{}' is {}"", it, it.length()); 						return it.length(); 							} 					 					@Override 					public void cancel() { 					} 				}).toList(); 		} 		 		@Override 		public Integer reduce(List<GridComputeJobResult> results) 						throws GridException { 			int total = 0; 			for (GridComputeJobResult res : results) { 				total += (int) res.getData(); 			} 			return total; 		} 	}, msg).get(); 	log.info(""Tot: {}"", tot); }  Ctrl+Space inside main() shows in Error Log:  org.eclipse.e4.core.di.InjectionException: java.lang.StackOverflowError 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:62) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1574) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1387) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1412) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1397) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1424) 	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:824) 	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3269) 	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:777) 	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2098) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5510) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4700) 	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method) 	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9074) 	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1253) 	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method) 	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2473) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3439) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438) Caused by: java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.traverse(SingleTypeReference.java:108) 	at org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation.traverse(MarkerAnnotation.java:40) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:324) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1434) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:603) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:649) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1015) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:347) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1434) ...repeats over and over...  eclipse.buildId=4.4.0.I20140606-1215 java.version=1.8.0_05 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product  This is a continuation of log file /home/ceefour/space_spring/.metadata/.bak_3.log Created Time: 2014-07-04 18:00:21.550"
"This code:  for (int ruleId : ruleIds) { 	grid.compute().affinityRun(cache.name(), ruleId, 		() -> log.info(""Processing rule #{} {}"", ruleId, cache.get(ruleId)) ); }  will generate compiler error: Unhandled exception type GridException  with 1 quick fix: Surround with try/catch.  However, when surround with try/catch quick fix is selected, it becomes:  try { 	grid.compute().affinityRun(cache.name(), ruleId, 		() -> log.info(""Processing rule #{} {}"", ruleId, cache.get(ruleId)) ); } catch (GridException e1) { 	throw new RuntimeException(""Cannot compute"", e1); }  which won't work (i.e. the code still won't compile), as quick fix is surrounding the outer method affinityRun(), which doesn't throw checked Exception, while the inner lambda still throw GridException.  What JDT should do is convert the lambda into a Runnable (as it's inferred from the context), then surround the Runnable's method body with try/catch."
master  > Re: [platform-releng-dev] 4.5.0 N-Build: N20140704-2000 - BUILD FAILED  > This was because the jdt.feature was expecting jdt.annotation version to be > from 2.0.0 - 2.0.1 but found to be 2.0.100.  > > I have fixed the version to be 2.0.1.   I don't think 2.0.1 would be any different from 2.0.100 (but it would not adhere the versioning rules). AFAIK, the /org.eclipse.jdt-feature/feature.xml can either contain version="0.0.0", which will be replaced with one of the versions available at build time. Or it can have a version number that exactly matches an available bundle.  I'll revert this to 2.0.100 and adjust the feature.
"It seems that adding a null annotation to the return type A in the following code causes issues for my machine:  import java.util.Collection; import java.util.List; import java.util.Set;  public class Test { 	class X { 		 	} 	 	public static <C extends Collection<?>, A extends C, B extends C> 			A transform(B arg) { // Add @Nullable to A 		return null; 	} 	 	public static void main(String[] args) { 		List<X> list = null; 		Set<X> result = transform(list); 	} }  This occurs regardless of whether I have null annotations enabled, although the ""'Rebuilding' has encountered a problem"" popup only seems to appear when I have null analysis on. The InvocationTargetException seems to occur when I try to use Command-Shift-O to organize imports after the IllegalStateException, even when null annotations are off.  Eclipse 4.4, ID I20140701-0800, OS X 10.9.3, Java 1.8.0_05.   Here are the stack traces:  java.lang.IllegalStateException: TypeBinding#clone() should have been overridden 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.clone(TypeBinding.java:228) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:339) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:268) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:988) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.substitute(ParameterizedGenericMethodBinding.java:742) 	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:490) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:435) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.<init>(ParameterizedGenericMethodBinding.java:502) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedGenericMethod(LookupEnvironment.java:831) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:533) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5150) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1297) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1767) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1662) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2621) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:866) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:250) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)   java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:479) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374) 	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2144) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2140) 	at org.eclipse.ui.internal.progress.ProgressManager$RunnableWithStatus.run(ProgressManager.java:1380) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.progress.ProgressManager$5.run(ProgressManager.java:1214) 	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187) 	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156) 	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4721) 	at org.eclipse.ui.internal.progress.ProgressManager.runInUI(ProgressManager.java:1211) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:291) 	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:204) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) 	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1087) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4184) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1504) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1500) 	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:496) 	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1060) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5719) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68) 	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:594) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5629) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2105) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2329) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5691) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5128) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5277) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3655) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) Caused by: java.lang.IllegalArgumentException: AST must not be null 	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.create(ImportRewrite.java:192) 	at org.eclipse.jdt.ui.CodeStyleConfiguration.createImportRewrite(CodeStyleConfiguration.java:70) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility.createImportRewrite(StubUtility.java:1503) 	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.createTextEdit(OrganizeImportsOperation.java:427) 	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.run(OrganizeImportsOperation.java:398) 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5358) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466) 	... 83 more"
Consider the following code:       Runnable runnable = () -> {};  When ctrl-clicking on the arrow ("->"), Eclipse intuitively opens the Runnable.run() declaration. That doesn't work with F3
Version: Luna (4.4) Build id: I20140606-1215  Few tests are failed in org.eclipse.jdt.core.tests.compiler.regression with JDK9:  junit.framework.AssertionFailedError: Unexpected problems [out: ][err: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:204) at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.handleOption(EclipseFileManager.java:677) at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchProcessingEnvImpl.<init>(BatchProcessingEnvImpl.java:88) at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager.configure(BatchAnnotationProcessorManager.java:69) at org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager(Main.java:3996) at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:4114) at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1694) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.invokeCompiler(BatchCompilerTest.java:648) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runTest(BatchCompilerTest.java:572) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runConformTest(BatchCompilerTest.java:437) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.test405225_extdirs(BatchCompilerTest.java:13797) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34)  Effected tests: test405225_extdirs - 1.5 test405225_extdirs - 1.6 test405225_extdirs - 1.7 test405225_extdirs - 1.8 test009 - 1.8  How to reproduce: 1. eclipse-Automated-Tests-4.4 from http://download.eclipse.org/eclipse/downloads/drops4/R-4.4-201406061215/ 2. jdk9 from http://jdk9.java.net/download 3. run jdkcorecompiler to reproduce the failures.  It's not platform specific.
Created attachment 244949 [details] just compile this project, the error should raise  The compiler raises the error "Missing code implementation in the compiler" when compiling the small project attached to this report.  If I remove the line @NonNullByDefault in package-info.java the problem disappears.  I use: jdk 1.8 u5 x64 eclipse 4.4 RC3 x64  compiler compliance level is 1.8  I added plugins checkstyle and findbugs.  I did activate a lot of options in warning/errors of the compiler.  Regards, Mickaël
"All of a sudden my workspace stopped building and I keep getting ""Building workspace has encountered a problem. Errors occured during the build."" errors.  The stack trace is:  java.lang.ArrayIndexOutOfBoundsException: 3000 	at org.eclipse.jdt.internal.compiler.ClassFile.dumpTargetTypeContents(ClassFile.java:2279) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateTypeAnnotation(ClassFile.java:4682) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateRuntimeTypeAnnotations(ClassFile.java:3876) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateTypeAnnotationsOnCodeAttribute(ClassFile.java:1449) 	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1391) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:338) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:270) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:935) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
"Example from JLS8: 15.13.1. -------------------------------------------------------------------- package meth.refs;  interface Fun<T, R> { 	R apply(T arg); }  class C { 	int size() { 		return 0; 	}  	int size(Object arg) { 		return 0; 	}  	int size(C arg) { 		return 0; 	}  	void test() { 		Fun<C, Integer> f1 = C::size; 		// OK: reference is to instance method size() 	} } --------------------------------------------------------------------  The code compiles with javac b132 but ECJ reports an error at method reference: ""Cannot make a static reference to the non-static method size(C) from the type C""."
Consider two classes    @NonNullByDefault    C1<T> and    @NonNullByDefault    C2<T extends Object>  While the nullness default has no effect on C1, it changes the semantics of C2 to    C2<T extends @NonNull Object>  This is because the nullness default affects explicit type bounds, but not implicit type bounds.  Unfortunately, both classes create the same byte code, and we cannot distinguish from those bytes, whether a type bound was implicit or explicit. This causes us to incorrectly read the class file for C1 as "C1<T extends @NonNull Object>".  I'm planning two changes: (1) always consider upper bounds of j.l.Object as "implicit" bounds (src & bin) (2) issue a warning against classes like C2, signaling that the default is not applied although the type bound is explicit  Perhaps, a note in the javadoc of DefaultLocation.TYPE_BOUND is appropriate, too.
When I add a Java 8 JRE to the "Installed JREs" in Eclipse, the jfxrt.jar isn't associated with the javafx-src.zip, but most other jars are associated with the src.zip available in JDK 8.   -- Configuration Details -- Product: Eclipse 4.4.0.20140612-0500 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.10.0.v20140606-1536
Created attachment 245056 [details] Test source file  When in project "Save  Actions" enabled are: - Format Source code, Format all lines - Additional actions, Correct identation then saving file from attachment, adding a space to end file and saving again. Formatting of the source is changing.
"Maybe related to bug 432110 but since the fix for this should already be part of the Luna release, I'm creating a separate bug report.  The following code compiles using javac 1.8.05 but fails to compile in Eclipse (error message is ""Type mismatch: cannot convert from Object to List<NestedLambdaTest.ImmutableRecord>"" ):   -----------------------------------------------------------------  import java.util.ArrayList; import java.util.List; import java.util.function.Function; import java.util.function.Predicate; import java.util.stream.Collectors; import java.util.stream.Stream;  public class NestedLambdaTest {  	protected static interface IListEntry { 		public <T> T visitRecordsWithResult(Function<Stream<Record>,T> func);		 	} 	 	protected static final class ImmutableRecord { 		public ImmutableRecord(Record r) { } 	} 	 	protected static final class Record {} 	 	public List<ImmutableRecord> compilesWithEclipseAndJavac()  	{ 		return visitEntriesWithResult( stream -> { 			return stream.map( entry -> { 				final List<ImmutableRecord> result1 = entry.visitRecordsWithResult( stream2 -> stream2 						.filter( somePredicate() ) 						.map( ImmutableRecord::new ) 						.collect( Collectors.toList() ) 					);	 				return result1; 			}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) ); 		});		 	}		 	 	public List<ImmutableRecord> compilesWithJavacButNotEclipse1()  	{ 		return visitEntriesWithResult( stream -> { 			return stream.map( entry -> { 				return entry.visitRecordsWithResult( stream2 -> stream2 						.filter( somePredicate() ) 						.map( ImmutableRecord::new ) 						.collect( Collectors.toList() ) 					);	 			}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) ); 		});		 	}		 	 	public List<ImmutableRecord> compilesWithJavacButNotEclipse2()  	{ 		return visitEntriesWithResult( stream -> { 			return stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2 						.filter( somePredicate() ) 						.map( ImmutableRecord::new ) 						.collect( Collectors.toList() ) ) 			).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) ); 		});		 	}	 	 	public List<ImmutableRecord> compilesWithJavacButNotEclipse3()  	{ 		return visitEntriesWithResult( stream -> stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2 						.filter( somePredicate() ) 						.map( ImmutableRecord::new ) 						.collect( Collectors.toList() ) ) 			) 			.flatMap( List::stream ) 			.collect( Collectors.toCollection( ArrayList::new ) ) 		);		 	}	 	 	private static Predicate<Record> somePredicate() { 		return record -> true; 	}		 	 	private <T> T visitEntriesWithResult(Function<Stream<IListEntry>,T> func) { 		return func.apply( new ArrayList<IListEntry>().stream() ); 	} }"
Refer bug 428741 comment #0. A quick assist can be added to convert lambda expression to method reference.
Take the following programme:  ------------------------------ public class T1 {     public static void main(String[] args) {         T2.run(() -> {});     } }  public class T2 {      public static void run(InvisibleInterface i) {     }      private interface InvisibleInterface {         void run();     } } ------------------------------  T1 should not compile, and indeed it doesn't with javac:  ------------------------------ C:\Users\Lukas\workspace\jOOQ\jOOQ-test\src\main\resources>javac T1.java T2.java T1.java:45: error: InvisibleInterface has private access in T2         T2.run(() -> {});                ^ 1 error ------------------------------  Intuitively, this shouldn't compile as there is no way T1 can call T2.run() prior to Java 8
Since upgrading to Eclipse 4.5 integration build ID I20140715-0800, the following code snippet now triggers a compiler warning/error:    try {     ...   } catch (Exception e) {     // do nothing   }  The error is: The value of the exception parameter e is not used  Turning off the setting "Value of parameter is not used" in the compiler settings removes this error. We have that setting enabled, for example to warn of unused parameters in private methods. Is it a design decision to have this setting also apply to exception parameters, or is just a bug?
Platform requires Java 1.6 since Luna and I think it would be nice to be able to use @Override for interfaces also in JDT.ui
"This looks suspiciously like bug 428642 (currently marked as fixed) is not really fixed. I tested this on Eclipse 4.4.0 (Luna release version) using 64-bit JDK 1.8.05.  The following code works as expected with javac but fails to execute correctly (throwing an IllegalArgumentException instead) when run from inside Eclipse.  ----------------------------- package com.vodecc.voipmng.boundary.wicket.alarming;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;  public class SerializationTest implements Serializable { 	interface SerializableRunnable extends Runnable, Serializable { 	}  	SerializableRunnable runnable;  	public SerializationTest() { 		final SerializationTest self = this; 		// runnable = () -> self.doSomething();  // WORKING 		runnable = () -> this.doSomething(); // FAILS         }  	public void doSomething() { 		System.out.println(""Hello,world!""); 	}  	public static void main(String[] args) throws Exception 	{ 		final ByteArrayOutputStream buffer = new ByteArrayOutputStream(); 		try (ObjectOutputStream out = new ObjectOutputStream(buffer) ) { 			out.writeObject(new SerializationTest()); 		} 		try (ObjectInputStream in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray()))) 		{ 			final SerializationTest s = (SerializationTest) in.readObject(); 			s.doSomething(); 		} 	} }"
Build ID: N20140718-2000  The test testRemoveExternalProject Failed.  junit.framework.AssertionFailedError: Should receive change at org.eclipse.jdt.core.tests.model.TypeHierarchyNotificationTests.testRemoveExternalProject(TypeHierarchyNotificationTests.java:1110) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34)
"import java.util.function.*;  public class Snippet { 	Function<Integer, int[]> m1 = int[]::new; }  In the above example, CreationReference#resolveMethodBinding() returns a synthetic method binding for the constructor of int[] i.e.   > method binding: Snippet.lambda$0(int)  The binding is ""private static"" and has ""IS CONSTRUCTOR: false"", hence it cannot be used to identify if the method is a constructor.  The DOM APIs should not create a fake constructor binding for array types in CreationReference as it cannot tell anything interesting to the API clients.  Instead, CreationReference#resolveMethodBinding() should return null if the type is an array type."
The following simple test code compiles fine when source/target is set to 1.6, but compilation fails on the first line in method x() when source/target is set to 1.8 with a type mismatch: the resulting integer can't be cast to long.  This class compiles fine with the Oracle compiler and both targets 1.6 and 1.8.  public class A {   <T> T get(String name, T defaultValue) { return defaultValue; }    void x() {     long a1 = get("key", 0);     long a3 = get("key", 0L);   } }
"Example from https://www.eclipse.org/forums/index.php/mv/msg/781138/1384369/#msg_1384369  //--- import org.eclipse.jdt.annotation.*;  public class Test7<@Nullable E> { 	E e;  	@Nullable 	E test() { 		return null; 	}  	@NonNull 	E getNotNull() { 		if (e == null) 			throw new NullPointerException(); 		else 			return e; 	} } //---  triggers this error against getNotNull():  Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location  Literally speaking this error can be regarded as correct, but we actually want to always consider '@NonNull E' as: ""The @NonNull variant of whatever type E represents"". Hence this program should be legal, too."
The following valid code is rejected by Eclipse compiler:  import java.util.function.Function; interface Foo {void alpha(Bar pBar);} class Bar {Object bravo() {return null;}} class Test {   Test(Function pFunction) {     class Baz {public Baz(Object pObj) {pFunction.apply(pObj);}}     delta(pBar -> charlie(new Baz(pBar.bravo())));   }   void charlie(Object pRemovals) {}   void delta(Foo pListener) {} }
"Given the following source file in a plugin with an OSGI import:  import org.osgi.framework.Bundle;  public class MyClass { 	Bundle getBundle() { return null; } }  select getBundle() and do Declarations->Project.  Expect: 1 result  Actual: 42 results  If I want results outside my project, I would do Declarations->Workspace, but even there the result should be 1 since MyClass has no super/subclass other than Object so the only candidate second declaration is Object::getBundle() that does not exist.  (I think it was about 3 years ago that Find Declarations became so overenthusiastic and consequently useless. I'm generally forced into a text search.)"
Created attachment 245317 [details] Attached testcase  Resource leak detection incorrectly reports a false negative with an *empty* finally block when returning an AutoCloseable, instead of reporting a warning.  This shouldn't happen; for me, the testcase crashes almost immediately with "too many open files."  Removing the empty finally block causes the warning to occur.  import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader;  public final class ResourceLeakFalseNegative {    private static final class Foo implements AutoCloseable {     final InputStreamReader reader;      Foo(final InputStreamReader reader) {       this.reader = reader;     }      public int read() throws IOException {       return reader.read();     }      @Override     public void close() throws IOException {       reader.close();     }   }    private static final class Bar {     final int read;      Bar(final InputStreamReader reader) throws IOException {       read = reader.read();     }          public int read() {       return read;     }   }    public final static int foo() throws IOException {     final FileInputStream in = new FileInputStream("/dev/null");     final InputStreamReader reader = new InputStreamReader(in);     try {       return new Foo(reader).read();     } finally {       // even though Foo is not closed, no potential resource leak is reported.     }   }    public final static int bar() throws IOException {     final FileInputStream in = new FileInputStream("/dev/null");     final InputStreamReader reader = new InputStreamReader(in);     try {       final Bar bar = new Bar(reader);       return bar.read();     } finally {       // Removing the close correctly reports potential resource leak as a warning,       // because Bar does not implement AutoCloseable.       reader.close();     }   }    public static void main(String[] args) throws IOException {     for (;;) {       foo();       bar();     }   } }
Both ECJ and javac compile the following incorrect code (array type constructor reference with type arguments):  Function<Integer, int[]> m1 = int[]::<Runnable>new;  The code specifies <Runnable> as a type argument for the array creation expression, which is not correct.
"Created attachment 245402 [details] log file  Trying to save & compile a file with:  List<@Nullable ? extends Integer> list;  Results in an error dialog.  The log file contains numerous exceptions:  !SESSION 2014-07-25 20:21:06.760 ----------------------------------------------- eclipse.buildId=4.4.0.I20140606-1215 java.version=1.8.0_11 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=de_DE  [...]  !ENTRY org.eclipse.jdt.core 4 4 2014-07-25 20:21:12.409 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package de.klene.nullable;  import java.util.List;  import org.eclipse.jdt.annotation.NonNullByDefault; import org.eclipse.jdt.annotation.Nullable;  @NonNullByDefault public class CompilerError {      List<@Nullable ? extends Integer> list;  }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.contradictoryNullAnnotationsOnBounds(ProblemReporter.java:9522) 	at org.eclipse.jdt.internal.compiler.ast.Wildcard.internalResolveType(Wildcard.java:78) 	at org.eclipse.jdt.internal.compiler.ast.Wildcard.resolveTypeArgument(Wildcard.java:122) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:241) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:361) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:559) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1706) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:880) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:850) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:450) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:922) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136) 	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) 	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
"I have a project with a rather long classpath, more than 400 entries. When the debugger first stops at a breakpoint, it takes more than 30 seconds before it shows the source. I used visualvm to capture some thread dumps during that 30 seconds, and most of them look like this:  ""Worker-54"" #503 prio=5 os_prio=0 tid=0x000000001a794800 nid=0x41ce4 runnable [0x00000000327de000]    java.lang.Thread.State: RUNNABLE 	at java.io.WinNTFileSystem.getLastModifiedTime(Native Method) 	at java.io.File.lastModified(Unknown Source) 	at java.util.zip.ZipFile.<init>(Unknown Source) 	at java.util.zip.ZipFile.<init>(Unknown Source) 	at java.util.zip.ZipFile.<init>(Unknown Source) 	at org.eclipse.jdt.internal.core.JavaModelManager.getZipFile(JavaModelManager.java:2712) 	at org.eclipse.jdt.internal.core.util.Util.getJdkLevel(Util.java:846) 	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.<init>(JarPackageFragmentRoot.java:76) 	at org.eclipse.jdt.internal.core.JavaProject.getPackageFragmentRoot(JavaProject.java:1810) 	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:615) 	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:708) 	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:672) 	at org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1430) 	at org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1425) 	at org.eclipse.jdt.internal.core.JavaProject.findPackageFragmentRoot0(JavaProject.java:1228) 	at org.eclipse.jdt.internal.core.JavaProject.findPackageFragmentRoot(JavaProject.java:1220) 	at org.eclipse.jdt.internal.launching.JavaSourceLookupUtil.getPackageFragmentRoot(JavaSourceLookupUtil.java:157) 	at org.eclipse.jdt.internal.launching.JavaSourceLookupUtil.translate(JavaSourceLookupUtil.java:57) 	at org.eclipse.jdt.launching.JavaRuntime.getSourceContainers(JavaRuntime.java:2449) 	at org.eclipse.jdt.launching.sourcelookup.containers.JavaSourcePathComputer.computeSourceContainers(JavaSourcePathComputer.java:58) 	at org.eclipse.debug.internal.core.sourcelookup.SourcePathComputer.computeSourceContainers(SourcePathComputer.java:71) 	at org.eclipse.debug.core.sourcelookup.containers.DefaultSourceContainer.createSourceContainers(DefaultSourceContainer.java:117) 	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.getSourceContainers(CompositeSourceContainer.java:133) 	- locked <0x00000000fa6ee7a8> (a org.eclipse.debug.core.sourcelookup.containers.DefaultSourceContainer) 	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.findSourceElements(CompositeSourceContainer.java:48) 	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupParticipant.findSourceElements(AbstractSourceLookupParticipant.java:70) 	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector$SourceLookupQuery.run(AbstractSourceLookupDirector.java:142) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.doSourceLookup(AbstractSourceLookupDirector.java:505) 	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.getSourceElement(AbstractSourceLookupDirector.java:785) 	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:346) 	- locked <0x00000000ae4fd858> (a org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility$LRU) 	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility$SourceLookupJob.run(SourceLookupFacility.java:737) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)  When I do the exact same thing with the exact same project in eclipse 4.3.x, the source lookup takes just a second or so - very fast.   I suspect the problem is in the JarPackageFragmentRoot constructor where it is calling Util.getJdkLevel -- it looks like older versions of JarPackageFragmentRoot didn't have that, but I'm just speculating -- I don't really know that much about it."
To support external null annotations for libraries we need a file format. After initial experiments had used the binary class file format, we agreed that a textual format is to be preferred, mainly in order to better support versioning, comparison and merging of external annotations (involving manual intervention).  In bug 331651 essentially four textual formats have been discussed:  - jaif: contains significant complexity that's not needed for our use case - IntelliJ's XML format: not yet ready for type annotations & very verbose - Java signatures:   - source level method headers   - signature encoding as used in .class files  The batch compiler will support exactly one of these formats. Whether or not the IDE will be able to handle alternative formats will be left to the future.
To support external null annotations (bug 331651) we need some infrastructure that supports: (1) defining a per-library location for external annotations (2) retrieving the external annotations during type lookup (3) feeding external annotations into the compilation   Ad (1):  For the IDE case this can be handled in analogy to source or javadoc  attachments.   For the batch compiler no precedent exists. Here I could imagine several strategies: - let the user specify alternating entries on the classpath:     -cp lib1;lib1annots;lib2;lib2annots ... - use a new command line argument (list of paths):   - let each external annotation bundle identify itself as to which library     it is annotating (how are libraries identified?)   - consider the list of paths as a flat search path just like classpath:     each type is searched front-to-tail until annotations are found (if any)  Should overlapping between sets of external annotations be detected / reported?   Ad (3): At this interface we could either - pass the unprocessed string of annotations for one class - pass an IAnnotationProvider that hides the actual annotation format  While the second option has its merits, it must be carefully selected which design decisions should be exposed at this interface.   Internally, I will need functionality to obtain a TypeAnnotationWalker per method (as identified by name and signature). Defining an API using a new abstraction IAnnotationProvider would imply to also expose an interface ITypeAnnotationWalker.  BTW: speaking of 1.8-specific TypeAnnotationWalker: I do expect that SE5 null annotations can be handled as a special reduced case of 1.8 annotations for the sake of external null annotations.
"Hello,    A NPE exception occurs when source code contains some lambda expressions. Isn't easy for me to extract/identify the code that cause the problem but I'm confident it's bc of lambdas.   Thanks  Environment: MAC OSX eclipse.buildId=4.4.0.I20140606-1215 JDT.core: 3.10.0.v20140604-1726 JDT.ui: 3.10.0.v20140604-1403   Stack Trace: Java Model Exception: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
When adding one more type to jclMin1.8.jar I observed a mysterious failure in JavaSearchBugs8Tests.testBug400899g38(): two of the expected exact matches turned into potential matches.  At a closer look, that new result is actually "better".  Here's what I see:    Object r = (@Marker java. @Marker util.@Marker Map<@Marker String, @Marker String>.@Marker Entry @Marker []) null;  This line contains 2 annotations in illegal positions (trying to annotate a package).  Q: Why does it succeed in HEAD? A: Because java.util.Map cannot be resolved (lacking from jclMin1.8.jar)  Oops?  Q: Why does a missing type help to get "better" search results? A: Because java.util.Map did *not* consist of two packages and a type, but only of unresolved tokens.  So, adding Map to the jar revealed that two occurrences are not kosher, hence they're flagged as potential matches. Makes sense?  Note, that the same also applies to java.util.List one line above (just I didn't add that to jclMin1.8.jar, so nothing changed here).
"What steps will reproduce the problem? 1. Create java 8 project 2. Create two java files (note that the classes must be in separate java files, otherwise bug does not show up):  First file: //------------------------- //file BugTest.java public class BugTest {  	public void baz(InterfaceForBugTest arg) {  	}  	public void bar() { 		baz(InterfaceForBugTest.instance); 	}    	public Runnable returningLambda() { 		return () -> { 		}; 	}  	public static void main(String[] args) { 		// 	} }  //-------------------------  Second file: //------------------------- //file InterfaceForBugTest.java public interface InterfaceForBugTest {   	public static InterfaceForBugTest creator1(Runnable simpleInstance){ 		return null; 	} 	 	public static void methodWithAnonymousImplementation() { 		new InterfaceForBugTest() { 			@Override 			public void fun1() { 			}  			@Override 			public void fun2() { 			}  			@Override 			public void fun3() { 			}  			@Override 			public void fun4() { 			}  			@Override 			public void fun5() { 			}  		}; 	}    	public static void methodWithAnonymousImplementation2() { 		new InterfaceForBugTest() {  			@Override 			public void fun1() { 			}  			@Override 			public void fun2() { 			}  			@Override 			public void fun3() { 			}  			@Override 			public void fun4() { 			}  			@Override 			public void fun5() { 			}  		}; 	}  	public static InterfaceForBugTest instance = creator1(() -> { 	});  	void fun1();  	void fun2();  	void fun3();  	void fun4();  	void fun5();  } //-------------------------  3. Observe bugs:  	- Go to the file BugTest.java, right-click anywhere in the editor to bring pop-up menu, click ""Run as"". Nothing will happen (the sub-menu should appear) 	- While still in BugTest.java mouse-over ""Run"" button in toolbar. The error message will appear (the attached exception stack is from this error) 	- Try to modify ""BugTest.java"". Three exceptions will appear in Eclipse Error Log: 	 - Error in JDT Core during reconcile 	 - Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". 	 - Exception occurred during problem detection: All stack traces for mentioned errors are similar to attached one - everything begins in ""org.eclipse.jdt.internal.compiler.ast.LambdaExpression.copy(LambdaExpression.java:946)"".  The error occurs not only when you try to run code with ""main"" function but also when you try to run it as unit-tests, so actually it prevents me from running affected unit tests in any convenient way.  Please note that above example java files are minimal that I was able to produce. There must be at least five methods in InterfaceForBugTest and there must be at least two methods with anonymous interface implementations. The instance in InterfaceForBugTest must be created from function with lambda expression argument and there must be methods similar to bar/baz in BugTest. Very strange but true :).  -- Error Details -- Date: Mon Jul 28 22:30:16 CEST 2014 Message: An internal error occurred during: ""Compute launch button tooltip"". Severity: Error Product: Eclipse 4.4.0.20140612-0500 (org.eclipse.epp.package.jee.product) Plugin: org.eclipse.core.jobs Session Data: eclipse.buildId=4.4.0.I20140606-1215 java.version=1.8.0_05 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product  Exception Stack Trace: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.copy(LambdaExpression.java:946) 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:715) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.compatibilityLevel18FromInner(Scope.java:887) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel18(Scope.java:794) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:756) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:695) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1761) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1662) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2621) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:866) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264) 	at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:210) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getOtherFieldBindings(QualifiedNameReference.java:728) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:1078) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:648) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:826) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:628) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:741) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:693) 	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.hasSuperclass(JavaLaunchableTester.java:467) 	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.test(JavaLaunchableTester.java:610) 	at org.eclipse.core.internal.expressions.Property.test(Property.java:58) 	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68) 	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.IterateExpression.evaluate(IterateExpression.java:150) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.WithExpression.evaluate(WithExpression.java:72) 	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53) 	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.evalEnablementExpression(LaunchShortcutExtension.java:281) 	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager.getShortcutsForSelection(LaunchingResourceManager.java:455) 	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager.computeLabels(LaunchingResourceManager.java:240) 	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager$1$1.run(LaunchingResourceManager.java:142) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
As one of the next steps in the context of bug 331651 I'd like to do some performance measurements (to avoid discussions with lots of hand waving about what *should* be a good / viable approach :) ).  Here's what I'd like to do with other people's help:  - Use a tool (KAnnotator?) to create lots of external annotations,   I guess the JRE would be a perfect candidate for these experiments?   The Checkers Framework site lists some more tools in this area.  - Use (ad-hoc) generators to transform these annotations into other formats  - Using the infra structure from bug 440477 feed these data into the compiler  - Implement a test that reads all classes of the given library together with   their external annotations (perhaps in chunks to avoid memory problems ...)  - Measure the overall time and memory consumption  Using this setup we can show - General viability of the approach, or will it completely kill performance? - Comparison between different formats and strategies  I want to use the current implementation using signatures in .class file format as our reference for now (see bug 440474). Others are invited to contribute code for evaluating other formats. After these experiments we will be in a much better situation to make an informed decision.   I'm slightly concerned about the difference between declaration annotations and type annotations: I'd like to base our decisions on data about type annotations (because those can be bigger in volume and are more complex to process), but I don't know if we can get a body of type annotations from any existing tool. Anybody?  Otherwise, we may have to amend our experiments with some synthetic benchmark specifically for type annotations.   Who likes to join in these experiments?
Created attachment 245468 [details] Demo-sourcecode  I wrote a Wrapper around a java.util.Comparator to count the number of times, it's compare method was called. Playing around with the @NonNullByDefault parameters, I just wanted to disable the DefaultLocation.TYPE_PARAMETER (marked A in the source code). Methods foo() and bar() are there to test, if my CountingComparator accepts both @Nullable and @NonNull parameter types for the wrapped Comparator.  1) Is there a better way to selectively disable some default locations other than listing all the other DefaultLocations? I'd really love to have a negative selection for this. 2) Toggling the comment at A causes an IllegalArgumentException in EJC -> I'll attach a log file 3) With A commented in and a package-level @NonNullByDefault in effect: shouldn't this also be flagged as redundant, as it then selects every possible DefaultLocation? The implementation should not distinguish the unparameterized annotation from a full list of all possible values.  With A commented out: Now T is an unconstrained legacy type parameter, that may become either @NonNull or @Nullable as demonstrated in foo() and bar(). So T carries a kind of placeholder for an outside-controlled nullable-state, right?  4) The save action code formater jumps line A from 0 to 4 spaces back and forth on every save - very irritating, if you try to commit this code to some SCM. 5) T is a free type variable at B and C as demonstrated by the error for line D?!? 6) Free type means: T should either accept null or not depending on the wrapped comparator. But why do I still have to cancel the DefaultLocation.PARAMETER for those two parameters element1 and element2 in method compare() at E? 7) Even more suspicious: Why is it necessary to also cancel the DefaultLocation.RETURN_TYPE at F?
Per bug 440477 I'm implementing minimal support to use external annotations (bug 331651) also from the batch compiler.  The IDE approach based on an attribute on a classpath entry is more capable, because it allows to specify one annotation location per library.  I'm filing this bug as a reminder that we may want similar capability also for the batch compiler.  The difficulty is just in inventing a suitable format for the CLI option. A classpath can already contain details (access restrictions), but I don't think we should extend the syntax of this standard option. OTOH, when specifying external annotations via a separate option, it's not clear what's the best way of associating classpath entries with external annotation locations.
"See bug 424110 also.  In the following example, press F3 or hover over 'isFile' at [1] and [2]. It works at [1] but not at [2]. ----------------------------------------------------------------------- package p;  import java.io.File; import java.io.FileFilter;  public class Snippet { 	{ 		File dir = new File(""C:\\TEST""); 		FileFilter filter = File::isFile; // [1] works 		dir.listFiles(File::isFile); // [2] does not work 	} } -----------------------------------------------------------------------"
Consider the following code:  @NonNullByDefault(value={     DefaultLocation.ARRAY_CONTENTS,     DefaultLocation.FIELD,     DefaultLocation.PARAMETER,     DefaultLocation.RETURN_TYPE,     DefaultLocation.TYPE_ARGUMENT,     DefaultLocation.TYPE_BOUND,     // DefaultLocation.TYPE_PARAMETER, // A }) public class BigClass</* B */ T> implements LegacyInterface<T> {     // C      @Override     @NonNullByDefault(value={         DefaultLocation.ARRAY_CONTENTS,         DefaultLocation.FIELD,         // DefaultLocation.PARAMETER, // D         // DefaultLocation.RETURN_TYPE, // E         DefaultLocation.TYPE_ARGUMENT,         DefaultLocation.TYPE_BOUND,         DefaultLocation.TYPE_PARAMETER,     })     public T inheritedMethod(T t) {         return t;     }      // hundreds of lines of code      public class Inner<F> {     } }  I'd love to gain more control over specifically canceling the DefaultLocation.TYPE_PARAMETER to surgically create free type variables (neither @NonNull nor @Nullable) for interoperability with legacy code / interfaces, e.g. Comparable, Comparator, Iterable, ... Free type variables are the recommended intermediate solution given at: http://help.eclipse.org/luna/topic/org.eclipse.jdt.doc.user/tasks/task-using_null_type_annotations.htm#typeVariables  Possible approaches to discuss:  a) As demonstrated in the code, it is currently possible to provide @NonNullByDefault with a positive list of locations to apply. This is due to the fact, that an empty list as @NonNullByDefault({}) should represent a convenient way to disable all defaults imported from a bigger context (e.g. the package-info.java) The problem is, this does not account for eventually new DefaultLocations, which might be added in the future. So you never know, whether the list is complete, if you don't explicitly give even the commented lines A, D & E  b) A negative selection like @NonNullByDefault(skip={DefaultLocation.TYPE_PARAMETER}) could override the value. Question is, how to interpret @NonNullByDefault({})?  c) Add some "scope control" at line C to somehow undo the effect of the surrounding @NonNullByDefault. Not sure, if this would be possible to achieve with an annotation, as there is no element, it applies to. It just should apply to everything after it until the closing curly brace }. Can you annotate an opening curly brace { ?  d) Introduce a new marker annotation @NullFree at B, that selectively cancels any @NonNullByDefault that might apply otherwise.  Thinking about it, my favorite is d)  PS: Inspired by bug 440630 comment 1 issue 1
"This ticket is a subtask of bug 440630 comment 1 issue 2  Download bug 440630 attachement 245468 and unzip as workspace and open with Eclipse Mars 5.5 nightly from July 28th 2014 In addition open the log-file in Kate or any other editor to monitor for changes. Deleted the // at the beginning of line A Kate signals a change in the log file, though eclipse silently ignored the exception (BTW, the java-file in Eclipse is still dirty and unsaved)  java.lang.IllegalArgumentException: Type doesn't have its own method? 	at org.eclipse.jdt.internal.compiler.lookup.SyntheticFactoryMethodBinding.applyTypeArgumentsOnConstructor(SyntheticFactoryMethodBinding.java:40) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.registerInferenceContext(AllocationExpression.java:776) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:170) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:739) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:695) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:5056) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:581) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:497) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:487) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:602) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
see demo code of bug 440630 attachment 245468 [details]  Uncommenting line marked F reveals that DefaultLocation.RETURN_TYPE erroneously affects the parameters element1 and element2  Illegal redefinition of parameter element1, inherited method from Comparator<T> does not constrain this parameter  inspired by bug 440630 comment 1 issue 7
The "Generate Javadoc" wizard should keep the generated javadoc-arguments temp file for a while to allow debugging.  The file is mentioned in the command line on the "Process properties" page, e.g: C:\java\jdk8\bin\javadoc.exe -J-showversion @C:\Users\xxx\AppData\Local\Temp\javadoc-arguments2359803814154564317.tmp  The file should not be deleted when the process terminates, but only when it is removed from the debug view (or on shutdown).
Member classes are non-static by default (unless they are members of interfaces or annotation types, in which case they are static by default) but they may be marked static explicitly.  Member enums, member interfaces, and member annotation types are static by default but they may be marked static explicitly. However, Eclipse displays a different type icon for these if they are marked static explicitly. Since the addition of the modifier does not change the meaning of the code, it should not change the icon.      class C {         class C1 {}         static class C2 {}                  enum E1 { X }         static enum E2 { X }                  interface I1 {}         static interface I2 {}                  @interface A1 {}         static @interface A2 {}     }          interface I {         class C3 {}         static class C4 {}                  enum E3 { X }         static enum E4 { X }                  interface I3 {}         static interface I4 {}                  @interface A3 {}         static @interface A4 {}     }  In this example, types C1, E1, I1, A1 have no 'S' in their icon. Types C2, E2, I2, A2 have an 'S' in their icon. However, E1, I1, A1 are static too, so they should also have the 'S' in their icon.   For comparison, all of the *3 and *4 types (the members of I) are static, and do consistently display the 'S', even though the *3 are only static implicitly.  Note that the only member type in the example code that is not static is C1.
Warnings can be seen here:  http://download.eclipse.org/eclipse/downloads/drops4/I20140804-2000/compilelogs/plugins/org.eclipse.jdt.apt.ui_3.3.500.v20140704-0625/@dot.html  This has started happening since this commit:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=4388c0ac2a341f1edd7db6cb0966477c51abd917
@SuppressWarnings("null") public class NullWarn {      // Some code  }  gets two Warnings (not in scope of any package default): line 1: Unnecessary @SuppressWarnings("null") line 2: A default nullness annotation has not been specified for the type NullWa
"When the following code is run, the output is '0', which is the original value of C.i.  public class A extends C { 	public A() { 		i = 1; 	} 	 	public int m(D d) { 		B b = new B() { 			public int n() { 				return i;     // Output is C.i 			} 		}; 		 		return b.n(); 	} 	 	public static void main(String[] args) { 		System.out.println(new A().m(new D())); 	} }  public class B extends C { 	public int n() { 		return -1; 	} }  public class C { 	public int i = 0; }  When A.m(D) is moved to D without delegate, two bug fixed are required.  1. Argument A of D.m(A) should be 'final'.  public class D { 	public int m(A a) {       // ERROR #1: should add 'final' 		B b = new B() { 			public int n() { 				return a.i;   // ERROR #2: should be just 'i' 			} 		}; 		 		return b.n(); 	} }  2. After move-refactoring, the output is changed to '1' due to incorrect update of reference (a.i is wrong)."
Typo in new API: org.eclipse.jdt.core.compiler.IProblem.NotAnnoationType
Created attachment 245874 [details] PDE Project  Steps to recreate problem: Open eclipse on bidi environments, e.g. Arabic locale Import the PDE project Right click on the project PDE Select Plug-in Tools Click Convert API Tools Javadoc Tags... Click Next button   Problem description: 1) "Original Source" and "Refactored Source" in API Tools Javadoc Conversion panel are not mirrored  2) Suggest to fix: The text order of displaying the contents of build.properties should be LTR   Expected result: Panels should be mirrored correctly and the text order and alignment of displaying source code should be correct on bidi loacles   PII Information: N/A
In the program below, the method requireNonNull is invoked with   @Nullable Iterable<@NonNull String>   as argument, and therefore the returned value is   @NonNull Iterable<@NonNull String>.   Assigning the returned value to the field iterable is therefore safe.  With Annotation-based null analysis enabled and "Unchecked conversion from non-annotated type to @NonNull type" set to warning, the null analysis issues a bogus warning: "The expression of type '@NonNull Iterable<String>' needs unchecked conversion to conform to '@NonNull Iterable<@NonNull String>'" at the line marked with (*)   package foo.bar;  import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.NonNullByDefault; import org.eclipse.jdt.annotation.Nullable;  @NonNullByDefault({}) public abstract class Foo {          abstract <T> @NonNull T requireNonNull(@Nullable T obj);          @NonNull Iterable<@NonNull String> iterable;          Foo(@Nullable Iterable<@NonNull String> iterable) {         this.iterable = requireNonNull(iterable); // (*)     } }
I was always amazed when I saw spelling errors in Javadocs, since spell checking is available and enabled by default in the Eclipse SDK.  Only today, I think I found the real reason: The default setting for "Maximum number of problems reported per file" is only 100. In a *.java file with many technical comments, this limit is quickly exceeded, and you're running blind for the rest of the file.  Either the default needs to be increased (I run with 1000), or it needs to be changed in *.java files to apply per comment and not per file.
"In org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer I see the following code:  public void processContents(MElementContainer<MUIElement> me) { 		if (!(((MUIElement) me) instanceof MWindow)) 			return; ...more }  JDT marks (MUIElement) me as unnecessary cast but if I remove this cast, I get an syntax error.   Is this a wrong warning message?"
The following class compiles with javac.exe (JDK 8u11 x86), but fails in Eclipse (tested on 4.4.0, 4.5M1, and I20140812-0800):  class Example {     void foo(Iterable<Number> x) { }      <T> void bar(Consumer<Iterable<T>> f) { }      void test() {         //call 1: lambda w/argument type - OK         bar((Iterable<Number> x) -> foo(x));          //call 2: lambda w/explicit type - OK         this.<Number> bar(x -> foo(x));          //call 3: method ref w/explicit type - OK         this.<Number> bar(this::foo);          //call 4: lambda w/implicit type - correctly(?) fails*         //bar(x -> foo(x));          //call 5: method ref w/implicit type - BUG!         bar(this::foo); // errors!     } }  The last method call gives two errors in Eclipse: 1. The method bar(Consumer<Iterable<T>>) in the type Example is not applicable for the arguments (this::foo) 2. The type Example does not define foo(Iterable<T>) that is applicable here  The types Consumer, Iterable, and Number are arbitrary and can be replaced with any functional interface, generic type, and non-generic type (ex. Predicate, Optional, String). Giving foo a return type or additional arguments to fit a different interface does not affect the bug.  The problem seems to stem from the nesting of the generic type parameter. The bug will not trigger if: - bar is changed to "<T extends Iterable<Number>> void bar(Consumer<T> f)" - All instances of Iterable<_> are replaced with their parameter (T or Number) - bar is changed to "void bar(Consumer<Iterable<Number>> f)"   *Surprisingly, javac will infer the type for the implicit method reference, but not for the implicit lambda (call 4). It just assigns Object to T and gives an "incompatible types" error. Eclipse does this as well, so I assume this is somehow correct behavior.
While debugging variations of bug 441693 I saw weird types of the shape    @NonNull capture#of @Nullable ? extends Foo  Since captures have no syntax this can only happen internally during resolving. Rather than waiting for downstream analysis to flag this as contradictory annotations (in the case of null type annotations), we should try hard to avoid such types.  I believe the rule should be that a capture and its wildcard should always have the same (immediate - not speaking about bounds) type annotations.
Eclipse 4.4.x has problems finding relevant methods passed as lambdas in streams if the methods have generic parameters. Here is a reproducible test case, which compiles fine with Oracle JDK 8:  import java.util.*;  public class EclipseJava8StreamLambdaGenerics {    public static class FooBar<V> {   }    public interface FooBarred {     public <V> boolean hasFooBar(final FooBar<V> fooBar);   }    public interface Widget extends FooBarred {   }    public static void test() {     Set<FooBar<?>> foobars = new HashSet<>();     Set<Widget> widgets = new HashSet<>();     boolean anyWidgetHasFooBar = widgets.stream().anyMatch(         widget -> foobars.stream().anyMatch(widget::hasFooBar)         );   }  }  This bug appears in Eclipse 4.4 and Eclipse 4.4.1 M20140813-0800.  See also Bug 441905, Bug 434044, and Bug 431408, which may nor may not be related (but which make me think that our company's use of generics must be unusually intense if no one else picked up on these earlier).
Given the following code, Eclipse gives a warning of "Unnecessary @SuppressWarnings("unchecked")". However, if I remove that annotation, I get "Type safety: Unchecked cast from Class<capture#10-of ?> to Class<? extends T>".        public <T> ClasspathScanner matchClassesImplementing(final Class<T> iface, final InterfaceMatchProcessor<T> interfaceMatchProcessor) {         if (!iface.isInterface()) {             throw new RuntimeException(iface.getName() + " is not an interface");         }         classMatchers.add(() -> {             // Call class loader for all classes implementing the specified interface, and call classMatchProcessor with these classes                 ArrayList<String> classesImplementingIface = interfaceToClasses.get(iface.getName());                 if (classesImplementingIface != null) {                     for (String implClass : classesImplementingIface) {                         try {                             @SuppressWarnings("unchecked")                             Class<? extends T> klass = (Class<? extends T>) Class.forName(implClass);                             interfaceMatchProcessor.processMatch(klass);                         } catch (ClassNotFoundException | NoClassDefFoundError e) {                             throw new RuntimeException(e);                         }                     }                 } else {                     Log.info("No classes found implementing interface " + iface.getName());                 }             });         return this;     }
Fix to Bug 412119 introduced an optional warning to report unused exception parameters, but optional warning uses the same JavaCore.COMPILER_PB_UNUSED_PARAMETER that we use for unused method parameter. And this has resulted in some unhappy users who do not like new warnings in their code and that both these warnings have been combined with the same preference (see bug 439750).   This bug is raised to track the UI side of the new preference and of course, to discuss if we want to do that in first place.
Created attachment 246143 [details] Static verifications java class  To simplify dealing with the user assertions that certain "legacy" method, or entire assignment is nonNull, I propose the following additions to the org.eclipse.jdt.annotation:  1. add @AssertNonNull - can be used in place of 2 annotation currently in use, @NonNull and the related @SuppressWarnings("null"), which is quite ugly. Also, this would be a future-proof, as later, when the null-analyses improved, Eclipse could be able to be specifically looking at this annotation for possible resolution. In version 1, @AssertNonNull would be applicable to all areas where @NonNull in use today; in version 2, anywhere where jsr308 permits it.  2. add org.eclipse.jdt.annotation.Verifications.java class with the static methods like assertNonNull, verifyNonNull, and so forth. This class itself should be annotated with @NonNullByDefault, in addition to its methods with @Nullable. This would allow to future-proof all its use, as later Eclipse could be scanning for these methods with aim of automatically/semi-automatically replacing them appropriately.  The attached is an example of the proposed class.
Created attachment 246188 [details] Source files which cause the problem  These two files lead eclipse to hang when building the workspace. Even if automatic build is turned off and a portion of text is copied to the clipboard within the java editor, eclipse hangs.  Project setup: - please create a new Java project, source level: java 8 - copy the attached files to src/test  Thanks for your help,  Daniel
Created attachment 246267 [details] Code triggering the bug.  The synthetic $deserializeLambda$ method may be generated before the synthetic methods for nested lambdas. When this happens the $deserializeLambda$ only handles the lambdas that have already been encountered but is missing subsequent lambdas.  For example, with the attached source code, only two of the three lambdas are handled in $deserializeLambda$.  The code in org.eclipse.jdt.internal.compiler.ClassFile already hints at this issue with the todo: // TODO [andy] do we need to do this after the loop to ensure it is done last?  The synthesis loop should be restructured to ensure the $deserializeLambda$ method is produced only after all the nested lambdas have been discovered.
Created attachment 246271 [details] Code triggering the bug.  When $deserializeLambda$ deserializes the captured arguments of a serializable lambda that captures the enclosing instance, it does not account for the captured instance when computing argument indexes.  The $deserializeLambda$ method for example code attached passes twice index 0 to  java.lang.invoke.SerializedLambda.getCapturedArg to obtain either the capture instance or the captured integer.  It looks like a simple coding mistake in org.eclipse.jdt.internal.compiler.codegen.CodeStream. In method generateSyntheticBodyForDeserializeLambda, in loop "for (int p=0,max=outerLocalVariables.length;p<max;p++)" the loop index "p" is used in place of the argument index "index" to generated the argument to "java.lang.invoke.SerializedLambda.getCapturedArg".
"Reproduced the following problem using HEAD: (reported in https://bugs.eclipse.org/bugs/show_bug.cgi?id=434326#c67)  0.) Use either N20140820-2000 or N20140821-2000   (1.) Create a new Java 8 project   (2.) Paste the following classes and interfaces to distict files:  //----  public class Entity implements IEntity<Entity> {  	public int compareTo(IBasicItem o) { 		return 0; 	} }  public interface IEntity<T extends IEntity<T>> extends IBasicItem {  }  public interface IBasicItem extends Comparable<IBasicItem> {  }  public interface IAdvancedItem extends Comparable<IBasicItem> {  }  //----   (3.) Edit ""Entity"" to also implement IAdvancedItem, i.e. change the first line to  ""public class Entity implements IEntity<Entity>, IAdvancedItem {""  You should now see the initially quoted error occur (can anybody confirm?).   (4.) Clean the project and start a complete build -> the error disappears.   (5.) Rename (Alt-Shift-R) the ""Entity"" class to something else -> the error re-appears.   (6.) Undo renaming the class -> the error is still present."
When a Java class has more than just the Java stratum (e.g it was generated by Xtend, so it also has an Xtend stratum), breakpoints in the Java file are not hit.  To reproduce: - download Eclipse for Java and DSL developers - new -> Examples -> Xtend Introductory Examples - Open xtend-gen/example1/HelloWorld.java - set a breakpoint in the main method - debug as Java application, the breakpoint is not hit  The reason lies in JavaLineBreakpoint#determineLocations, which calls ReferenceTypeImpl#locationsOfLine(int). This one-argument version tries to look up the Java line number in the default stratum, which in our case is Xtend. This leads to either no or wrong locations.  Plain JavaLineBreakpoints should always use the Java stratum by calling ReferenceTypeImpl#locationsOfLine(String, String, int).
See bug 442455 for more detail, but it is confusing (at best) for us to some tests marked as having performance tests, when they really don't.   From what I could see, the following have an empty performance target:   eclipse.jdt.core/org.eclipse.jdt.apt.pluggable.tests/test.xml eclipse.jdt.core/org.eclipse.jdt.compiler.apt.tests/test.xml eclipse.jdt.core/org.eclipse.jdt.compiler.tool.tests/test.xml eclipse.jdt.core/org.eclipse.jdt.core.tests.builder/test.xml eclipse.jdt.core/org.eclipse.jdt.core.tests.compiler/test.xml eclipse.jdt.core/org.eclipse.jdt.core.tests.model/test.xml  eclipse.jdt.ui/org.eclipse.ltk.core.refactoring.tests eclipse.jdt.ui/org.eclipse.ltk.ui.refactoring.tests   Hope you don't find me combining "core" with "ui".   Would appreciate either removing empty targets, or "comment them out" so they are not detected by the CBI-tool (and test framework) that mark them as "performance tests).
I use Eclipse Luna and everything was working fine until today when I saw this error message while trying to run my Java code:  http://i.stack.imgur.com/l0U4M.png  When I dismissed the message, clicking the run and debug buttons did nothing at all. I restarted Eclipse, but that did nothing.  After trying to find the source of the error, it seems that restarting the whole computer seems to "reset" everything. The first time I open Eclipse after a restart, the run button works fine for one run, but after that first run if I hover the cursor over the run button, I get the above error message and the run button stops working. Strangely, clicking the down arrow next to the run button and selecting my project works all the time, regardless of the error message.  Reinstalling did not fix anything. In fact, the error only occurs when one certain source file is open in the Editor... I tried removing class members one by one and the error only occurs if one specific method is present. This method is pretty long (176 LOC), and everything works fine if I remove at least 70 LOC. Breaking the method up into several helper methods does not help.
Required for bug 441790.  jdt.core has several implementation of string and char literal escaping. They should be combined into one and bugs should be fixed.  org.eclipse.jdt.core.dom.StringLiteral#setLiteralValue(String) and org.eclipse.jdt.internal.core.util.Disassembler#escapeChar(StringBuffer, char)  both escape \0 to \7 wrongly when they are followed by more octal numbers. E.g. "\0041" is the char sequence { '\4', '1' }, but such a sequence is currently escaped to "\41", which is equivalent to "!".  I don't see a reason why we should only escape \0 to \7 and not all chars below 0x20. We can't know how these chars were represented in source, but it makes sense to escape them all, so that the user knows what's going on and doesn't run into trouble with tools that don't properly display these characters. As JLS8 3.10.6 says, Unicode escapes are usually preferred.
FUP to bug 438621, we should add the hook in the Java debugger to allow 3rd parties to contribute step filters for the Java debug model.
Before the fix for Bug 368212 there was this fallback code in JavaLineBreakpoint#getJavaProject  if (sourceElement instanceof IJavaElement) {   return ((IJavaElement) sourceElement).getJavaProject(); } else if (sourceElement instanceof IResource) {   IJavaProject project = JavaCore.create(((IResource) sourceElement).getProject());   if (project.exists()) {     return project;   } }  This fallback code was deleted, even though the bug only required deleting a block further up in that method.  This is critical because for stratum line breakpoints (e.g. Xtend) the source will generally be some IFile and not an IJavaElement. This blocks conditional breakpoints in Xtend in Eclipse 4.3+
"NPE at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:129)  ---  The issue is present on 4.4.1 as well. (Version: Luna SR1 (4.4.1) Build id: M20140827-0800)  The issue is reproducible on master branch tip code.  ---  Test Case:  //Descriptor.java  package test; public interface Descriptor <UNMARSHAL_RECORD extends UnmarshalRecord, OBJECT_BUILDER extends CoreObjectBuilder> { 	public default OBJECT_BUILDER getObjectBuilder() { return null; } }  //Unmarshaller.java package test; public abstract class Unmarshaller<CONTEXT extends Context, DESCRIPTOR extends Descriptor> {    public CONTEXT getContext() { 	   return null;    } }  ---  Call stack:   java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:129) 	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:208) 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2369) 	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.rawTypeReference(ProblemReporter.java:7141) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:503) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:574) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.connectTypeVariables(Scope.java:949) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1099) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:229) 	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:746) 	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:383) 	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:428) 	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367) 	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.compile(IncrementalImageBuilder.java:330) 	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304) 	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build(IncrementalImageBuilder.java:135) 	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:267) 	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:195) 	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:729) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:204) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:244) 	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:297) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:300) 	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:356) 	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:379) 	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143) 	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:239) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
SAP JVM adds JNI-style method signatures in stack traces as additional info.  Those entries are not properly recognized in stack trace console, leading to wrong hyperlinks.  Example stack entry:   at java.util.concurrent.locks.LockSupport.parkNanos(Ljava/lang/Object;J)V(LockSupport.java:215) as opposed to   at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)    Change https://git.eclipse.org/r/#/c/32400/ adds support for these entries as well as tests for hyperlink detection.
"While running some smoke tests I found that triggering JDT content assist on the second argument of m() marked with a '$', JDT does not propose any types. Whereas when I trigger content assist on the first type I get all types as expected.     package __test;  import java.util.List;  public class Weird { 	private static void weird() { 		new Other() {  			@Override 			public void m(String s, L$ist l, Object o) { 			} 		}; 	} }  abstract class Other { 	public abstract void m(String s, List l, Object o); }"
From the changelog of JSR 335 0.9.3:  "Method References: Renumbered the Method Reference Expressions section 15.13 (to make room, the JLS 7 15.13 will be merged with a previous section)."  Still our code contains many references to the old number 15.28, which should be updated.
"package meth.refs; import java.util.function.Function; public class CL<T> { 	<F> String method1(CL<T> ie) { 		return ""b""; 	} 	public void bar() {		 		Function<CL<Integer>, String> v5 = CL::method1; 		v5 = t -> t.method1();	 	}	 }  ---------------------------------------------------  Edit anything and save the Java editor with above code. We get the following exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1301) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1770) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1665) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2939) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:476) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:250) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:530) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) ..."
After bug 430336, we need to adapt the quick assist again. Bug 430818 adapted the quick assist to 4.4.0, but the AST in master is slightly different.
"package p1;  class E21 { 	{private int[] nums;  	void foo() {         nums 	}	 }  --------------------------------------- In the above example, type anything and save. We get the following exception:  java.lang.IllegalArgumentException 	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1250) 	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:423) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) ..."
Steps to reproduce:  1. Open New JUnit Test Case Wizard (NewTestCaseCreationWizard) 2. See, that tearDownAfterClass() checkbox is enabled. 3. FAIL Click on any checkbox in "Which method stubs would you like to create?" section -> tearDownAfterClass() checkbox turns disabled.  I think that this is not desired behavior.
Convert lambda to anonymous should be a quick fix below 1.8
Consider this snippet:  //---import org.eclipse.jdt.annotation.*; abstract class Super {   Super(String s) { }   abstract void bar();   void foo() { bar(); } }  @NonNullByDefault public class X {   void test1(@Nullable String s) {     new Super(s) {       void bar() {}     }.foo();   } } //---  At 1.8 we currently report           new Super(s) {                   ^ Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'  This indicates that the @NonNullByDefault bogusly applies to the implicit declaration of the anonymous' constructor.  This is unfortunate as it makes instantiation of an unannotated class difficult in the context of @NonNullByDefault.
(In reply to David Williams from bug 374441 comment #48) > org.eclipse.jdt.ui.tests.refactoring    49 tests - 1 failure  The failing test is RenameTypePerfAcceptanceTests#testCold
If “Non-externalized strings (missing/unused $NON-NLS$ tag)” warning is enabled, the following code compiles with invalid “Non-externalized string literal; it should be followed by //$NON-NLS-<n>$” warning.  import java.util.concurrent.Callable;  public class Test {     Callable<String> c;      void setC(Callable<String> c) {         this.c = c;     }      Test() {         setC(() -> "ee"); //$NON-NLS-1$     } }  The same issue in Luna, Luna SR1-RC2, and Mars M1.
"Please see Bug 437973 Comment 17.  public final class Collections2 {     static interface Predicate<T> { boolean test(T object); }     public static <T> Predicate<T> in(Predicate<? extends T> arg) { return null; }     public static <T> Predicate<T> and(Predicate<? super T>... arg) { return null; }     public static <T> Predicate<T> and(Predicate<? super T> arg0, Predicate<? super T> arg1) { return null; }     static class FilteredCollection<E> {         Predicate<? super E> predicate;         public void error(Predicate<?> arg) { and(predicate, in(arg)); } // no compile     } }  ---  1. WARNING in Collections2.java (at line 4)\r\n 	public static <T> Predicate<T> and(Predicate<? super T>... arg) { return null; }\r\n 	                                                           ^^^\n Type safety: Potential heap pollution via varargs parameter arg\n   2. ERROR in Collections2.java (at line 8)\r\n 	public void error(Predicate<?> arg) { and(predicate, in(arg)); } // no compile\r\n 	                                      ^^^\n The method and(Collections2.Predicate<capture#1-of ? super E>, Collections2.Predicate<capture#2-of ?>) is undefined for the type Collections2.FilteredCollection<E>\n   ---  javac 1.8 compiles the code without any issues."
Hello Committers,  I found round about 150 events (all from a single user) in the error logs and though it may be worth reporting it. Maybe you can quickly spot the issue based on this stacktrace?   Please let me know what else we could (automatically) collect from a user to help you tracking that issue.  Best, Marcel  @message   timestamp=Wed Sep 10 09:48:04 EDT 2014   anonymousId=bac41314-e68f-499e-a691-4b75137e6066   eventId=8e22b97a-1659-4696-80d4-9a37cee8ccc4   eclipseBuildId=4.4.0.I20140606-1215   eclipseProduct=org.eclipse.epp.package.standard.product   javaRuntimeVersion=1.8.0_20-b26   osgiWs=win32   osgiOs=Windows8   osgiOsVersion=6.3.0   osgiArch=x86_64   presentBundles={com.codetrails.stats.stacktraces.server.eclipse.Bundle@4a6d15ca[   name=org.eclipse.core.jobs   version=3.6.0.v20140424-0053 ],Bundle[   name=org.eclipse.jdt.debug   version=3.8.100.v20140522-1618 ],Bundle[    name=org.eclipse.jdt   version=3.10.0.v20140606-1215 ]}   status=com.codetrails.stats.stacktraces.server.eclipse.Status@a8136b88[   pluginId=org.eclipse.core.jobs   pluginVersion=3.6.0.v20140424-0053   code=2   severity=4   message=An internal error occurred during: "JDI Event Dispatch".   fingerprint=3d0ae8a9   exception=  java.lang.NullPointerException: null     at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget$ThreadStartHandler.handleEvent(JDIDebugTarget.java:1955)     at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:152)     at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100)     at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249)     at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)   children={} ]  https://dev.eclipse.org/recommenders/errors/8e22b97a-1659-4696-80d4-9a37cee8ccc4.txt
Created attachment 246938 [details] Example project that shows problem  In projects with annotation processors, it is possible to get bogus error messages.  Please try out the example project I have attached and see that there is an error message in Anno.java saying that A.X cannot be resolved to a variable. A.X is defined and you can even navigate to it using F3.  Here's what I believe is happening: 1. In the annotation processor there is a call to Elements#getElementValuesWithDefaults() 2. This causes type resolution for A.X since A.X is the default value for the foo() attribute for Anno.java using the method org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(BlockScope) 3. The type resolution of A.X causes the 'RestrictiveFlags' part of the 'bits' field of the binding for A.X to change from Binding.VARIABLE to Binding.FIELD 4. After the annotation processing the normal build begins. 5. A.X is again resolved but since the 'RestrictiveFlags' part of the 'bits' field for the A.X binding is Binding.FIELD, it does not match any of the cases in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(BlockScope) and so an error is reported.   I don't really understand how the JDT compiler works so I haven't been able to find a fix for this issue.
"> java.lang.ArrayIndexOutOfBoundsException: 1 > 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:217) > 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkNullSpecInheritance(ImplicitNullAnnotationVerifier.java:291) > 	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:113) > 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.createArgumentBindings(SourceTypeBinding.java:2004) > 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1971) > 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1464) > 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.unResolvedMethods(ReferenceBinding.java:1804) > 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:511) > 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:484) > 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:969) > 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify(MethodVerifier15.java:1003) > 	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:979) > 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:2508) > 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:824) > 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:767) > 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) > 	at java.lang.Thread.run(Thread.java:745)  eclipse.buildId=4.4.1.M20140902-1430 java.version=1.8.0_11 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product   Sorry, I wasn't able to reduce my large project to replicate this in a small test-case."
Created attachment 246998 [details] Sample Java project  Building large Java element deltas is really slow.  Steps to reproduce:  1. Import the attached Java project. 2. Open the file Functions.java with the Java editor. 3. Select and delete all methods in the class Functions (15000 Java elements).  It will take many seconds before the Outline view is refreshed. Most of the time is spent in JavaElementDeltaBuilder#buildDeltas, which is called from ReconcileWorkingCopyOperation#makeConsistent.  4. Undo the deletion above.  Again, #buildDeltas will take most of the reconciling time.  As an aside, this problem (building large deltas being really slow) was first observed in Handly (http://eclipse.org/handly/) while conducting scalability tests. Since HandleDelta and HandleDeltaBuilder code in Handly was originally adapted from JDT, I thought it might affect JDT too and so it did.  In Handly, I was able to fix the problem with the introduction of childIndex, a HashMap in HandleDelta to speed up child delta searches. It provided a  significant performance boost on large deltas. Please see the bug 443813 for more details.  I could try to make a similar patch for JDT, if you are interested.  Best Regards, Vladimir
"Follow-up to bug 402081 and bug 433178.  Have this code:          IntFunction<String> ts= Integer::toString;  Set caret after ""Integer::to"" and press Ctrl+Space. Try to apply e.g. ""toBinaryString(int)"". => The proposal is not inserted. The problem is that the replaceRange is wrong.  This code in CompletionEngine.findLocalMethods(..) line 8750 looks wrong:  	if (completionOnReferenceExpressionName) 		proposal.setReplaceRange(this.endPosition - this.offset - methodLength, this.endPosition - this.offset); 	else  When I remove that change from bug 402081, then the proposals work as expected."
"4.5.0.I20140909-1315, already happens with 4.4.0.I20140606-1215  - Launch Eclipse with these debug options enabled: org.eclipse.jdt.core/debug=true org.eclipse.jdt.core/debug/dom/ast=true  - Paste the source cited in the error message to the Package Explorer. - Set caret after ""{"" - Press Space, wait for the reconciler. => Error in the log. => The range of the first method parameter is ""/*int*/ realpath(byte[] path"".  A visible effect of this is that ""Edit > Expand Selection To > Enclosing Element"" always selects the whole bad range. A normal ASTParser#createAST(..) call doesn't exhibit this problem.  org.eclipse.jdt.core Error Fri Sep 12 14:33:03 CEST 2014 Bad AST node structure: - parent [59, 138] org.eclipse.jdt.core.dom.MethodDeclaration    previous [99, 107] org.eclipse.jdt.core.dom.SimpleName    parameters [91, 119] org.eclipse.jdt.core.dom.SingleVariableDeclaration  ----------------------------------- SOURCE BEGIN ------------------------------------- package org.eclipse.swt.internal.gtk; public class OS {  public static final native long /*int*/ realpath(byte[] path, byte[] realPath); }  ----------------------------------- SOURCE END -------------------------------------  java.lang.IllegalStateException: Bad AST node structure 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419) 	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
"Sorry for the big description, but I was unable to create a simple reproduction 8-(  Summary: Eclipse 4.4 and 4.4.1(rc3) both exhibit the following odd problem: when a workspace's projects are newly imported, or when a ""clean (all) projects"" operation is done I get two similar errors in my project:  Type mismatch: cannot convert from Class<ContractantTypeLister> to Class<? extends IComboDataSet<?>>  But: the errors /disappear/ if I comment the line, save the file, then uncomment again and save again. So the /incremental/ compile does compile the code, but a full compile does not. The code compiles correctly with Javac and with Kepler and Juno's compilers.  Details: The failing construct is:  @MetaCombo(dataSet = ContractantTypeLister.class, properties = { 	@MetaComboProperty(name = ""description"") }) public ContractantType getContractantType() {  ------------------  The relevant part of the MetaCombo annotation looks like: @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface MetaCombo { 	Class< ? extends IComboDataSet< ? >> dataSet() default UndefinedComboDataSet.class;  ------------------  That ""default"" there assigns the same kind of class as the later failed one, yet it does not fail.  The ""ContractantTypeLister"" class is defined as: public class ContractantTypeLister implements IComboDataSet<ContractantType> { 	@Override 	public @Nonnull List<ContractantType> getComboDataSet(@Nonnull UrlPage cc) throws Exception { 		return DaoContractantTypes.getAll(cc.getSharedContext()); 	} }  The annotation AND the IComboDataSet interface are defined in the same project. The failing class is in another. A ""clean"" on the project with the error will also reproduce the error."
"import java.util.List;  class E21 { 	private int[][] nums;  	void foo() { 		nums 	}	 } -------------------------------------  Press Ctrl+1 at 'nums' in #foo and select ""Create 'for' loop"" or ""Create enhanced 'for' loop"" quick assist. The type to loop over does not contain any array dimension:  class E21 { 	private int[][] nums;  	void foo() { 		for (int i : nums) { 			 		} 	}	 }  Looks like it was not handled in the initial patch itself in GenerateForLoopAssistProposal.extractElementType(AST ast)."
"In two separate files, create an interface and an implementation:  public interface Interface<T> { 	@Nullable T get(); }  @NonNullByDefault public class Impl implements Interface<String> { 	// No methods }  Although Impl does not implement the method specified in the interface, the compiler successfully compiles both classes, without errors.  The problem seems to be caused by the nullable generic return type of the method. The @NonNullByDefault annotation on the implementing class also has something to do with it. When it is removed, the class correctly won't compile."
"Please See Bug 435682 Comment 2.  --- import java.util.Arrays; import java.util.List; import java.util.stream.Collectors;   public class X1 { 	List<String> words = Arrays.asList(""hi"", ""hello"", ""hola"", ""bye"", ""goodbye""); 	List<String> list1 = words.stream().map(so -> so.[1]).collect(Collectors.toList()); } ---  [1] No proposals offered."
Created attachment 247143 [details] Testproject reproducing the described behavior  Consider the following Code:  public class TestGenericUncheckedConversion {     public static void main(String[] args) {         doSomething(returnClassType(Class.class));         doSomething(returnListType(new ArrayList<List>()));     }      public static <T> void doSomething(Class<T> clazz) {         System.out.println(clazz.getSimpleName());     }     public static <T> T returnClassType(Class<T> clazz) {         return null;     }     public static <T> void doSomething(List<T> list) {         System.out.println(list.getClass().getSimpleName());     }     public static <T> T returnListType(List<T> list) {         return null;     } }  The Eclipse JavaSE-1.7 compiler issues warnings for both doSomething() calls in the class's main method which can be suppressed by adding the @SuppressWarnings({ "unchecked", "rawtypes" }) annotation to the method:  - Type safety: The expression of type Class needs unchecked conversion to conform to Class<Object> - Type safety: The expression of type List needs unchecked conversion to conform to List<Object> - Type safety: Unchecked invocation doSomething(Class) of the generic method doSomething(Class<T>) of type TestGenericUncheckedConversion - Type safety: Unchecked invocation doSomething(List) of the generic method doSomething(List<T>) of type TestGenericUncheckedConversion - (List is a raw type. References to generic type List<E> should be parameterized)  Using the JavaSE-1.8 compiler however instead of the warnings mentioned above an error is generated for each doSomething() call:  - The method doSomething(Class<T>) in the type TestGenericUncheckedConversion is not applicable for the arguments (Class) - The method doSomething(Class<T>) in the type TestGenericUncheckedConversion is not applicable for the arguments (List)  Using Java8's javac, the code just compiles fine.  On the second invocation of doSomething(), the error goes away when the generic type argument for List is specified. However in the first example, this solution is not possible because the generic type argument for Class.class is just Class and not Class<Class> (which would be recursive :D).  Although this seems like a bit of a constructed example, we are actually facing this problem during transition from JavaSE-1.7 to JavaSE-1.8. Many of our unit tests for a registry like object contain jMock code similar to the following example:  allowing(registry).getObject(with(any(Class.class));  I tested this with the following Eclipse releases all yielding the same result: - Kepler with Java8 Support Patch applied - Luna 4.4 - Luna 4.4 SR1 RC3 - Mars 4.5 M1  I also checked the Java - Compiler - Errors/Warnings Preferences but no option in the "Generic types" section is set to "Error".  You can find my test project attached to this bug.
See bug 443650 comment 5 for similar issue.   But while searching our repo tonight, for other "hidden mentions" of the MacOSX 32 bit platform, I did see the launching bundle has a p2.inf file, that says  requires.1.namespace = org.eclipse.equinox.p2.iu requires.1.name = org.eclipse.swt.cocoa.macosx #requires.1.range = [$version$,$version$] requires.1.filter = (&(osgi.os=macosx)(osgi.ws=cocoa)(osgi.arch=x86))  I think under normal conditions this would not hurt anything, but, might when a user ends up with several "repos" enabled, some of which have the fragment, and some that don't (such as Luna vs. Mars) I think complications could arise?   I'd recommend that be removed .. on semantic grounds alone ... since it does not accurate state the requirements in mars stream.
Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidMethod(ProblemReporter.java:4022)  when compiling  class Foo {     static void foo(java.util.Map<Long, Long> map) {         java.util.function.Consumer<int[]> c = array -> map.compute(array.get(0), (k, v) -> null);     } }
"Summary:  When using a method reference inside a constructor call, the following issue is reported on project build:  java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.shouldGenerateImplicitLambda(ReferenceExpression.java:182)  The below code will demonstrate the issue in Eclipse 4.4  // https://gist.github.com/NeQuissimus/1986029efa51e5b18111 See Error #2 import java.util.ArrayList; import java.util.List; import java.util.Optional;   public class WillNotWork {   static class Container {     final private String s;     public Container(String s) { this.s = s; }   }     public static void main(String[] args) {     final List<Container> list = new ArrayList<>();     final Optional<String> optStr = Optional.of(""foo"");     list.add(new Container(optStr.orElseThrow(IllegalStateException::new))); // Error here       // This will work:     final String s = optStr.orElseThrow(IllegalStateException::new);     list.add(new Container(s));	   } }  I am doing this with Java 1.8.0_11 on OSX 10.9.4 but it can be reproduced with 1.8.0_05 and OSX 10.9.3 as well. I suspect that the Java/OS versions have no impact here. Just mentioning it for additional information."
"Summary:  When using a method reference in a constructor call, a NPE will be throws from inside LambdaExpression.analyseCode:  java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:469)  The following code reproduces the issue:  // https://gist.github.com/NeQuissimus/1986029efa51e5b18111 Error #1 import java.util.ArrayList; import java.util.List; import java.util.Optional;   public class WillNotWork {   static class Container {     final private String s;     public Container(String s) { this.s = s; }   }     public static void main(String[] args) {     final List<Container> list = new ArrayList<>();     final Optional<String> optStr = Optional.of(""foo"");     list.add(new Container(optStr.orElseThrow(() -> new IllegalStateException()))); // Error here       // This will work:     final String s = optStr.orElseThrow(IllegalStateException::new);     list.add(new Container(s));	   } }  This is most likely related to https://bugs.eclipse.org/bugs/show_bug.cgi?id=444772 I am submitting a separate issue because I am unsure whether the two are related or just coincidental."
"package net.xyz.control.dispatcher;  import java.util.ArrayList; import java.util.List; import com.amazonaws.services.ec2.AmazonEC2; import com.amazonaws.services.ec2.model.TerminateInstancesRequest;  public class Abc {      private AmazonEC2 ec2;          public static void main(String[] args) {         new Abc();     }      private void doSth() {         final List<String> l = new ArrayList<>();          try {             System.out.println(""ok"");         } finally {             Runnable r = () -> ec2.terminateInstances(new TerminateInstancesRequest().withInstanceIds(l));         }     }  }  Exception in thread ""main"" java.lang.VerifyError: Bad local variable type Exception Details:   Location:     net/xyz/control/dispatcher/Abc.lambda$0(Ljava/util/List;)V @11: aload_2   Reason:     Type top (current frame, locals[2]) is not assignable to reference type   Current Frame:     bci: @11     flags: { }     locals: { 'net/control/dispatcher/Abc', 'java/util/List' }     stack: { 'com/amazonaws/services/ec2/AmazonEC2', 'com/amazonaws/services/ec2/model/TerminateInstancesRequest' }   Bytecode:     0000000: 2ab4 0038 bb00 3a59 b700 3c2c b600 3db9     0000010: 0041 0200 b1                             	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688) 	at java.lang.Class.getMethod0(Class.java:2937) 	at java.lang.Class.getMethod(Class.java:1771) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)  if I comment out  // System.out.println(""ok""); situation changes for better...      private void doSth() {         final List<String> l = new ArrayList<>();          try {             // System.out.println(""ok"");         } finally {             Runnable r = () -> ec2.terminateInstances(new TerminateInstancesRequest().withInstanceIds(l));         }"
Hello committers,  we received a new error report for Eclipse 4.4.0.I20140606-1215.   General Information:     anonymous-id:         f8087d7b-9d38-4c73-aeb1-6991603c2a84     eclipse-build-id:     4.4.0.I20140606-1215     eclipse-product:      org.eclipse.epp.package.standard.product     operating system:     MacOSX 10.9.4 (x86_64) - cocoa     java-runtime-version: 1.8.0_20-b26  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.commands_3.6.100.v20140528-1422     2. org.eclipse.core.databinding.observable_1.4.1.v20140210-1835     3. org.eclipse.core.databinding_1.4.1.v20140214-0004     4. org.eclipse.core.resources_3.9.0.v20140514-1307     5. org.eclipse.core.runtime_3.10.0.v20140318-2214     6. org.eclipse.e4.core.commands_0.10.2.v20140424-2344     7. org.eclipse.e4.core.contexts_1.3.100.v20140407-1019     8. org.eclipse.e4.core.di_1.4.0.v20140414-1837     9. org.eclipse.e4.ui.bindings_0.10.200.v20140424-2042     10. org.eclipse.e4.ui.workbench_1.1.0.v20140528-1949     11. org.eclipse.e4.ui.workbench.swt_0.12.100.v20140530-1436     12. org.eclipse.equinox.app_1.3.200.v20130910-1609     13. org.eclipse.equinox.launcher_1.3.0.v20140415-2008     14. org.eclipse.jdt_3.10.0.v20140606-1215     15. org.eclipse.jdt.ui_3.10.0.v20140604-1403     16. org.eclipse.jface_3.10.0.v20140604-0740     17. org.eclipse.ltk.core.refactoring_3.6.100.v20140520-1248     18. org.eclipse.osgi_3.10.0.v20140606-1445     19. org.eclipse.recommenders.stacktraces.rcp_2.1.10.v20140922-1455     20. org.eclipse.swt_3.103.0.v20140605-2008     21. org.eclipse.ui_3.106.0.v20140519-0906     22. org.eclipse.ui.editors_3.8.200.v20140401-1310     23. org.eclipse.ui.ide.application_1.0.500.v20140514-2033     24. org.eclipse.ui.ide_3.10.0.v20140521-1937   Error Status:     code:                   380     message:                The resource tree is locked for modifications.     fingerprint:            b5bdbf3b     exception class:        java.lang.RuntimeException     exception message:      Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool     number of children:     0  Topmost Stacktrace:  java.lang.RuntimeException: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool     at org.eclipse.recommenders.internal.stacktraces.rcp.LogListener.insertDebugStacktraceIfEmpty(LogListener.java:104)     at org.eclipse.recommenders.internal.stacktraces.rcp.LogListener.logging(LogListener.java:81)     at org.eclipse.core.internal.runtime.RuntimeLog.logToListeners(RuntimeLog.java:160)     at org.eclipse.core.internal.runtime.PlatformLogWriter.logged(PlatformLogWriter.java:100)     at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.safeLogged(ExtendedLogReaderServiceFactory.java:86)     at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.logPrivileged(ExtendedLogReaderServiceFactory.java:205)     at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.log(ExtendedLogReaderServiceFactory.java:178)     at org.eclipse.osgi.internal.log.ExtendedLogServiceFactory.log(ExtendedLogServiceFactory.java:65)     at org.eclipse.osgi.internal.log.ExtendedLogServiceImpl.log(ExtendedLogServiceImpl.java:87)     at org.eclipse.osgi.internal.log.LoggerImpl.log(LoggerImpl.java:54)     at org.eclipse.core.internal.runtime.Log.log(Log.java:62)     at org.eclipse.core.internal.utils.Policy.log(Policy.java:133)     at org.eclipse.core.internal.resources.Workspace.checkpoint(Workspace.java:545)     at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.aboutToNotify(UndoableOperation2ChangeAdapter.java:289)     at org.eclipse.core.commands.operations.TriggeredOperations.aboutToNotify(TriggeredOperations.java:363)     at org.eclipse.core.commands.operations.DefaultOperationHistory$1.run(DefaultOperationHistory.java:923)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:912)     at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyNotOK(DefaultOperationHistory.java:1029)     at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyNotOK(DefaultOperationHistory.java:1013)     at org.eclipse.core.commands.operations.DefaultOperationHistory.flushUndo(DefaultOperationHistory.java:673)     at org.eclipse.core.commands.operations.DefaultOperationHistory.dispose(DefaultOperationHistory.java:336)     at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.flushWorkspaceHistory(WorkspaceUndoMonitor.java:260)     at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.checkOperationHistory(WorkspaceUndoMonitor.java:246)     at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.access$4(WorkspaceUndoMonitor.java:209)     at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor$1.resourceChanged(WorkspaceUndoMonitor.java:132)     at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:291)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:285)     at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:149)     at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:378)     at org.eclipse.core.internal.resources.Workspace.checkpoint(Workspace.java:540)     at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.aboutToNotify(UndoableOperation2ChangeAdapter.java:289)     at org.eclipse.core.commands.operations.TriggeredOperations.aboutToNotify(TriggeredOperations.java:363)     at org.eclipse.core.commands.operations.DefaultOperationHistory$1.run(DefaultOperationHistory.java:923)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:912)     at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyAboutToExecute(DefaultOperationHistory.java:953)     at org.eclipse.core.commands.operations.DefaultOperationHistory.openOperation(DefaultOperationHistory.java:1335)     at org.eclipse.ltk.internal.core.refactoring.UndoManager2.aboutToPerformChange(UndoManager2.java:139)     at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:364)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1598)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1593)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1380)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1458)     at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:132)     at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:69)     at org.eclipse.ui.actions.WorkspaceModifyOperation$1.run(WorkspaceModifyOperation.java:106)     at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)     at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:118)     at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:75)     at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:65)     at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:456)     at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:772)     at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5076)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1247)     at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1301)     at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7209)     at org.eclipse.ui.Saveable.doSave(Saveable.java:216)     at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:355)     at org.eclipse.ui.internal.SaveableHelper$3.run(SaveableHelper.java:199)     at org.eclipse.ui.internal.SaveableHelper$5.run(SaveableHelper.java:283)     at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)     at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)     at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2144)     at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)     at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2140)     at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:291)     at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:269)     at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:211)     at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:146)     at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3851)     at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3865)     at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:54)     at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:294)     at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)     at sun.reflect.GeneratedMethodAccessor228.invoke(null:-1)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:483)     at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)     at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)     at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)     at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)     at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)     at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)     at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)     at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)     at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)     at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)     at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1087)     at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4184)     at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467)     at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490)     at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475)     at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1504)     at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1500)     at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:496)     at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1060)     at org.eclipse.swt.widgets.Display.windowProc(Display.java:5719)     at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(OS.java:-2)     at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68)     at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:594)     at org.eclipse.swt.widgets.Display.windowProc(Display.java:5629)     at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(OS.java:-2)     at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221)     at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2105)     at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2329)     at org.eclipse.swt.widgets.Display.windowProc(Display.java:5691)     at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(OS.java:-2)     at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5128)     at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5277)     at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(OS.java:-2)     at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128)     at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3655)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)     at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)     at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)     at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)     at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)     at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)     at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:483)     at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)     at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)     at org.eclipse.equinox.launcher.Main.run(Main.java:1465)       Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/reports/54213f0ce4b0f1322ab5159f for the complete error log.  The list of all reported error reports belonging to this error group can be fetched from http://dev.eclipse.org/recommenders/states/54213f0ce4b0f1322ab515a0/reports  The Error Log Reporter presents the current processing state of this error to  new reporters. This state can be updated by modifying the values of this bug. To update the error log database call the link below after each change made to this bug report: http://dev.eclipse.org/recommenders/states/54213f0ce4b0f1322ab515a0/sync   Thank you for caring. Your friendly error reports bot.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"Eclipse crashes when overriding a default method. The happens either when using content assist (ctrl+space) or when choosing Source->Override/Implement Methods from the Menu (or via pop-up menu). See a stack trace below.  Reproduce this by creating a class that implements java.util.Collection. Try overriding a default method (e.g. #parallelStream) by using one of the methods described above. An unhandled event loop exception will occur.   java.lang.IllegalArgumentException: Invalid identifier : >Collection<E>< 	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:199) 	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:2202) 	at org.eclipse.jdt.core.dom.AST.newName(AST.java:1929) 	at org.eclipse.jdt.internal.corext.dom.ASTNodeFactory.newName(ASTNodeFactory.java:96) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:374) 	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:315) 	at org.eclipse.jdt.internal.ui.text.java.OverrideCompletionProposal.updateReplacementString(OverrideCompletionProposal.java:158) 	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposal.apply(JavaTypeCompletionProposal.java:107) 	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:497) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:963) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:914) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:910) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:674) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:119) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)"
This bug is track the specification change in JLS 18.5.2: Invocation Type Inference (https://bugs.openjdk.java.net/browse/JDK-8038747)  https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682 and its dozen cousin are affected by this. Javac ATM does extra constitutional stuff and compiles this code.  The cited Oracle bug has proposed amendments - this needs to be investigated and taken to completion.
When I click on a Korean word, eclipse doesn't select the whole word but only one character.  Text editors don't seem to treat non-Roman spelled words properly.
False resource leak warning:  try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {   for (;;) {     return;   } } catch (Exception e) { }  Same code but no warning:  try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {   while (true) {     return;   } } catch (Exception e) { }
The commit made for https://bugs.eclipse.org/bugs/show_bug.cgi?id=442245 breaks this test, don't know why. I wonder if it may be have worked by relying on incorporation having run a bit more earlier than absolutely needed. Having said that the prior incorporatedBounds.contains mechanism to avoid reincorporation and the present generational incorporation should really be equivalent. Long story short - needs investigation.
"With annotation-based null analysis enabled and the interfaces below, one gets java.lang.StackOverflowError when building the project. With annotation-based null analysis disabled, the project can be compiled.  package foobar; @org.eclipse.jdt.annotation.NonNullByDefault interface Bar<B extends Bar<B, F>, F extends Foo<F, B>> {}  -----  package foobar; @org.eclipse.jdt.annotation.NonNullByDefault interface Foo<F extends Foo<F, B>, B extends Bar<B, F>> {}  -----  java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:208) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:155) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:218) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:164) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:218) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:155) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:218) 	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:164) ..."
With Null Analysis enabled, one gets for the program below:  Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isProvableDistinctSubType(TypeBinding.java:750)  @org.eclipse.jdt.annotation.NonNullByDefault class Bar<E extends Bar.Foo<E>> {     final Iterable<E> list;      Bar() {         this((Iterable<E>) emptyList());     }      Bar(Iterable<E> list) { this.list = list; }      private static <X extends Foo<X>> Iterable<X> emptyList() { throw new UnsupportedOperationException(); }      interface Foo<F extends Foo<F>> { } }
Created attachment 247419 [details] whole Eclipse project, with 4 source files and their compiled .classes as well  The code below, when compiled by Eclipse (4.4.1), causes an IllegalAccessError to be thrown by "clazz.isAnonymousClass()" when it's run. The same code can be successfully compiled and runs properly by java's javac (java 1.7.0).  I encountered this problem on my project, and then did my best to trim it down to a minimal reproduceable case, but I still need 4 classes in 2 java packages. Just about anything that I try to trim down any further makes the problem disappear.  Be careful tinkering with this: incremental compile sometimes does not toggle the thing to go good/bad (i.e. when making any change to the code, do a full clean and re-run).  I attach here the entire project as a zip, including the .classes as I see them.  BTW, here's a few examples of things that make the problem go away:  1. Stop calling .setJobName on Buggered  2. Make Base public  3. put all classes in the same package  4. simplify the generic type of Base.Builder
"When compiling classes, I frequently get the error below.   It happens when the compiled source contains an error (e.g. a syntax error). Unfortunately, I can't isolate a piece of code to reproduce the bug. Maybe it has something to do with the state of my eclipse project.  I'm using 4.4.1 and java 8.   java.lang.IllegalStateException 	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.clone(UnresolvedReferenceBinding.java:43) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:339) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:268) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:989) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanFieldForNullAnnotation(BinaryTypeBinding.java:1482) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:493) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:696) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:679) 	at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:99) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:180) 	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:186) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:399) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:447) 	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:763) 	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137) 	at java.lang.Thread.run(Thread.java:744)"
Created attachment 247553 [details] example of compiler errors  Similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=435689 and others, it seems that it's not picking up the type for a constructor that extends a parameterized class.  Eclipse gives a compiler error, but javac compiles it just fine.  Note - I'm still seeing this with 4.4.1, but that version isn't in the list of choices yet.
"I came across this after importing vert.x code into Eclipse Luna. Line 297 below causes JDT to report a ""Lambda expression's parameter future cannot redeclare another local variable defined in an enclosing scope."" compilation error:  https://github.com/eclipse/vert.x/blob/master/vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java#L297  I think the compiler is confused by the nested enclosing scopes. The ""future"" parameter on line 297 is considered to collide with the declaration of future on line 286. I understand lambdas do not define a nested scope, but it seems like the JDK considers this not to be the case (the code compiles and runs fine with Oracle JDK 1.8.0_20).  One can easily reproduce this by using this snippet:  import java.util.function.Consumer; public class LambdaScopeTest { 	void methodInFirstLevel(int y) { 		class Second { 			int t = y; 			Consumer<Integer> myConsumer1 = (z) -> { 				System.out.println(""z = "" + z); 				System.out.println(""y = "" + y); 				System.out.println(""t = "" + t); 			}; 			Consumer<Integer> myConsumer2 = (y) -> { 				System.out.println(""y = "" + y); 				System.out.println(""t = "" + t); 			}; 		} 		new Second().myConsumer1.accept(10); 		new Second().myConsumer2.accept(20); 	} 	 	public static void main(String[] args) { 		new LambdaScopeTest().methodInFirstLevel(5); 	} }  In the snippet above you will get the same behavior for parameter y in myConsumer2."
Hello committers,  we received a new error report for Eclipse 4.4.1.M20140925-0400.   General Information:     anonymous-id:         24ad43ce-0a9e-4ffd-a544-d73b21063102     eclipse-build-id:     4.4.1.M20140925-0400     eclipse-product:      org.eclipse.epp.package.jee.product     operating system:     Windows7 6.1.0 (x86_64) - win32     java-runtime-version: 1.8.0_20-b26  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.runtime_3.10.0.v20140318-2214     2. org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926     3. org.eclipse.jdt.debug_3.8.101.v20140902-1548     4. org.eclipse.jdt_3.10.0.v20140925-0400     5. org.eclipse.jface_3.10.1.v20140813-1009     6. org.eclipse.swt_3.103.1.v20140903-1938   Error Status:      code:                   2     plugin:                 org.eclipse.equinox.preferences_3.5.200.v20140224-1527     message:                Problems occurred when invoking code from plug-in: "org.eclipse.equinox.preferences".     fingerprint:            87791828     exception class:        org.eclipse.swt.SWTException     exception message:      Invalid thread access     number of children:     0          org.eclipse.swt.SWTException: Invalid thread access     at org.eclipse.swt.SWT.error(SWT.java:4441)     at org.eclipse.swt.SWT.error(SWT.java:4356)     at org.eclipse.swt.SWT.error(SWT.java:4327)     at org.eclipse.swt.widgets.Widget.error(Widget.java:476)     at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:367)     at org.eclipse.swt.widgets.Tree.getSelection(Tree.java:3446)     at org.eclipse.jface.viewers.TreeViewer.getSelection(TreeViewer.java:232)     at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:311)     at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2524)     at org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget(StructuredViewer.java:1751)     at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2977)     at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1443)     at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366)     at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1397)     at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1525)     at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:533)     at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1481)     at org.eclipse.jdt.internal.debug.ui.classpath.RuntimeClasspathViewer$1.preferenceChange(RuntimeClasspathViewer.java:58)     at org.eclipse.core.internal.preferences.EclipsePreferences$3.run(EclipsePreferences.java:896)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.internal.preferences.EclipsePreferences.firePreferenceEvent(EclipsePreferences.java:899)     at org.eclipse.core.internal.preferences.EclipsePreferences.put(EclipsePreferences.java:912)     at org.eclipse.jdt.internal.debug.ui.jres.JREsUpdater$1.run(JREsUpdater.java:91)     at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/54328c1ee4b0a33678b204b7 for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
Hello committers,  we received a new error report for Eclipse 4.4.1.M20140925-0400.   General Information:     anonymous-id:         07a45dd4-f95f-478f-a15e-4000ce15f73a     eclipse-build-id:     4.4.1.M20140925-0400     eclipse-product:      org.eclipse.epp.package.standard.product     operating system:     Windows8 6.2.0 (x86_64) - win32     java-runtime-version: 1.8.0_20-b26  The following plug-ins were present on the execution stack (*):     1. org.eclipse.jdt.core_3.10.0.v20140902-0626     2. org.eclipse.jdt_3.10.0.v20140925-0400   Error Status:      code:                   4     plugin:                 org.eclipse.jdt.core_3.10.0.v20140902-0626     message:                Background Indexer Crash Recovery     fingerprint:            6675354d     exception class:        java.util.zip.ZipError     exception message:      jzentry == 0,  jzfile = 466081616,  total = 341,  name = D:\_DEVEL_\facebook-android-sdk-3.17.1\facebook\bin\facebooksdk.jar,  i = 1,  message = null     number of children:     0          java.util.zip.ZipError: jzentry == 0,  jzfile = 466081616,  total = 341,  name = D:\_DEVEL_\facebook-android-sdk-3.17.1\facebook\bin\facebooksdk.jar,  i = 1,  message = null     at java.util.zip.ZipFile$ZipEntryIterator.next(null:-1)     at java.util.zip.ZipFile$ZipEntryIterator.nextElement(null:-1)     at java.util.zip.ZipFile$ZipEntryIterator.nextElement(null:-1)     at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:228)     at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:405)     at java.lang.Thread.run(null:-1)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/54329fb9e4b0a33678b204ca for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"Eclipse Mars, Build ID I20140930-0800, running on OS X Yosemite Beta 2, Java 1.8.0_20  Adding @NonNullByDefault to package-info.java appears to prevent Eclipse from properly figuring out the type arguments used in a generic constructor.  FuncList.java:  package sol;  interface FuncList<A> {} 	 final class Node<A> implements FuncList<A> { 	private final A a; 	private final FuncList<A> tail; 	 	Node(final A a, final FuncList<A> tail) { 		this.a = a; 		this.tail = tail; 	} }  final class Empty<A> implements FuncList<A> { 	Empty() {} }  package-info.java:  @org.eclipse.jdt.annotation.NonNullByDefault package sol;  Test.java:  package sol;  public class Test { 	public static void main(final String[] args) { 		 System.out.println(new Node<>(""A"", new Empty<>())); 	} }  Error: ""The constructor Node<String>(String, Empty<A>) is undefined""  Giving explicit type arguments for Empty changes the error to this: ""Cannot infer type arguments for Node<>""  Giving explicit type arguments for Node or for both Node and Empty causes this warning to be correctly emitted: ""Redundant specification of type arguments <String>"" However, taking the suggested action of removing redundant type specifications causes one of the two above errors to be emitted.  Commenting out @NonNullByDefault in package-info.java causes the code to compile with no warnings or errors except for ""unused"" warnings and a warning about an unspecified default null annotation.  Uncommenting @NonNullByDefault does not cause errors to reappear until Test.java is recompiled."
Created attachment 247706 [details] Event details  Error occurred when editing/refactoring a class having saved it at the end of the previous day when it still had syntax errors/did not compile. Next morning the error occurred when saving (code still not ready to compile).  Clean up settings:  Add 'this' qualifier to unqualified field accesses Add 'this' qualifier to unqualified method accesses Convert control statement bodies to block Convert 'for' loops to enhanced 'for' loops Add final modifier to private fields Add final modifier to method parameters Add final modifier to local variables Remove unnecessary parentheses Remove unused imports Add missing '@Override' annotations Add missing '@Override' annotations to implementations of interface methods Add missing '@Deprecated' annotations Add missing serial version ID (default 1L) Remove unnecessary '$NON-NLS$' tags Add unimplemented methods Sort members excluding fields, enum constants, and initializers Organize imports Format source code Remove trailing white spaces on all lines Correct indentation
Similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=444803 we found slightly different variants using Lambdas/Inner Classes etc. where the ECJ generates invalid bytecode and causes following Exception during verifying:  Exception in thread "main" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     java8/ecjissues/AnotherEcjProblem$Sub.<init>(Ljava8/ecjissues/AnotherEcjProblem;)V @8: invokedynamic   Reason:     Type uninitializedThis (current frame, stack[2]) is not assignable to 'java8/ecjissues/AnotherEcjProblem$Sub'  See following code:  // ----------------------------------------------------------------------  import java.util.function.Consumer;  @SuppressWarnings("all") public class AnotherEcjProblem {    private final String text = "Bug?";    public static void main(String[] args) {     new AnotherEcjProblem().doIt();   }    private void doIt() {     new Sub();   }    private class Super<T> {      public Super(Consumer<T> consumer) {     }   }    private class Sub extends Super<String> {      public Sub() {       super(s -> System.out.println(text));       // super(s -> System.out.println("miep"));     }   }  }   // ----------------------------------------------------------------------  import java.util.HashMap; import java.util.Map; import java.util.function.Function;  public class EclipseCompilerAndLambdaCrash {    public static void main(String[] args) {     new EclipseCompilerAndLambdaCrash().run();   }    public void run() {     class Inner {       public Inner() {         System.out.println("miep");       }     }      Map<String, Inner> map = new HashMap<>();     Function<String, Inner> function = (name) -> {       Inner i = map.get(name);       if (i == null) {         i = new Inner();         map.put(name, i);       }       return i;      };     function.apply("test");   } }  // ----------------------------------------------------------------------  Tested with 4.4.1 and eclipse-SDK-N20141007-2000-win32-x86_64
Bug 437444 comment 28 introduced a TODO: "Stephan to validate".  Error messages would be changing from "potential null pointer access" / "null type mismatch" to "contradictory null annotations".  I'm trying to avoid inferring such contradictions, which makes it harder to understand for the user.  Hence, before enabling needUniqueCapture in PMB.capture() also in the case of isAnnotationBasedNullAnalysisEnabled, I'll give it a try to keep the current error message.
"+++ This bug was initially created as a clone of Bug #432614 +++  package test.one;  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class C1 { 	FI fi1= (@T2 int i) -> {}; }  interface FI { 	void foo(@T1 int i); }  @Ta"
1. Create the following class:   public class RemoveArgumentBug {     public static void main(String[] args) {         RemoveArgumentBug bug = new RemoveArgumentBug(                 1.0e-3  // some comment                 , null);     }      RemoveArgumentBug(double d) {     } }   2. The class contains a compiler error, a superfluous 'null' argument. The quick fix suggests to remove that, so let's do it. The resulting code is, however, invalid:   public class RemoveArgumentBug {     public static void main(String[] args) {         RemoveArgumentBug bug = new RemoveArgumentBug(                 1.0e-3  // some comment);     }      RemoveArgumentBug(double d) {     } }    Note that the closing parenthesis and the semicolon are not being added after the 1.0e-3 but at the end of the comment line, which is an error.
Hello committers,  we received a new error report for Eclipse 4.3.2.M20140221-1700.   General Information:     anonymous-id:         23ca87fb-325b-4150-8ad8-f1a99999d769     eclipse-build-id:     4.3.2.M20140221-1700     eclipse-product:      org.eclipse.epp.package.rcp.product     operating system:     Linux 3.15.0 (x86_64) - gtk     java-runtime-version: 1.8.0_20-b26  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.databinding.observable_1.4.1.v20130515-1857     2. org.eclipse.core.databinding_1.4.1.v20130515-1857     3. org.eclipse.core.runtime_3.9.100.v20131218-1515     4. org.eclipse.e4.ui.workbench_1.0.2.v20131202-1739     5. org.eclipse.e4.ui.workbench.swt_0.12.2.v20140117-1939     6. org.eclipse.equinox.app_1.3.100.v20130327-1442     7. org.eclipse.equinox.launcher_1.3.0.v20130327-1440     8. org.eclipse.jdt.ui_3.9.2.v20131106-1600     9. org.eclipse.jdt_3.9.1.v20140221-1700     10. org.eclipse.jface_3.9.1.v20130725-1141     11. org.eclipse.jface.text_3.8.101.v20130802-1147     12. org.eclipse.swt_3.102.1.v20140206-1334     13. org.eclipse.ui_3.105.0.v20130522-1122     14. org.eclipse.ui.ide.application_1.0.401.v20131105-1007     15. org.eclipse.ui.ide_3.9.2.v20131004-0923   Error Status:      code:                   0     plugin:                 org.eclipse.ui_3.105.0.v20130522-1122     message:                Unhandled event loop exception     fingerprint:            22ac62c5     exception class:        java.lang.ArrayIndexOutOfBoundsException     exception message:      1034     number of children:     0          java.lang.ArrayIndexOutOfBoundsException: 1034     at org.eclipse.jdt.internal.ui.dialogs.OptionalMessageDialog.buttonPressed(OptionalMessageDialog.java:116)     at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628)     at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)     at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)     at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392)     at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3742)     at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3363)     at org.eclipse.jface.window.Window.runEventLoop(Window.java:826)     at org.eclipse.jface.window.Window.open(Window.java:802)     at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.informUserAboutEmptyDefaultCategory(ContentAssistProcessor.java:602)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.getDefaultCategories(ContentAssistProcessor.java:504)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.getCategoryIteration(ContentAssistProcessor.java:492)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.setCategoryIteration(ContentAssistProcessor.java:487)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.access$3(ContentAssistProcessor.java:486)     at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor$CompletionListener.assistSessionStarted(ContentAssistProcessor.java:117)     at org.eclipse.jface.text.contentassist.ContentAssistant.fireSessionBeginEvent(ContentAssistant.java:2221)     at org.eclipse.jface.text.contentassist.ContentAssistant.prepareToShowCompletions(ContentAssistant.java:1696)     at org.eclipse.jface.text.contentassist.ContentAssistant.access$6(ContentAssistant.java:1687)     at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:376)     at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)     at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)     at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3717)     at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3366)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)     at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:140)     at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:611)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)     at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)     at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)     at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)     at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:483)     at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)     at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)     at org.eclipse.equinox.launcher.Main.run(Main.java:1450)     at org.eclipse.equinox.launcher.Main.main(Main.java:1426)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/5437b9a9e4b08c25446233ee for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"> java.lang.NullPointerException > 	at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.analyseCode(SingleNameReference.java:186) > 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123) > 	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.analyseCode(BinaryExpression.java:66) > 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCode(AllocationExpression.java:117) > 	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:487) > 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:173) > 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:88) > 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:48) > 	at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode(IfStatement.java:133) > 	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:48) > 	at org.eclipse.jdt.internal.compiler.ast.TryStatement.analyseCode(TryStatement.java:165) > 	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.analyseCode(ConstructorDeclaration.java:176) > 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:733) > 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261) > 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118) > 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) > 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) > 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) > 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) > 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) > 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) > 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) > 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) > 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) > 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161) > 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136) > 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273) > 	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273) > 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83) > 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) > 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367) > 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349) > 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372) > 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332) > 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)  eclipse.buildId=4.5.0.I20140918-0330 java.version=1.8.0_11 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product  I didn't see this under 4.4."
"eclipse.buildId=4.4.1.M20140925-0400 java.version=1.8.0_20 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=it_IT  org.eclipse.jdt.core Error Fri Oct 10 22:45:58 CEST 2014 Errors running builder 'Java Builder' on project 'ntools'.  java.lang.IllegalStateException 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:268) 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:298) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getArrayType(AnnotatableTypeSystem.java:87) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromSignature(LookupEnvironment.java:1323) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createFields(BinaryTypeBinding.java:547) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:473) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:696) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:679) 	at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:164) 	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.resolveSingleImport(CompilationUnitScope.java:735) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3310) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3042) 	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:51) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:472) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:571) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1287) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces(ClassScope.java:1038) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1096) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectMemberTypes(ClassScope.java:906) 	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1104) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:227) 	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:746) 	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:383) 	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:428) 	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367) 	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.compile(IncrementalImageBuilder.java:330) 	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304) 	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build(IncrementalImageBuilder.java:135) 	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:267) 	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:195) 	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246) 	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302) 	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358) 	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381) 	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143) 	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
Browse the following snipped in ASTView: enum A{B(){void c(){}}}  The EnumConstantDeclaration range does not include its closing brace. It works fine if there's a space added before the closing brace.
I have a mass of lambdas and internal classes that I'm working with. It's reached a point now where I get the following stack overflow.  This is with org.eclipse.jdt.core 3.10.0.v20140902-026  "main" #1 prio=6 os_prio=31 tid=0x0000000102807800 nid=0x707 runnable [0x00007fff5f87b000]    java.lang.Thread.State: RUNNABLE         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)         at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202)         at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) ....
"I use Eclipse 4.4.1 and JDK 1.8.0.5.  I have a class with lambda as a class member:  public class LambdaTest {  	Runnable foo = () -> {  	};  }  When I save this class, the following error occurs (in error log):   java.lang.IllegalArgumentException 	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2252) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1789) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3317) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3204) 	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:438) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:889) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:896) 	at org.eclipse.jdt.apt.core.internal.env.BaseProcessorEnv.createASTs(BaseProcessorEnv.java:857) 	at org.eclipse.jdt.apt.core.internal.env.ReconcileEnv.openPipeline(ReconcileEnv.java:108) 	at org.eclipse.jdt.apt.core.internal.env.AbstractCompilationEnv.newReconcileEnv(AbstractCompilationEnv.java:97) 	at org.eclipse.jdt.apt.core.internal.APTDispatchRunnable.reconcile(APTDispatchRunnable.java:219) 	at org.eclipse.jdt.apt.core.internal.APTDispatchRunnable.runAPTDuringReconcile(APTDispatchRunnable.java:167) 	at org.eclipse.jdt.apt.core.internal.AptCompilationParticipant.reconcile(AptCompilationParticipant.java:223) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation$1.run(ReconcileWorkingCopyOperation.java:258) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.notifyParticipants(ReconcileWorkingCopyOperation.java:245) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:95) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136) 	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) 	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)   As a result the project can not be complied properly. When I put 'foo' variable in any method, everything works as expected. Making 'foo' variable does not help."
"The class  @NonNullByDefault public class FullyQualifiedNullable { 	java.lang.@Nullable String text; }  gives a compile error on 'text': ""The @NonNull field text may not have been initialized""  Maybe I'm wrong, but I think this is the correct way to annotate a fully qualified type. When removing ""java.lang."", the compiler no longer gives the error."
Created attachment 247862 [details] test class that shows the regression  In 4.4.1, generic type information is lost for lambdas. The attached test class shows the problem. The output is:  Eclipse 4.4.1 ------------- Lambda binds to: Testbed.lambda$0 Methods (with generics): - java.util.List<java.lang.String> noop(java.util.List<java.lang.String>) - interface java.util.List lambda$0(interface java.util.List)  Eclipse 4.4.0 ------------- Lambda binds to: Testbed.lambda$0 Methods (with generics): - java.util.List<java.lang.String> noop(java.util.List<java.lang.String>) - java.util.List<java.lang.String> lambda$0(java.util.List<java.lang.String>)  jdk 1.8.0_11 ------------ Lambda binds to: Testbed.noop Methods (with generics): - java.util.List<java.lang.String> noop(java.util.List<java.lang.String>)
ICTB is used for two purposes in JDT/Core:  1. To support the special intersection cast introduced for lambda serialization 2. In type inference.  While this abstraction serves the purposes for (1) fairly adequately[*], it is not hooked up properly into various type compatibility APIs (isCompatibleWith isEquivalentTo, findSuperTypeOriginatingFrom etc) and as a result does not serve well the requirements of (2)  For 1.7 we use a modified wildcard binding that serves as an intersection type. Either we should move all uses of ICTB to that or factor out the intersection type part of wildcard into a separate abstraction and start using that.   [*] Even there we have problems: See https://bugs.eclipse.org/bugs/show_bug.cgi?id=424410
There are various design loose ends in poly expression support.      - We need a IPolyExpression type that documents the APIs.     - Disparate APIs need unification (Incovation.binding, RE.findCompile*, LE.getResolved* etc)     - We need to come up with a FunctionTypeBinding that would be the type returned by LE and RE resolve methods.       There are a few more loose ends documented in other bugs, I'll scan through them and collect them all here so this can be the umbrella bug for this effort.
"If you create two separate class files:  @NonNullByDefault public class One {  	public void test() { 		Set<String> set = Two.getSet(); 	} }  and  public class Two {  	@NonNullByDefault 	public static Set<String> getSet() { 		return new HashSet<>(); 	} }  The expression ""Two.getSet()"" gives the warning ""Null type safety (type annotations): The expression of type '@NonNull Set<String>' needs unchecked conversion to conform to 'Set<@NonNull String>'"".  This is incorrect, because of the @NonNullByDefault annotation on getSet(). If the annotation is moved to class level, the warning no longer appears."
"Master:  interface I { 	void bar(String t); } public class X<T> { 	X(String x) {} 	X(T x) {} 	X(T x, String ...strings) {} 	 	public void one(X<I> c){} 	 	public void two() { 		one(new X<>((String s) -> { })); 	} }    javac compiles this, while we reject it on master. Problem is that Scope.mSMB calls parameterCompatibilityLevel on only-applicability inferred methods with jlO substitutions. So we are checking for lambda compatibility against a target type of Object incorrectly.  We should consult the shallowOriginal also.  See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c121 - https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c127"
Once a lambda is cast (e.g. to add Serializable) then auto complete stops working inside the entire method, both before and after the cast and even including annotations, return types and arguments.  An example of such a cast: (Function<Integer, Integer> & Serializable) x -> 2 * x  If this cast is removed so only the lambda remains then auto complete immediately works again.
Mac OS X, org.eclipse.jdt.text.tests.performance.ScrollEditorTest must not press Ctrl+Arrow_Down/Up for Scroll Line Down/Up.  These shortcuts have been hijacked by Apple by default for system-wide "Mission Control" and "Application Windows" commands. The effects when running e.g. ScrollAnnotatedJavaEditorTest#testScrollJavaEditorLineWise1() is an endless flickering that is hard to cancel (hint: try Command+Q).  I guess we best remove the shortcuts for Scroll Line Down/Up on the Mac and change the tests to set custom shortcuts.
Version: Luna SR1 (4.4.1) Build id: M20140925-0400  and  Version: Mars (4.5) Build id: I20140918-0330   In the following example the method err1() compiles ok when using JDK Compilance 1.7 but issues an error when set to 1.8:  package e44.j8.err;  public class F {    public static interface I {/*empty*/}    public static class C     implements I {/*empty*/}    public static class W<T extends I>     implements I {      // --- problem is triggered only, when there is a vararg-parameter     public W(final T t, final Object... o) {       super();     }   }    // --- needed to trigger problem   public static final <T> T inspect(final T t) {     return t;   }    // --- this compiles ok when having JDK Compilance set to 1.7 !   public static final W<C> err1() {     final C c = new C();     final Object o = new Object();     return inspect(new W<>(c, o)); // - ERROR: Cannot infer type arguments for W<> F.java   }    public static final W<C> wrn1() {     final C c = new C();     final Object o = new Object();     // --- giving the type-parameter yields a warning     // --- comparing that to the error of method err1() it does not make much sense     return inspect(new W<C>(c, o)); // - WARNING: Redundant specification of type arguments <F.C> F.java   }    public static final W<C> ok1() {     final C c = new C();     // --- no extra vararg-paramaeter     return inspect(new W<>(c)); // - OK   }    public static final W<C> ok2() {     final C c = new C();     final Object o = new Object();     // --- no check-method     return new W<>(c, o); // - OK   }    public static final W<C> ok3() {     final C c = new C();     // --- no check-method     return new W<>(c); // - OK   }    public static final W<C> ok4() {     final C c = new C();     final Object o = new Object();     // --- this also compiles (my solution for now)     final W<C> w = new W<>(c, o);     return inspect(w);   } }
"package p2;  public class MainScreen { 	public MainScreen() {} 	/** 	 * m1 	 */ 	void m1() {} 	 		syso//this.m2(); 	} 	 	void m2() {} } ----------------------------------------  In the above example, press Ctrl+space after ""syso"" and press Enter. We get the following exception:  java.lang.IllegalStateException: Bad AST node structure: - parent [176, 177] org.eclipse.jdt.core.dom.Initializer    body [-1, -1] org.eclipse.jdt.core.dom.Block  ----------------------------------- SOURCE BEGIN ------------------------------------- package p2;  public class MainScreen { 	public MainScreen() {} 	/** 	 * m1 	 */ 	void m1() {} 	 		private void syso() { 			// TODO Auto-generated method stub  		}//this.m2(); 	} 	 	void m2() {} } ----------------------------------- SOURCE END -------------------------------------  	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1421)  	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)  	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)  	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)  	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.rewriteImports(ImportRewrite.java:1051)  	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposal.apply(JavaTypeCompletionProposal.java:116)  	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:497) ..."
In the example code below, ecj gives the invalid error "Local variable i defined in an enclosing scope must be final or effectively final." It's invalid because the variable i is not being closed over by the lambda, rather the value returned by get() is being closed over. Oddly, the fact that MyPredicate extends Serializable seems to matter. If I delete that, the compiler error goes away.  public class MyTest {      private static final List<Integer> INTEGERS = Arrays.asList(1, 2, 3, 4);      public static void main(String[] args)     {         for (int i = 0; i < INTEGERS.size(); i++)         {             MyPredicate<Integer> predicate = INTEGERS.get(i)::equals;         }     }      public interface MyPredicate<T> extends Serializable     {         boolean accept(T each);     } }
Follow-up from bug 445099:  Since we don't have effective code in TypeVariableBinding.boundCheck() that validates an inferred type against null constraints on a type parameter's bound, we should probably ensure that ThreeSets.setInstantiation() never produces such conflict - by inspecting the type bounds, too.
"Adding an irrelevant type parameter on the overloaded method breaks resolution of it, if the argument is expresses as lambda expression.  Changing lambda expression to the block solves the problem.  import java.util.concurrent.Callable;  public class ErrorExample {  	public void mismatchRunnableCallable() throws Exception {          		//Resolves to case1(Runnable) method invocation; lambda with block 		case1(() -> {""abc"".length();});          		//Resolves to case1(Callable) method invocation, resulting in type mismatch; block removed - lambda with expression         case1(() -> ""abc"".length()); 	} 	 	public void noSuchMismatch() throws Exception { 		 		//no difference to case1  		case2(() -> {""abc"".length();}); 		 		//the only difference to case 1 is the missing irrelevant <T> type parameter. Properly resolves to case2(Runnable) here 		case2(() -> ""abc"".length()); 	} 	 	public void case1(final Runnable r) {} 	public <T> void case1(Callable<Boolean> c) {} 	 	 	 	public void case2(final Runnable supplier) {} 	public void case2(Callable<Boolean> conditionEvaluator) {}  }"
This will be the umbrella bug to track tasks that fall under the bucket of finishing touches/follow ups from https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444  Let us not add patches here, they can go into unit level tickets linked to here.
https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444 introduces interned captures:  This still needs follow up in three areas:      - To make it more robust we should capture using both the capturing expression's source start and source end (along with CUD) not just the source end as some times source ends are seen to be identical for the containing and the contained expression (cast, assignment ...)      - TypeSystem.getCapturedWildcard may introduce performance problems as we just maintain a linear list of captures across all files input to compiler. These should be hashed somehow on a CUD basis.      - We need to see whether we need ATS.getCapturedWildcard and what it would look like.
After https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444, inner poly expressions are fully re-resolved against their eventual target type. This would trigger re-inference of the inner poly expression which is wasteful. The aggregate inference done on behalf of the outer most call should arrange to forward results so re-inference could be short-circuited.  (is(Boxing)CompatibleWith() should also cache/lookup the cache for bindings)
This is to cover two items:       - There are blocks of code that are duplicated around the several calls to inferElidedTypes. We need to see if we can factor out this better.      - AE should not recompute the binding via findConstructorBinding() in <> situation. It should use inferConstructorOfElidedParameterizedType() and be done with it.
From https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c48  CaptureBinding: Own version of substituteInferenceVariable() no longer handles superclass & superInterfaces (nor lowerBound, which we didn't handle before, either). Question: can we assert that the fresh CaptureBinding created here gets initializeBounds called when needed? Could we end up working with an insufficiently initialized CaptureBinding downstream? => @Srikanth, please comment.  This needs follow up.
"See GenericsRegressionTest_1_8.testBug424712a():  	// The extra error with <unknown> reads a bit weird. 	""----------\n"" +  ... 	""3. ERROR in X.java (at line 12)\n"" +  	""	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n"" +  	""	                            ^^^^^^^^^^^^^^^^^^^\n"" +  	""Type mismatch: cannot convert from Collection<Object> to <unknown>\n"" +  	""----------\n"" +"
Opening this bug to track the tasks outlined in https://bugs.eclipse.org/bugs/show_bug.cgi?id=430686#c16.  Commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=c454077fd72f14a026b898d3b50aaf59d2a0517c made on behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=430686 solves the problem there, but only short circuiting the route to some problem spots that are still unaddressed - they can be tackled here.
"Compiling this program on master, I see an error, while javac compiles this fine and prints ""Right!""  // --   interface I<T, U, V> { 	T goo(U u, V v); }  interface J { 	void foo(); } public class X { 	static String goo(String s, String s2) { 		return null; 	} 	static <T, U, V> T foo(T t, U u, J j) {        System.out.println(""Wrong!"");        return null;    } 	static <T, U, V> V foo(T t, U u, I<T, U, V> i) { 		System.out.println(""Right!""); 		return null; 	} 	public static void main(String[] args) { 		String s = goo(foo(""String"", ""String"", X::goo)); 	} 	static <T> T goo(T t) { 	    return t;	 	} }"
Until Eclipse 4.4 the generic signature of a Lambda Expression was stored within the class file, which made it possible to extract type information for creating type-safe programs. With the merge of the patch for Bug 436542 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=436542) this feature has been completely thrown away.  The following snippet shows an example where a generic signature is a very valuable feature:  ///// public class Test {     public static interface Map<IN, OUT> {         public OUT map(IN in);     }      public static class Tuple<T1, T2> {         private T1 field1;         private T2 field2;     }      public static void main(String[] strings) throws Exception {         Map<Tuple<String, Double>, Tuple<Integer, String>> map = (in) -> new Tuple<>();         SerializedLambda sl = getSerializedLambda(lambda);               Method m = getLambdaMethod(sl);          // Use the type information stored in signature         System.out.println(m.getGenericReturnType());         for (Type t : m.getGenericParameterTypes()) {             System.out.println(t);         }     } } ///// Another discussion on this topic can be found here:  http://stackoverflow.com/questions/21887358/reflection-type-inference-on-java-8-lambdas  It would be a great enhancement to bring the functionality back (by default or at least with help of a compiler option).
Hello committers,  we received a new error report for Eclipse 4.3.2.M20140221-1700.   General Information:     anonymous-id:         18be9654-9a91-4680-9666-9eb864bd11d4     eclipse-build-id:     4.3.2.M20140221-1700     eclipse-product:      org.eclipse.epp.package.jee.product     operating system:     Windows7 6.1.0 (x86) - win32     java-runtime-version: 1.7.0_51-b13  The following plug-ins were present on the execution stack (*):     1. org.eclipse.jdt.debug.ui_3.6.200.v20130514-0841     2. org.eclipse.jdt.debug_3.8.0.v20130514-0841     3. org.eclipse.jdt_3.9.1.v20140221-1700     4. org.eclipse.jdt.ui_3.9.2.v20131106-1600     5. org.eclipse.jface.text_3.8.101.v20130802-1147     6. org.eclipse.jface_3.9.1.v20130725-1141   Error Status:      code:                   0     plugin:                 org.eclipse.jface.text_3.8.101.v20130802-1147     message:                Unexpected runtime error while computing a text hover     fingerprint:            9b432cbe     exception class:        java.lang.NullPointerException     exception message:      -     number of children:     0          java.lang.NullPointerException: null     at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:362)     at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)     at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)     at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)     at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/- for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"The ""Convert to lambda expression"" quick assist should enter linked mode for the newly created parameters, so that the user can easily modify the names and references.  Example:  	<T, S> BiFunction<java.util.List<S>, S, Object> foo() { 		return List<S>::add; 	}"
"The ""Convert to lambda expression"" quick assist should avoid redundant 'this' or class names in the generate lambda.  In the example below, the first 3 method references can be converted into a lambda that doesn't refer to 'this' or 'Claxx'. If the method name is not ambiguous, we should use the short form.  import java.util.function.Consumer;  public class Claxx { 	void doInBackground() throws Exception { 		post(Claxx::execute); 		absorb(Claxx::executeGiven); 		post(this::executeObject); 		 		absorb(Claxx::executeObject); 		post(() -> execute()); 		post(() -> executeGiven(this)); // not convertible 		post(() -> executeObject()); 	} 	 	void post(Runnable r) { 		r.run(); 	} 	void absorb(Consumer<Claxx> c) throws Exception { 		c.accept(this); 	} 	 	static void execute() { 		System.out.println(""exec!""); 	} 	static void executeGiven(Object o) { 		System.out.println(""exec "" + o); 	} 	void executeObject() { 		System.out.println(""exec "" + this); 	} }"
"Steps:  1. create simple class with main method 2. add method entry bp to main 3. make noop change to file -> save 4. method bp is removed  Part of the fix for bug 216098 made a small change to the logic in getLineLocation, which is now returning a line location of 0 for LOCATION_METHOD, which ends up causing an exception in our marker updater, which ends up removing the breakpoint.  org.eclipse.jface.text.BadLocationException 	at org.eclipse.jface.text.ListLineTracker.getLineOffset(ListLineTracker.java:201) 	at org.eclipse.jface.text.AbstractLineTracker.getLineOffset(AbstractLineTracker.java:169) 	at org.eclipse.jface.text.AbstractDocument.getLineOffset(AbstractDocument.java:922) 	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setBreakpoint(JavaBreakpointConditionEditor.java:281) 	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setInput(JavaBreakpointConditionEditor.java:215) 	at org.eclipse.jdt.internal.debug.ui.breakpoints.CompositeBreakpointEditor.setInput(CompositeBreakpointEditor.java:137) 	at org.eclipse.jdt.internal.debug.ui.breakpoints.AbstractDetailPane.display(AbstractDetailPane.java:283) 	at org.eclipse.debug.internal.ui.views.variables.details.DetailPaneProxy.display(DetailPaneProxy.java:117) 	at org.eclipse.debug.internal.ui.views.variables.VariablesView.refreshDetailPaneContents(VariablesView.java:1218) 	at org.eclipse.debug.internal.ui.views.variables.VariablesView$2.runInUIThread(VariablesView.java:398) 	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:97) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3983) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:638) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:582) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)  To fix the regression we can simply change the getLineLocation method to:  if (fLocationType == LOCATION_NOT_FOUND || fLocationType == LOCATION_METHOD) {   return -1; } return fLineLocation;  or properly compute the line locations for LOCATION_METHOD (rather than leaving it at 0)"
"Created attachment 248272 [details] ant and eclipse builded class files  I using class files, with hibernate annotations, and after 4.3 to 4.4 upgrade i found this annoying bug.   The host os using java 7 (""1.7.0_60"") and inside eclipse i define different java runtime (windows - preferences - java - installed jre): jdk1.6.0_39  I configure default compilance settings to 1.6 and doesn't using any project specific setup.   The project contains all the required dependencies on the classpath, and build successfuly by and and eclipse internal compiler, but...  The example java file is:  @javax.persistence.SequenceGenerator( 		name=""AOK_AGENT_LOG_SEQ"", sequenceName=""HB_AOK_AGENT_LOG_SEQ"", allocationSize=100) package hu.ardinsys.det.dal.hibernate.aokagentlog.dao;   The eclipse builded class file is java 6 versioned class file, but doesn't contain any of AOK_AGENT_LOG_SEQ, HB_AOK_AGENT_LOG_SEQ etc., and my project doesnt work...   When i build the classes with ant javac compiler, the classes contains all the required notations..."
Created attachment 248297 [details] Test code  We've run into a similar issue as previously reported (and fixed) in #439889. This however is a sightly different case. The code works fine as long as it is compiled using javac (tested with 1.8.0_25). If it's compiled using eclipse's compiler (Version: Luna SR1 (4.4.1) Build id: M20140925-0400), deserialization fails.  As our application (using Apacke Wicket) heavily relies on serialization, this effectively prevents us from using lambdas in our project. It would be great if this could also be fixed in future 4.4.x releases.  The test code is attached.
Created attachment 248301 [details] Test code illustrating the problem  In addition to the lambda deserialization issues reported in bug 439889 and bug 449453 we've identified yet another issue, this time involving an anonymous class.  As in the other bugs, the code works fine as long as it is compiled using javac (tested with 1.8.0_25). If it's compiled using eclipse's compiler (Version: Luna SR1 (4.4.1) Build id: M20140925-0400), deserialization fails. Note that this even fails with Version: Mars (4.5) Build id: I20141029-2000.  Again, it would be great if this could also be fixed in future 4.4.x releases.  The test code is attached.
"Master:  // -- public class X { 	public class Y<T> { 	} 	static void foo(Y<String> ys) { 	} 	public static void main(String[] args) { 		foo(new X().new Y<>()); 	} }   fails to compile with:   The method foo(X.Y<String>) in the type X is not applicable for the arguments (X.Y<Object>)"
The following code fails to compile in Java 1.8.0_11 but succeeds in Eclipse 4.5M3 and 4.4.1; however, converting the method reference to a lambda (or uncommenting the line) results in a compile error for both:  public class Bug {   public static void main(String[] args) {     Concrete<Target> fl = new Concrete<Target>();     // fl.call(each -> each.doSomething()); // fails     fl.call(Target::doSomething); // succeeds in Eclipse 4.5M3 and 4.4.1     // but fails in Java 8 1.8.0_11   }   public static class Target {     public void doSomething() {     }   }   public static class Concrete<T> implements Left<T>, Right<T> {     public void call(RightHand<? super T> p) {     }   }   public interface Left<T> {     default void call(LeftHand<? super T> p) {     }   }   public interface LeftHand<T> {     public void left(T t);   }   public interface Right<T> {     public void call(RightHand<? super T> p);   }   public interface RightHand<T> {     public void right(T t);   } }
Hello committers,  we received a new error report for Eclipse 4.4.1.M20140925-0400.   General Information:     anonymous-id:         7431d31e-7058-4e40-89b0-644cd93252e5     eclipse-build-id:     4.4.1.M20140925-0400     eclipse-product:      org.eclipse.epp.package.jee.product     operating system:     Linux 3.2.0 (x86_64) - gtk     java-runtime-version: 1.8.0_25-b17  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.databinding.observable_1.4.1.v20140210-1835     2. org.eclipse.core.databinding_1.4.2.v20140729-1044     3. org.eclipse.core.runtime_3.10.0.v20140318-2214     4. org.eclipse.e4.ui.workbench_1.2.1.v20140901-1244     5. org.eclipse.e4.ui.workbench.swt_0.12.100.v20140530-1436     6. org.eclipse.equinox.app_1.3.200.v20130910-1609     7. org.eclipse.equinox.launcher_1.3.0.v20140415-2008     8. org.eclipse.jdt.ui_3.10.1.v20140817-1500     9. org.eclipse.jdt_3.10.0.v20140925-0400     10. org.eclipse.jface_3.10.1.v20140813-1009     11. org.eclipse.swt_3.103.1.v20140903-1938     12. org.eclipse.ui_3.106.0.v20140812-1751     13. org.eclipse.ui.ide.application_1.0.500.v20140514-2033     14. org.eclipse.ui.ide_3.10.1.v20140828-0944   Error Status:      code:                   4     plugin:                 org.eclipse.ui_3.106.0.v20140812-1751     message:                An internal error has occurred.     fingerprint:            aedd286c     exception class:        java.lang.NullPointerException     exception message:      -     number of children:     0          java.lang.NullPointerException: null     at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getPackageFragmentRoots(PackageExplorerContentProvider.java:365)     at org.eclipse.jdt.ui.StandardJavaElementContentProvider.getChildren(StandardJavaElementContentProvider.java:183)     at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getChildren(PackageExplorerContentProvider.java:307)     at org.eclipse.jface.viewers.AbstractTreeViewer.getRawChildren(AbstractTreeViewer.java:1372)     at org.eclipse.jface.viewers.TreeViewer.getRawChildren(TreeViewer.java:353)     at org.eclipse.jdt.internal.ui.viewsupport.ProblemTreeViewer.getFilteredChildren(ProblemTreeViewer.java:274)     at org.eclipse.jface.viewers.AbstractTreeViewer.getSortedChildren(AbstractTreeViewer.java:617)     at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2649)     at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1918)     at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)     at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1925)     at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)     at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1893)     at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1850)     at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart$PackageExplorerProblemTreeViewer.internalRefresh(PackageExplorerPart.java:258)     at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1836)     at org.eclipse.jface.viewers.StructuredViewer$7.run(StructuredViewer.java:1500)     at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1436)     at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366)     at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1397)     at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1497)     at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:521)     at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1456)     at HIDDEN.HIDDEN(HIDDEN:-1)     at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:97)     at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)     at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)     at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3774)     at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3412)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)     at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)     at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)     at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)     at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)     at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)     at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)     at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)     at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)     at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:483)     at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)     at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)     at org.eclipse.equinox.launcher.Main.run(Main.java:1465)     at org.eclipse.equinox.launcher.Main.main(Main.java:1438)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/- for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"GTT.test1210 is presently disabled for 1.8, when enabled I get:  // -- public class X {     public final <E extends Exception> E throwE (Object ... args) throws E {     	return null;     }     void foo(Object[] objs) {     	Object[] o  = throwE(objs);     } }  ""Unhandled exception type Object[]""  I would have expected a message:   cannot convert from Object[] & Exception to Object[]"
"Normally when I have an error because my code is calling a non-existant method, then CTRL+1 will show me a quickfix to create the method.  This is mighty useful :-)  Unfortunately when the method that needs to be created has a generic method signature than the quickfix is not suggested. This is fairly annoying if you have gotten used to having this quickfix available.  To reproduce here is a concrete example:  ---------------------------------------------------------------->8 package bork.it;  public class Bork<T> { 	 	Class<T> type; 	 	private Help help = new Help(); 	 	public void method() { 		help.help(this); 	}  }  class Help { 	 	<T> void help(T requestor) { 		return; 	} 	 } ---------------------------------------------------------------->8  Comment the method Help.help. Try to invoke quick fixes on the error that appears on the call to help.help. You will see the option to create the method is missing."
If the 'Introduce Parameter' dialog is opened for a method with a large number of parameters (~7 or more), the to-be-created parameter should be scrolled into view.
"The snippet below doesn't make sense at all. I ran into this while trying to edit code. The only thing I expect of the compiler is not to throw an exception.  The call at Scope.getExactConstructor(Scope.java:2285) is from bug 437444. I think a simple null check is all we need.   !ENTRY org.eclipse.jdt.core 4 4 2014-11-06 18:03:35.685 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package xy;  public class NpeInCompiler {     IntFunction<ArrayList<String>> noo() {         return System::new;     } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getExactConstructor(Scope.java:2285) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:438) 	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136) 	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) 	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
"This bug has perhaps existed forever:  // -- import java.util.List;  interface I { 	String foo(); }  interface J { 	List<String> foo(); } public class X {     static void goo(I i) {     	System.out.println(""goo(I)"");     }     static void goo(J j) {     	System.out.println(""goo(J)"");     }     static <T> List<T> loo() {     	return null;     }     public static void main(String[] args) { 		goo(()->loo()); 	} }  // --  This program fails to compile with ECJ, while compiling alright with 8u20.  Problem is a mistaken assumption on my part that we can reuse result  expressions having computed them against one particular target type.  (If you reverse the order of the goo methods, the code compiles fine)"
See https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c50 onwards.
"package meth.refs; import java.util.function.Consumer;  public class Claxx { 	void post(Runnable r) { 		r.run(); 	} 	void absorb(Consumer<Claxx> c) throws Exception { 		c.accept(this); 	} 	 	static void execute() { 		System.out.println(""exec!""); 	} 	static void executeGiven(Object o) { 		System.out.println(""exec "" + o); 	} 	void executeObject() { 		System.out.println(""exec "" + this); 	}	 }  class ClaxxTest { 	Claxx claxx = new Claxx(); 	 	void doInBackground() throws Exception { 		claxx.post(Claxx::execute); // Hover over ""post"" 		absorb(Claxx::executeGiven); 		post(this::executeObject); 		 		absorb(Claxx::executeObject); 		post(() -> execute()); 		post(() -> executeGiven(this)); // not convertible 		post(() -> executeObject()); 	} 	 }  ------------------------------------------------------  In the above example, hover over ""post"" at the specified location. We get the following exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:177) 	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:168) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:495) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:829) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:628) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:743) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:695) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144) ..."
"package meth.refs; import java.util.function.Consumer;  public class Claxx { 	void post(Runnable r) { 		r.run(); 	} 	void absorb(Consumer<Claxx> c) throws Exception { 		c.accept(this); 	} 	 	static void execute() { 		System.out.println(""exec!""); 	} 	static void executeGiven(Object o) { 		System.out.println(""exec "" + o); 	} 	void executeObject() { 		System.out.println(""exec "" + this); 	}	 }  class ClaxxTest { 	Claxx claxx = new Claxx(); 	 	void doInBackground() throws Exception { 		claxx.post(Claxx::execute); 		absorb(Claxx::executeGiven); // Press Ctrl+1 at the beginning of stmt 		post(this::executeObject); 		 		absorb(Claxx::executeObject); 		post(() -> execute()); 		post(() -> executeGiven(this)); // not convertible 		post(() -> executeObject()); 	} 	 }  -----------------------------------------------------------  In the above example, press Ctrl+1 to select the suggested quick fix at the location specified in comment. We get the following exception:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding 	at org.eclipse.jdt.core.dom.TypeBinding.getInterfaces(TypeBinding.java:509) 	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.collectRelaxingTypes(ASTResolving.java:1049) ..."
"This looks like a recent regression. To reproduce, add this code to an editor:  package repro; import java.io.IOException; import java.util.List; import java.util.function.Function;  public class UsedToWork<T, E extends Exception> { 	public static <T> List<T> of(T one) { return null; } 	public @SafeVarargs static <T> List<T> of(T... items) { return null; } 	public static void printDependencyLoops() throws IOException { 		Function<? super String, ? extends List<String>> mapping = UsedToWork::of; 	} }  The error is logged immediately in the Error Log view.  Tested with Eclipse SDK  Version: Mars (4.5) Build id: I20141104-0800  Here is the stack trace: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.getParameter(InferenceContext18.java:1377) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.isMoreSpecificThan(InferenceContext18.java:610) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.mostSpecificMethodBinding(Scope.java:4289) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1161) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1781) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2791) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:491) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.internalResolveTentatively(ReferenceExpression.java:738) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.findCompileTimeMethodTargeting(ReferenceExpression.java:710) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduceReferenceExpressionCompatibility(ConstraintExpressionFormula.java:230) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:186) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:840) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:387) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:216) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:80) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:730) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:687) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1619) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2791) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:880) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:701) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1022) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
Hello committers,  we received a new error report for Eclipse 4.4.1.M20140925-0400.   General Information:     anonymous-id:         f5797253-73aa-41ed-8998-5690655dd0a5     eclipse-build-id:     4.4.1.M20140925-0400     eclipse-product:      org.eclipse.epp.package.jee.product     operating system:     Windows8 6.2.0 (x86_64) - win32     java-runtime-version: 1.8.0_25-b18  The following plug-ins were present on the execution stack (*):     1. org.eclipse.jdt.core_3.10.0.v20140902-0626     2. org.eclipse.jdt_3.10.0.v20140925-0400     3. org.eclipse.jdt.ui_3.10.1.v20140817-1500     4. org.eclipse.jface.text_3.9.1.v20140827-1810     5. org.eclipse.jface_3.10.1.v20140813-1009   Error Status:      code:                   10.001     plugin:                 org.eclipse.jdt.ui_3.10.1.v20140817-1500     message:                Internal Error     fingerprint:            7a304c08     exception class:        org.eclipse.jdt.core.JavaModelException     exception message:      Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]]     number of children:     1          org.eclipse.jdt.core.JavaModelException: Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]]     at org.eclipse.jdt.internal.core.JavadocContents.getTypeDoc(JavadocContents.java:81)     at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:999)     at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:500)     at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:689)     at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:607)     at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:599)     at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)     at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)     at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)     at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)      ---           code:                   1.009       plugin:                 org.eclipse.jdt.core_3.10.0.v20140902-0626       message:                Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]]       fingerprint:            00000000       number of children:     0                      Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/- for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
(via bug 450684)  Looks like Oracle has permanently moved JRE Javadocs to https, so we should update the default URLs in org.eclipse.jdt.internal.launching.StandardVMType.  $ wget -S http://docs.oracle.com/javase/8/docs/api/ --2014-11-10 15:32:16--  http://docs.oracle.com/javase/8/docs/api/ Resolving docs.oracle.com (docs.oracle.com)... 104.66.181.23 Connecting to docs.oracle.com (docs.oracle.com)|104.66.181.23|:80... connected. HTTP request sent, awaiting response...   HTTP/1.1 301 Moved Permanently   Server: AkamaiGHost   Content-Length: 0   Location: https://docs.oracle.com/javase/8/docs/api/   Date: Mon, 10 Nov 2014 14:32:16 GMT   Connection: keep-alive Location: https://docs.oracle.com/javase/8/docs/api/ [following]
"I20141104-0800  Organize Imports wrongly adds an import for the qualifier of the SuperFieldAccess here:   package bug;  class S { 	public /*static*/ final int f = 0; }  class X { 	class C extends S { 		public void foo() { 			System.out.println(C.super.f); 		} 	} }   The added import is unused:  import bug.X.C;"
In https://docs.oracle.com/javase/8/docs/api/java/math/package-summary.html , the package description starts with:  <a name="package.description">  In Java SE 7 and earlier, it was:  <a name="package_description">  The effect is that package descriptions from attached Javadoc don't show up in Javadoc hovers.
http://download.eclipse.org/eclipse/downloads/drops4/N20141108-1500/testresults/html/org.eclipse.jdt.ui.tests_linux.gtk.x86_64_8.0.html  Test failures in  org.eclipse.jdt.ui.tests.packageHover.PackageJavadocTests.testGetPackageAttacheddoc(PackageJavadocTests.java:231) and org.eclipse.jdt.ui.tests.packageHover.PackageJavadocTests.testFailToAccessAttachedJavadoc(PackageJavadocTests.java:330)  Base reason is bug 450684.  I'll update the tests (and thereby found bug 450859).
N20141112-2000  Failed on all platforms  http://download.eclipse.org/eclipse/downloads/drops4/N20141112-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html  Error : java.lang.IllegalArgumentException: protocol = http host = null  java.lang.RuntimeException: java.lang.IllegalArgumentException: protocol = http host = null at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1242) at sun.net.www.protocol.http.HttpURLConnection.getHeaderField(HttpURLConnection.java:2714) at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:477) at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:848) at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1039) at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121) at org.eclipse.jdt.core.tests.model.AttachedJavadocTests.test025(AttachedJavadocTests.java:592) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: java.lang.IllegalArgumentException: protocol = http host = null at sun.net.spi.DefaultProxySelector.select(DefaultProxySelector.java:170) at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:926) at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:850) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1300) at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:468)
Hello committers,  we received a new error report for Eclipse 4.4.1.M20140925-0400.   General Information:     anonymous-id:         aab621e9-4026-41d7-956e-ea5aef723587     eclipse-build-id:     4.4.1.M20140925-0400     eclipse-product:      org.eclipse.epp.package.rcp.product     operating system:     Windows7 6.1.0 (x86) - win32     java-runtime-version: 1.7.0_72-b14  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.jobs_3.6.0.v20140424-0053     2. org.eclipse.core.runtime_3.10.0.v20140318-2214     3. org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926     4. org.eclipse.jdt.debug_3.8.101.v20140902-1548     5. org.eclipse.jdt_3.10.0.v20140925-0400     6. org.eclipse.jdt.ui_3.10.1.v20140817-1500   Error Status:      code:                   2     plugin:                 org.eclipse.jdt.ui_3.10.1.v20140817-1500     message:                Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".     fingerprint:            0d04955e     exception class:        java.util.regex.PatternSyntaxException     exception message:      Unclosed group near index 10 CEP\.free(           ^     number of children:     0          java.util.regex.PatternSyntaxException: Unclosed group near index 10 CEP\.free(           ^     at java.util.regex.Pattern.error(null:-1)     at java.util.regex.Pattern.accept(null:-1)     at java.util.regex.Pattern.group0(null:-1)     at java.util.regex.Pattern.sequence(null:-1)     at java.util.regex.Pattern.expr(null:-1)     at java.util.regex.Pattern.compile(null:-1)     at java.util.regex.Pattern.<init>(null:-1)     at java.util.regex.Pattern.compile(null:-1)     at org.eclipse.jdt.internal.debug.ui.search.LaunchConfigurationQueryParticipant.search(LaunchConfigurationQueryParticipant.java:127)     at org.eclipse.jdt.internal.ui.search.JavaSearchQuery$2.run(JavaSearchQuery.java:164)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:170)     at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)     at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)            Messages, stacktraces, and nested status objects may be shortened. Please visit  http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/- for the complete error log.   Some general information and guidelines about how to use this bug report:  1. Feel free to move this bug to your own product and components. Please note    that this bug is only accessible to Eclipse committers. If you move this bug    please make sure that it's still in the "Security Advisor" group.  2. The bug contents of the fields status, resolution, keywords, and whitelist    are presented to reporters. If you needs more information, please set the    keyword "needinfo". This will trigger a specialized dialog asking the user    to provide further details.  3. Use the following resolutions for the following situations:    * CLOSED / FIXED: This bug has been fixed. Please provide additional      information in the whiteboard field.    * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue      and request further information. Please use the whiteboard text to specify      more details what a user should provide and how.    * CLOSED / INVALID: Use this resolution if the reported problem is a      'user-configuration' problem. Please consider giving hints how to fix      these issues in the whiteboard field.    * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin      not developed at Eclipse.org    * CLOSED / MOVED: If this bug has been moved else where. Please provide more       information (e.g. a link) in the whiteboard field.  4. Please remember that only committers can view and comment on this bug. You    may, however, manually add the reporting user to the bug's cc list. But keep    in mind that the report may contains sensitive information.  5. If you are missing a feature, please file a enhancement request here:    https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces         Thank you for your assistance. Your friendly error-reports-inbox.   -- * Note: The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.
"This following source code causes lots of NPE's being thrown:  package any; class Repro {   public static <T> FieldSet<T> emptySet() { return null; }    /**    * {@link #emptySet}     */   public int i; }  Here's the full stack trace:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:195) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:80) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:730) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:687) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1619) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2478) 	at org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.internalResolveType(JavadocFieldReference.java:85) 	at org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.resolveType(JavadocFieldReference.java:128) 	at org.eclipse.jdt.internal.compiler.ast.Javadoc.resolveReference(Javadoc.java:386) 	at org.eclipse.jdt.internal.compiler.ast.Javadoc.resolve(Javadoc.java:281) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveJavadoc(AbstractMethodDeclaration.java:598) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:525) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136) 	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) 	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
"The following code, when run results in a java.lang.BootstrapMethodError.  public class MyTest {     public static void main(String[] args)     {     	MyTest test = new MyTest();     	MySupplier<MyTest> s = test::new;       }      public interface MySupplier<T>     {         T create();     } }  The above code is rejected by javac because the lhs of the constructor reference isn't a class."
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. We should add all JDT/Core plugins to this preference page to make it easier to debug it.  This is an umbrella bug, all the work will be done in dependent bugs on a one bug per one plugin basis.
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.apt.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.apt.pluggable.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. We should add all JDT/UI plugins to this preference page to make it easier to debug it.  This is an umbrella bug, all the work will be done in dependent bugs on a one bug per one plugin basis.
If a plugin provides .options file, it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.ui plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
"The following java file (all Types in a single file, just for convenience) compiles fine in eclipse 4.3.x (defaults set to JRE 6), but no longer compiles in 4.4.1-ish (JRE 6).  package test;  import java.util.Map.Entry;  public class Main { 	public static void main(String[] args) { 		EcoreEMap map = new EcoreEMap(); 		map.addUnique(new Object()); //Error here ONLY in 4.4 	} }  interface InternalEList<E> { 	public void addUnique(E object); }  class EcoreEMap<K, V> implements InternalEList<Entry<K, V>> { 	public void addUnique(Entry<K, V> object) { 	} }  The error is: The method addUnique(java.lang.Object) in the type InternalEList is not applicable for the arguments (java.lang.Object)  To me, the 4.3 behavior never made any sense to me. However, the error that occurs in 4.4 is not right.  It should say: The method addUnique(java.util.Map.Entry) in the type InternalEList is not applicable for the arguments (java.lang.Object)"
+++ This bug was initially created as a clone of Bug #452336 +++  I've studied the logs in bug 452336 and can summarize the issue below. It primarily comes down to several "prereq" ranges in jdt test bundles ... both Core, and UI ... being "too tight" to 
(Using JDT-core version 3.9.5, which is not listed)  Compiling the java code below using ECJ, results in two identical bootstrap methods in the class file. Constant pool entries are also duplicated. This results in duplicate objects and excessive symbol resolution by the run-time constant pool. The class files are also bloated.  Compiling the same java code with javac only produces one bootstrap method.  The attached tests (Test.zip) demonstrate the difference in compiler behaviour, using five method references to the same method.  ==JAVA CODE==   public class Test {     public static void main(String[] args) {       Runnable m = Test::m;       Runnable n = Test::m;     }     public static void m() {}   }   ==ECJ byte codes==   0: #35 invokestatic java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;     Method arguments:       #36 ()V       #39 invokestatic mhiCount/Test.m:()V       #40 ()V   1: #35 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;     Method arguments:       #41 ()V       #42 invokestatic mhiCount/Test.m:()V       #43 ()V  Duplicated constant pool entries:   - #36, #40, #41, #43   - #39, #42   ==JAVAC byte codes==   0: #20 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;     Method arguments:       #21 ()V       #22 invokestatic Test_javac.m:()V       #21 ()V
"Hi,  using Eclipse Mars M3 and jdk1.8.0_25, the following does not compile in Eclipse (but with jdk).  This may be the same reason as in Bug 451677.  // - - - - - - - - - - - - - - - - - - - - - - - - - - -  import java.util.function.Function;  interface Test<A> {  	<B> Test<B> create(B b);  	<B> Test<B> transform(Function<? extends A, Test<B>> f);  	default <B> Test<B> wrap(Function<? super A, ? extends B> f) { 		// THIS WORKS WITH ECJ: return transform(a -> create((B) f.apply(a))); 		return transform(a -> create(f.apply(a))); 	} } // - - - - - - - - - - - - - - - - - - - - - - - - - - -   Thanks,  Daniel"
+++ This bug was initially created as a clone of Bug #452457 +++  +++ This bug was initially created as a clone of Bug #452336 +++  I've studied the logs in bug 452336 and can summarize the issue below. It primarily comes down to several "prereq" ranges i
TestMap.java ------------ > import java.util.*; > import org.eclipse.jdt.annotation.*; >  > @NonNullByDefault > public abstract class TestMap extends AbstractMap<String,@Nullable String> { >  > }  Test.java ------------ > import java.util.*; > import org.eclipse.jdt.annotation.*; >  > @NonNullByDefault > public class Test { >  >   public static final void test(TestMap testMap) { >     testMap.putAll(new HashMap<String,@Nullable String>()); // Error: Contradictory null annotations: method was inferred as 'void putAll(Map<? extends @NonNull String,? extends @NonNull @Nullable String>)', but only one of '@NonNull' and '@Nullable' can be effective at any location >   } >  > }  eclipse.buildId=4.5.0.I20141029-2000  If I do a "Project->Clean..." the error disappears and won't show up until I modify and save Test.java.  Sorry if this is a dup, but all the others are marked verified fixed in earlier releases.
This is an initiative to improve the precision of null analysis within loops.  To recap the current strategy:  Given a loop of this abstract shape (ignoring any condition etc.):     preamble;    loop {        body {            statements1;            expression;            statements2;        }    }  We analyse: - preamble -> flowPreamble - (flowPreamble - null info) + body -> flowBody  When during analysis of body, expression appears to be in danger of raising NPE, we record the expression for deferred checking plus a checkType, e.g., MAY_NULL.  For any recorded expression, we perform deferred checking by: - combining flowBody and flowPreamble into a flowEntry, that approximates the status when entering the loop. - each recorded expression is now checked against flowEntry, where the checkType determines the exact strategy for checking.   This approach has several shortcomings:  (A) We drop information when we first visit expression: while we have detailed information in FlowInfo as a combination of (unknown,null,nonnull) we only record the fact *that* expression appeared as dangerous. Even a (pot.un,pot.nn) status may lead to reporting a warning (provided the flowEntry gives more hints for danger). In particular, during deferred analysis, we cannot recognize if a null/nonnull state was established only in statements2, where it cannot directly affect expression.  (B) Our FlowInfo currently cannot correctly encode all information for flowBody without knowing flowEntry. To encode this we would need capability for capturing correlation between incoming values and resulting values. By this I mean conditional information per variable, like: - if v1 is null at entry -> result v1 is (some bit combination) - if v1 is nonnull at entry -> result v1 is (other bit combination) This is not a problem in loop-less methods, because those are analysed in a strict top-to-bottom sequence. But when analysing body independent of the preamble, we need ways to combining this information post-hoc.   Bugs that are affected by these shortcomings are marked [loop] in their title.
This is a follow up of bug 451902 comment 1: it would be good to adjust the behavior of debug flags so that disabling the general flag org.eclipse.jdt.apt.core/debug disables all debug flags like it is done in other bundles.
"package test;  @FunctionalInterface interface FunctionalInterface1 {     void methodWithoutDefault(); }  @FunctionalInterface interface FunctionalInterface2 extends FunctionalInterface1{}  @FunctionalInterface interface FunctionalInterface3 extends FunctionalInterface1{}  @FunctionalInterface interface FunctionalInterface4 extends FunctionalInterface2, FunctionalInterface3{}  @FunctionalInterface interface RunnableFunctionalInterface extends Runnable, FunctionalInterface4{ 	default void methodWithoutDefault(){ 		// implements methodWithoutDefault 	} }  ------------------------------------------------------  The above interface hierarchy results in the error     ""Invalid '@FunctionalInterface' annotation; RunnableFunctionalInterface is not a functional interface"" although RunnableFunctionalInterface only has the single abstract method ""run"" inherited from Runnable. The error seems to be caused by FunctionalInterface4 extending both FunctionalInterface2 and FunctionalInterface3, which in turn both extend FunctionalInterface1, which declares the single abstract method ""methodWithoutDefault""."
In Eclipse 4.5.0M3, the following code  ---------------------- import static java.util.stream.Collectors.*; ... ...         Map<String, Set<String>> countryLanguagesMap = Stream.of(Locale.getAvailableLocales())                 .collect(                         groupingBy(Locale::getDisplayCountry,                            mapping(Locale::getDisplayLanguage,                                 toSet())                         )                 ); ---------------------- Gives errors    "The type Locale does not define getDisplayCountry(Object) that is applicable here" and "The type Locale does not define getDisplayLanguage(Object) that is applicable here"  It compiles and runs fine in maven.
The following error was reported via the automated error reporting:  The user provided the following details for this error report:        code:                   2     plugin:                 org.eclipse.core.resources_3.9.1.v20140825-1431     message:                Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".     fingerprint:            b7f6ab8c     exception class:        java.lang.NullPointerException     exception message:      -     number of children:     0          java.lang.NullPointerException: null     at org.eclipse.jdt.internal.compiler.ReadManager.getContents(ReadManager.java:118)     at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:14048)     at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:14020)     at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:12197)     at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:779)     at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:441)     at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:489)     at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:405)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:179)     at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:342)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder._OT$compile$orig(BatchImageBuilder.java:-1)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder._OT$compile$chain(BatchImageBuilder.java:-1)     at org.eclipse.objectteams.otdt.internal.compiler.adaptor.CheckUniqueCallinCapture$__OT__Batch._OT$compile$base(CheckUniqueCallinCapture.java:-1)     at org.eclipse.objectteams.otdt.internal.compiler.adaptor.CheckUniqueCallinCapture$__OT__Batch.compile(CheckUniqueCallinCapture.java:83)     at org.eclipse.objectteams.otdt.internal.compiler.adaptor.CheckUniqueCallinCapture._OT$Batch$compile$compile(CheckUniqueCallinCapture.java:74)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder._OT$compile$chain(BatchImageBuilder.java:-1)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:-1)     at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:61)     at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:264)     at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)     at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)     at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)     at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)     at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)     at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)     at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)     at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)     at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)     at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)     at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)       General Information:      reported-by:           anonymous-id:     faefc04a-a48e-4dc3-b727-57eba94cb119     eclipse-build-id: 4.4.1.M20140925-0400     eclipse-product:  org.eclipse.epp.package.standard.product     operating system: MacOSX 10.10.1 (x86_64) - cocoa     jre-version:      1.7.0_67-b01  The following plug-ins were present on the execution stack (*):     1. org.eclipse.core.jobs_3.6.0.v20140424-0053     2. org.eclipse.core.runtime_3.10.0.v20140318-2214     3. org.eclipse.jdt_3.10.0.v20140925-0400     4. org.eclipse.jdt.core_3.10.0.v_OTDT_r231_201409160728     5. org.eclipse.objectteams.otdt.compiler.adaptor_2.3.0.201406101339     6. org.eclipse.objectteams.otdt_2.3.1.201409160728  Please note that: * Messages, stacktraces, and nested status objects may be shortened. * Bug fields like status, resolution, and whiteboard are sent   back to reporters. * The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.    Please visit http://goo.gl/MWFSff for further details.    Thank you for your assistance. Your friendly error-reports-inbox.
Many debug features rely on finding the Java source element for the current debug element.  These include:  - Change Variable - Logical Structure - Content Assist in Display View - Evaluate Expression  and probably some more I'm missing.  Currently all these eventually call JavaDebugUtils#getSourceName(Object). This uses the default stratum of the current StackFrame. But the callers listed above always need Java, no matter what other Strata are available.   As a result, all these features are broken in Xtend and other Xbase languages, which add additional Strata.  Instead, this function should really be getSourceName(Object o, String stratum) and be called with the "Java" argument by all clients that need Java source elements.
"I20141202-0800 and master; was OK in I20141125-0800  There's a new bug in null analysis that leads to a wrong ""dead code"" problem.  I get two wrong errors in my workspace:  - Dead code	LocalCorrectionsSubProcessor.java	/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/text/correction	line 196 - Dead code	UpdateManagerUtils.java	/org.eclipse.update.core/src/org/eclipse/update/internal/core	line 149   Example to reproduce:  package xy;  public class Try {     public static void main(String[] args) {         foo(new Node());     }     static void foo(Node n) {         Node selectedNode= n;         if (selectedNode == null) {             return;         }         while (selectedNode != null && !(selectedNode instanceof Cloneable)) {             selectedNode= selectedNode.getParent();         }         if (selectedNode == null) { //wrong problem: Null comparison always yields false: The variable selectedNode cannot be null at this location             // wrong problem: dead code             System.out.println(selectedNode.hashCode());         }     } }  class Node {     Node getParent() {         return null;     } }"
Created attachment 249180 [details] A zip of the project  Hello.  I decided to try out the new Java 8 features with a simple project, but found that Eclipse raised internal compiler errors for code that doesn't actually use any Java 8 features. Unfortunately, I've not been able to isolate the problem to a simpler example, but the current project as it stands is only a few hundred lines (of mostly comments!), so that may be isolated enough.  The error occurs in the file VThumbnailTask.java. The file currently has an error, because the compute() method doesn't return a value, but even if this error is fixed, the problem persists. Essentially, the IDE says:  Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1357)  ... and refuses to build any further.  The same project compiled as 1.7 builds without issue.  To reproduce: Import the project into Eclipse as a Maven project (this probably requires the m2e plugin). The IDE will raise an error immediately as it tries to build the project.  Versions:  Linux viper 3.17.4-1-ARCH #1 SMP PREEMPT Fri Nov 21 21:14:42 CET 2014 x86_64 GNU/Linux.  openjdk version "1.8.0_25" OpenJDK Runtime Environment (build 1.8.0_25-b18) OpenJDK 64-Bit Server VM (build 25.25-b02, mixed mode)  Version: Luna Service Release 1 (4.4.1) Build id: 20140925-1800  The actual eclipse package is just the one taken from eclipse.org.
"package bugzilla;  public class TestSearch {  	private class X { 		private class P { 			 		} 		private void t1(P p) { 			t2(p); 		} 		protected void t2(P p) { 			 		} 	} }  ---------------------------------  Press Ctrl+Shift+G at method declaration of #t2 to search for its references. 0 references are found, though it is being invoked in #t1.  It used to work in Eclipse 3.8.1."
"package bug;  import java.util.function.UnaryOperator;  public class Test02 { 	private static class Multiplier { 		private final long mMul;  		public Multiplier(long iMul) { 			this.mMul = iMul; 		}  		public <T, V> Long mul(Long iItem) { 			return iItem * mMul; 		} 	}  	private static void test(UnaryOperator<Long> iFn) { 	}  	public static <T, V> void main(String[] args) { 		UnaryOperator<Long> mul = (new Multiplier(3))::<T, V> mul; 		Test02.test((new Multiplier(3))::<T, V> mul); 	} }  -------------------------------------------  In the Search dialog's ""Java Search"" tab, enter search string ""mul"" and search for method references in the above file.  We get the following exception:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:129) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:740) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:983) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4736) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4703) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:755) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:689) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1621) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1522) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2797) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:885) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:703) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1024) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:638) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:548) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1843) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1259) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1300) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1432) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
Version: Luna (4.4) Build id: I20140606-1215  Some changes have been made in JDK9 b41 (see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8049367) and there are numerous new failures in: org.eclipse.jdt.core.tests.builder package (253 tests) org.eclipse.jdt.core.tests.compiler package (563 tests) org.eclipse.jdt.core.tests.model (145 tests)  [java] ----------      [java] 1. ERROR in p\X.java (at line 1)      [java]     package p;      [java]     ^      [java] The type java.lang.Object cannot be resolved. It is indirectly refer enced from required .class files      [java] ----------      [java] 2. ERROR in p\X.java (at line 2)      [java]     public class X {      [java]                  ^      [java] Implicit super constructor Object() is undefined for default constru ctor. Must define an explicit constructor  Use the following to reproduce: 1. eclipse-Automated-Tests-4.4 from http://download.eclipse.org/eclipse/downloads/drops4/R-4.4-201406061215/ 2. jdk9 from http://jdk9.java.net/download (b41)
"The problem appears when accessing classes from another project that use Raw Types in a Generics context with the new java8 ""TYPE_USE"" null annotations.  A) CODE THAT TRIGGERS THE PROBLEM (I will also attach this junit test) - Setup a workspace with Java8 and the new null annotation. - Create project A with the following classes:  // GenericType.java: package projA;  public class GenericType<T> { }  // ClassWithRawUsage.java package projA;  @org.eclipse.jdt.annotation.NonNullByDefault public class ClassWithRawUsage { 	public java.util.List<GenericType> method() { 		throw new RuntimeException(); 	} }  - Create project B with the following class: package projB;  import projA.ClassWithRawUsage; import projA.GenericType;  public class ClassThatImports { }  B) THE PROBLEM: java.lang.IllegalStateException         at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getRawType(AnnotatableTypeSystem.java:139)         at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getRawType(AnnotatableTypeSystem.java:167)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createRawType(LookupEnvironment.java:997)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.convertUnresolvedBinaryToRawType(LookupEnvironment.java:627)         at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.swapUnresolved(ParameterizedTypeBinding.java:1273)         at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.swapUnresolved(UnresolvedReferenceBinding.java:141)         at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.setResolvedType(UnresolvedReferenceBinding.java:129)         at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.addType(PackageBinding.java:74)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:698)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:683)         at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299)         at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:144)         at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:99)         at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:183)         at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:186)         at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:463)         at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:517)         at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:394)         at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:442)         at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:763)         at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)         at java.lang.Thread.run(Thread.java:745)  C) DETAILS AND ANALYSIS: The genericType Parameter references a BinaryTypeBinding for ""@NonNull GenericType"". enclosingType is null and annotations is an empty array.  The BinaryTypeBinding got its null annotation for resolving ""@NonNull GenericType(unresolved)"" in   ""UnresolvedReferenceBinding.swapUnresolved(UnresolvedReferenceBinding, ReferenceBinding, LookupEnvironment) line: 141"" and it got passed to the wrapper ""List<@NonNull GenericType>"" in ""ParameterizedTypeBinding.swapUnresolved(UnresolvedReferenceBinding, ReferenceBinding, LookupEnvironment) line: 1273	"" which invokes convertUnresolvedBinaryToRawType etc. which eventually triggers the exception.  PROPOSED FIX:  As far as I understood the code, I think the check that throws to the IllegalStateException can simply be removed as the usages which lead to the invocation of the getRawType-method should be wrappers which should have their own null-annotation information available and the getRawType method will create a copy of the genericType instance with null-annotation cleared.  (It would have been helpful, if the error message of the  IllegateStateExceptions like these already included some information about the involved types because it is really hard to work around the bugs without this information)"
See bug 436486 for context. At times having APT enabled affects the compiler behavior as seen in the given bug.  This bug is to investigate the options to run the compiler tests with APT enabled ,possibly with dummy annotations processors.
The following error was reported via the automated error reporting:  The user provided the following details for this error report:        code:                   2     plugin:                 org.eclipse.core.resources_3.9.100.v20141128-1217     message:                Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".     fingerprint:            5b9eb6b7     exception class:        java.lang.NullPointerException     exception message:      -     number of children:     0          java.lang.NullPointerException: null     at org.eclipse.jdt.internal.compiler.flow.LoopingFlowContext.recordNullReference(LoopingFlowContext.java:565)     at org.eclipse.jdt.internal.compiler.flow.LoopingFlowContext.internalRecordNullityMismatch(LoopingFlowContext.java:759)     at org.eclipse.jdt.internal.compiler.flow.FlowContext.recordNullityMismatch(FlowContext.java:1007)     at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.checkAssignment(NullAnnotationMatching.java:112)     at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:115)     at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)     at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:126)     at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)     at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode(IfStatement.java:105)     at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:126)     at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)     at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)     at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)     at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:776)     at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)     at java.lang.Thread.run(Thread.java:745)       General Information:      reported-by:       OCLstdlibTables.Types._Ed Willink     anonymous-id:     4480ddfc-64ed-45bb-a550-d1669a82122a     eclipse-build-id: 4.5.0.I20141210-2000     eclipse-product:  org.eclipse.sdk.ide     operating system: Windows8 6.3.0 (x86_64) - win32     jre-version:      1.7.0_72-b14  The following plug-ins were present on the execution stack (*):     1. org.eclipse.jdt_3.11.0.v20141210-2000  Please note that: * Messages, stacktraces, and nested status objects may be shortened. * Bug fields like status, resolution, and whiteboard are sent   back to reporters. * The list of present bundles and their respective versions was   calculated by package naming heuristics. This may or may not reflect reality.    Please visit http://goo.gl/MWFSff for further details.    Thank you for your assistance. Your friendly error-reports-inbox.
"The following class produces a compiler error:  public class Problem { 	public void fubar(final @Nullable String arg) { 		if (arg == null) { 			return; 		} 		 		doSomething(arg); 		// no errors here 		 		while (true) {	 			doSomething(arg); 			//          ^^^  compiler error 		} 	} 	 	private void doSomething(@NonNull String arg) {	} }  The error is ""Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'"".  It seems that because the invocation of doSomething occurs within a loop (any kind of loop gives this result), the compiler no longer knows that the argument was already inferred as nonnull."
"The following program doesn't compile with Eclipse but compiles fine with javac:  --------------------------------------------------------- package test;  import java.util.function.BiFunction; import java.util.function.Function; import java.util.function.Predicate; import java.util.stream.Stream;  public class Test {      static <T> Tuple2<Seq<T>, Seq<T>> splitAtDoesntCompile(Stream<T> stream, long position) {         return seq(stream)             .zipWithIndex()             .partition(t -> t.v2 < position)             .map((v1, v2) -> tuple(                 v1.map(t -> t.v1),                 v2.map(t -> t.v1)             ));     }      static <T> Tuple2<Seq<T>, Seq<T>> splitAtCompiles(Stream<T> stream, long position) {         return seq(stream)             .zipWithIndex()             .partition(t -> t.v2 < position)             .map((v1, v2) -> Test.<Seq<T>, Seq<T>>tuple(                 v1.map(t -> t.v1),                 v2.map(t -> t.v1)             ));     }      static <T> Seq<T> seq(Stream<T> stream) {     	return null;     }      static <T1, T2> Tuple2<T1, T2> tuple(T1 v1, T2 v2) {     	return null;     } }  interface I<T> { 	T get(); 	<U> I<U> map(Function<T, U> f); }  interface Seq<T> { 	Seq<Tuple2<T, Long>> zipWithIndex(); 	Tuple2<Seq<T>, Seq<T>> partition(Predicate<? super T> predicate); 	<R> Seq<R> map(Function<? super T, ? extends R> mapper); }  class Tuple2<T1, T2> { 	T1 v1; 	T2 v2; 	 	<R> R map(BiFunction<T1, T2, R> function) { 		return null; 	} } ---------------------------------------------------------  The problematic call is the call to Test.tuple() from within the lambda. The Eclipse compiler doesn't seem to be able to correctly infer the generic types Test.<Seq<T>, Seq<T>>tuple()."
"With annotation-based null analysis enabled and using default annotations for null specification in compiler settings, the following class fails to compile with ""Cannot infer type arguments for Nullsafe<>"" error:  class Nullsafe<T> { 	final @Nullable T t;  	Nullsafe(@Nullable T t) { 		this.t = t; 	} 	public static <U> Nullsafe<U> of(@Nullable U u) { 		return new Nullsafe<>(u); // compile error 		// return new Nullsafe<U>(u); // workaround 	} }  Removing the @Nullable from the t argument in the constructor can also be used as a workaround, but this results in a nullness warning."
"The following code compiles (and runs tests as expected) in Eclipse:      import java.util.EnumSet; 	public class EnumTest { 	 		static enum Cloneables implements Cloneable { 			One, Two, Three; 		} 	 		public <T extends Cloneable> T getOne(Class enumType) { 			EnumSet<? extends T> set = EnumSet.allOf(enumType); 			return set.iterator().next(); 		} 	}  However, compiling with either `javac` (JDK 7) directly or via Maven fails with the following error:      type argument ? extends T is not within bounds of type-variable E  To be honest, the complexity of enums + interfaces + type-parameters (generics) all at play at once threw me off as I was writing the code, but I thought I had finally gotten it right. I'm not sure if this *should* work or not, if the discrepancy is a bug in Eclipse or javac.  The goal is to write calling code like this:      Cloneable something = enumTest.getOne(Cloneables.class);  For example, in Eclipse the following test compiles and passes:      @Test     public void testGetFirst() { 	    assertSame(Cloneables.One, getOne(Cloneables.class));     }"
This example from http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8044737   //---  public class Test  {      interface Constructor {         MyTest execute();     }      class MyTest {         MyTest() { System.out.println("Constructor executed"); }     }      public Constructor getConstructor() {         return getConstructor(() -> { return MyTest::new; });     }      public static void main(String argv[]) {         Test t = new Test();         MyTest mytest = t.getConstructor().execute();     }      Constructor getConstructor(Wrapper arg) {         return arg.unwrap();     }      interface Wrapper {         Constructor unwrap();     } } //---  compiles fine using ecj head, but at runtime the program throws:  Exception in thread "main" java.lang.VerifyError: Bad local variable type Exception Details:   Location:     Test.lambda$0()LTest$Constructor; @0: aload_0   Reason:     Type top (current frame, locals[0]) is not assignable to reference type   Current Frame:     bci: @0     flags: { }     locals: { }     stack: { }   Bytecode:     0x0000000: 2aba 0026 0000 b0                                at java.lang.Class.getDeclaredMethods0(Native Method)         at java.lang.Class.privateGetDeclaredMethods(Class.java:2693)         at java.lang.Class.privateGetMethodRecursive(Class.java:3040)         at java.lang.Class.getMethod0(Class.java:3010)         at java.lang.Class.getMethod(Class.java:1776)         at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)         at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)  The compiled method lambda$0 looks like this:    private static Test$Constructor lambda$0();     flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC     Code:       stack=1, locals=1, args_size=0          0: aload_0                 1: invokedynamic #38,  0             // InvokeDynamic #1:execute:(LTest;)LTest$Constructor;          6: areturn              LineNumberTable:         line 12: 0   aload_0 in a static argumentless methods doesn't look right ...
When trying to null-annotate class Optional, I came up with this variant:  //--- class Optional<@NonNull T> {   @Nullable T value;   private Optional(T value) { this.value = value; }   public static <@NonNull T> Optional<T> of(T value) { return new Optional<T>(value); }   public T get() {      @Nullable T t = this.value;     if (t != null) return t;      else throw new NoSuchElementException("No value present"); }   }   public @Nullable T orElse(@Nullable T other) { return (this.value != null) ? this.value : other; } } //---  Here we complain:  ---------- 1. WARNING in /tmp/Optional.java (at line 10)         if (t != null) return t;              ^ Redundant null check: The variable t cannot be null at this location ---------- 2. WARNING in /tmp/Optional.java (at line 11)         else throw new NoSuchElementException("No value present"); }              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Dead code ---------- 3. WARNING in /tmp/Optional.java (at line 12)         public @Nullable T orElse(@Nullable T other) { return (this.value != null) ? this.value : other; }                                                                     ^^^^^ Redundant null check: The field value is specified as @NonNull ----------  This indicates that the compiler fails to override the previous nullness when saying "@Nullable T". Note that a variant declaring "<T extends @NonNull Object>" instead of "<@NonNull T>" works as desired.   Additionally, when I change "Optional<@NonNull T>" to "<Optional<@Nullable T>" and add this test program:  //--- @NonNullByDefault @SuppressWarnings("unused") class OTest {   public static void good() {     Optional<String> os1 = Optional.of("yes");     @NonNull String s = os1.get();     @Nullable String ns = os1.orElse(null);   }   public static void bad() {     Optional<String> os = Optional.of(null);     @NonNull String s = os.orElse(null);   } } //---  I get:  java.lang.NullPointerException         at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.providedNullTagBits(NullAnnotationMatching.java:320)         at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:204)         at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:129)         at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.checkAssignment(NullAnnotationMatching.java:103)         at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:105)         at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:126)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)         at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)         at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:794)         at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:139)
"While merging tests from the feature branch for Bug 440477 with master, I'm observing a slight regression in how null hints are used during inference (its ExternalAnnotations18Test.testLibs1()).  //--- import java.util.Collection; import java.util.Iterator; import org.eclipse.jdt.annotation.*;  public interface Lib1 { 	<T> Iterator<T> unconstrainedTypeArguments1(Collection<@Nullable T> in); } //--- import org.eclipse.jdt.annotation.*;  import java.util.Collection; import java.util.Iterator;  public class Test1 { 	Iterator<@NonNull String> test1(Lib1 lib, Collection<@Nullable String> coll) { 		return lib.unconstrainedTypeArguments1(coll); 	} } //---  In HEAD, the call to unconstrainedTypeArguments1() is inferred as returning @Iterator<@Nullable String>, ignoring the @NonNull annotation in the target type."
"Created attachment 249682 [details] showcase for the internal error  A regression in the 1.8 compiler causes an internal error when combining varargs and type-inference. With the compiler level set to 1.7, the code compiles fine.  The attached project triggers the following internal error: java.lang.IllegalStateException: Unexpected RHS PolyTypeBinding for: new QueryAtom<>(PGroepAccount_.account) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(ConstraintTypeFormula.java:315) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:94) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:749) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:760) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduceAndIncorporate(InferenceContext18.java:913) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.inferPolyInvocationType(ConstraintExpressionFormula.java:412) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:390) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:525) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5150) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:5068) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:581) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:497) 	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.binding(AllocationExpression.java:706) 	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:80) 	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:749) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:867) 	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:843) 	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:117) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:739) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:695) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1761) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1662) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2621) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:866) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136) 	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367) 	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372) 	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
"In error messages when printing a type variable that is constrained by a null-annotated bound, the null annotation may bogusly be repeated before the type variable itself.  Witness: ExternalAnnotations18Test.testLibsWithTypeParameters() in the feature branch for external null annotations (to be pushed soon).  Current draft fix looks like this (but causes regressions):  //--- protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options) { 	if (options.isAnnotationBasedNullAnalysisEnabled) { 		// restore applied null annotation from tagBits: 		if ((this.tagBits & TagBits.AnnotationNonNull) != 0) { 	    	if (!appendAnnotationName(nameBuffer, this.typeAnnotations, TypeIds.T_ConfiguredAnnotationNonNull)) { 	    		TypeBinding prototype = this.unannotated(); 	    		if (prototype != null) 	    			appendAnnotationName(nameBuffer, prototype.typeAnnotations, TypeIds.T_ConfiguredAnnotationNonNull); 	    	} 	    } 	    if ((this.tagBits & TagBits.AnnotationNullable) != 0) { 	    	if (!appendAnnotationName(nameBuffer, this.typeAnnotations, TypeIds.T_ConfiguredAnnotationNullable)) { 	    		TypeBinding prototype = this.unannotated(); 	    		if (prototype != null) 	    			appendAnnotationName(nameBuffer, prototype.typeAnnotations, TypeIds.T_ConfiguredAnnotationNullable); 	    	} 	    } 	} }  private boolean appendAnnotationName(StringBuffer buffer, AnnotationBinding[] annotations, int typeId) { 	for (AnnotationBinding annot : annotations) { 		if (annot.type == null || annot.type.id != TypeIds.T_ConfiguredAnnotationNonNull) continue; 		buffer.append('@').append(annot.type.sourceName()).append(' '); 		return true; 	} 	return false; } //---"
> import java.util.*; > import java.util.function.*; > import org.eclipse.jdt.annotation.*; >  > @NonNullByDefault > public class Test { >  >   public static final <T,R> @NonNull R applyRequired(final T input, final Function<? super T,? extends R> function) { // Warning on '@NonNull R': "The nullness annotation is redundant with a default that applies to this location" >     return Objects.requireNonNull(function.apply(input)); >   } >  > }  eclipse.buildId=4.5.0.N20141222-2000 java.version=1.8.0_25  Filing at request of Stephan Herrmann as per discussion at: https://www.eclipse.org/forums/index.php?t=msg&th=899545&goto=1540563&#msg_1540563
The next Java SE release is version 9, which is currently scheduled for early 2016. This Java release will add modularization to the Java language, also known under the code name Jigsaw.  Eclipse Java development tooling will make progress towards compiling, editing and launching applications for Java 9 for those parts which have publicly available specifications.
"I get a NullPointerException during compilation of a class that has a syntax error. This happens since Mars M4, previous milestone releases were fine.  Here is a code snippet that reproducibly triggers the error   public class Test { 	 	public void foo() { 		String s1 = """"; 		s1.; 	}  }  Subsequently, the error log is spammed with the same error when hovering over the highlighted syntax error.  This also breaks a lot of our tests in our build. One example of a test class with failures is at http://git.eclipse.org/c/recommenders/org.eclipse.recommenders.git/tree/tests/org.eclipse.recommenders.completion.rcp.tests/src/org/eclipse/recommenders/completion/rcp/it/RecommendersCompletionContextTest.xtend  Stacktrace for the error:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.insertTokenAhead(RecoveryScanner.java:100) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeLocalVariableDeclarationStatement(Parser.java:4868) 	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6589) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11111) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11716) 	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12015) 	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12001) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:358) 	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12109) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11174) 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11460) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:192) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:873) 	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10149) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1159) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119) 	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:221) 	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285) 	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186) 	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181) 	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150) 	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902) 	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243) 	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3983) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:648) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:592) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:483) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)"
"Since upgrading to JDT 3.11.0.v20141210-2000 I get a StackOverflowError during the compilation of a JDT project that compiled fine with JDT 3.11.0.v20141029-2000.  I was able to reduce the code causing the error to the following snippet:  --------------------------------  class Test1<E> { 	<T extends Test1<T>> void method1(Class<T> t) { 		Test2<? super T> test2 = getTest2(t);                 // getTest2(t); // --> no error 	} 	<T extends Test1<T>> Test2<? super T> getTest2(Class<T> t){ 		return null; 	} 	 }  class Test2<E extends Test1<E>>{}  ---------------------------------  I'm not exactly sure what causes the error but it seems to have to do with the generic parameter <E extends Test1<E>> in class Test2 in combination with the returned Test2<? super T> of the method getTest2.  The error goes away when doing any the following: - removing ""Test2<? super T> test2 ="" (see the commented out code in the snippet) - changing the generic type of Test2 to be just <E> - changing the return type of getTest2 to be just Test2<?>"
"The progream below could be compiled with 4.4.1 but cannot be compiled with 4.5.0(M4): I must write Collections.<String>emptySet() to compile it now.  import java.util.Collections; import java.util.Map; import java.util.Set; import java.util.function.Function;  class Foo { 	static <K, V> Map<K, V> foo(K value, Function<? super K, V> function) { 		return null; 	} 	 	static void bar(Set<String> set) { 		Map<String, Set<String>> map = foo("""", e -> Collections.emptySet()); 	} }"
Created attachment 249820 [details] EE description file  I20150106-0800  - Preferences > Installed JREs > Add... > Execution Environment Description - select the attached .ee file, Finish - switch to JUnit page => dialog asks about applying changes (good) - click Apply - go back to Installed JREs and then switch to JUnit again => dialog asks again to Apply (not good). Same if you close/reopen the preferences dialog and then switch away from the Installed JREs page.
"This might be related to bug 444024?  I tried compiling a bigger workspace with Luna SR1, Eclipse Mars M4, and also with a Mars version built on top of Stephan's ""external annotations"" branch. In this version I have the following: given the following class fragment:  public class HtmlRunReporter implements ITxPerClassListener, IResultReporter { 	@Nonnull 	final private OutputHelper m_outputHelper;  	@Nullable 	private HtmlOut m_o;  	public HtmlRunReporter(@Nonnull OutputHelper outputDir) { 		m_outputHelper = outputDir; 	}  with: - this being the ONLY constructor - project set to 1.6 level - Nullity checks present with the ""old"" annotations (declaration jsr305 style)  I get 2 errors on a full build: The @Nonnull field m_o may not have been initialized The @Nonnull field m_outputHelper may not have been initialized  If I just change something and save, causing an incremental compile the error about m_o disappears. If I then for instance remove the @Nonnull from the constructor parameter and save the other error disappears. Adding the @Nonnull back and save - no error still -> the code is now the same as before, yet all errors are gone.  The last one, where you really need to play with the @Nonnull to make it disappear is odd. It seems that any change to nullness information ""fixes"" that problem in incremental build, for instance adding a @Nullable or @Nonnull somewhere else.  The first problem does not occur if I add ""m_o = null"" inside the constructor.  Changing JDK and language level to 1.7 has no effect on the problem.  No idea if it is related, but what is also noticeable is that the editor's error markings (in the gutter) also behave bad: they are often present when the error has been gone from ""problems"" and vice versa."
This will be the top level bug for JDT Core in tracking the Java 9 support in JDT Core. Java 9 will mainly feature module support. We need to investigate what changes will be exactly required, below being some candidates:  1. The classpath resolution should support "module" along with JARs. We must also investigate the requirement of a new type of classpath container. 2. Lookup environment probably needs to change as well to cater to the new module specification such as access restriction, versions etc. 3. Support to build modules from existing workspace resources, if any. 4. Changes to batch compiler if any.
Consider the following example:  /**  * {@link #MSA_CONSTANT}  */ public interface IMsaTest {    int MSA_CONSTANT = 42;  }  If I hover on IMsaTest to get its Javadoc and click on the link, i won't see the constant value. If I do the same in the Javadoc view it works as expected.  The same behaviour can be found for Javadoc on Methods.
Enabling the java type decorator by default would be very useful.
When I use quick fix both in a magic number or in a string the following options appear in the popup:   Extract to local variable (replace all ocurrences)  Extract to local variable  Extract to local constant  When a string is being selected, both the first and the third option replace all the ocurrences of the string.  But when a number is being selected, it only replaces the selected occurrence selecting any of those options.  I found a workaround: using the shortcut Ctrl+T, A, then checking "replace all the occurrences".  Regards,  Jorge
Hi,  I was testing few things with Java 8 and it looks like there is a bug in Eclipse Java Compiler. The following code does not compile:    List<Dish> menu = ...     // multilevel grouping   Map<DishType, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =       menu       .stream()       .collect(Collectors.groupingBy(Dish::getType,           Collectors.groupingBy(dish -> {             if (dish.getCalories() <= 400) return CaloricLevel.DIET;             if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;             return CaloricLevel.FAT;           })));  Eclipse shows errors on lines with dish.getCalories() saying "The method getCalories() is undefined for the type Object" The same code compiles well with Oracle javac 1.8.0_05.  Complete code is available on github: https://github.com/pbielicki/java8  Cheers, Przemyslaw  -- Configuration Details -- Product: Eclipse 4.4.1.20150109-0740 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.10.0.v20140925-0400
"Our product, which is starting to consume Eclipse 4.4.1, is noticing a performance degradation with the Java compiler of 37% (measured over 5 runs) as compared to our previous product version which consumes Eclipse 4.2.2.  For example, using a sample Java project we are seeing the following times:  Java Builder (Browser Client) 	Eclipse 4.4.1: 6818ms 	Eclipse 4.2.2: 4966ms 	Difference:  -1852ms (-37.00%)  Machine specs:  OS: Windows 7 Professional - 64 bit OS CPU: Intel i7-2600 CPU @ 3.40GHz (8 cores) Memory: 8GB  JRE:  java full version JRE 1.7.0 IBM Windows AMD 64 build pwa6470sr8ifix-20141106_01(SR8+IV66375)  VM args: -Xms100m -Xmx1024m -Xmnx64m -Xgcpolicy:gencon"
Junit 4.12 was released, it would be good to update the version of junit in jdt to the latest version.  Upstream's release notes:  https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md
See   http://download.eclipse.org/eclipse/downloads/drops4/M20150121-0900/buildlogs/comparatorlogs/buildtimeComparatorUnanticipated.log.txt  These types of errors are the "worst", since they involve .class files.   Meaning "what was delivered" in M20150121-0900 is not the same as what was built, since the qualifier did not change.   I've not actually looked at the .class file differences, to know if significant or not, but will attach the "artifactcomparison" directory from the build targets, to make it easier for you to assess.   Please let me know if a re-build is needed ... after "touching" the related artifacts.
Sibling of bug 458186, but now we want to support adding annotations without any compile errors/warnings.  Rationale: by pointing to the library method in an editor when adding annotations, we can completely hide the attached external annotations.
During initial experiments regarding bug 458200 I learned that ClassFileEditor does not at all participate in quick assists (for obvious reasons).  Yet, in that other bug it would be awesome if we could indeed use the accustomed gesture of quick assist for adding external annotations to library classes.  I have some experimental changes in my workspace that succeed in invoking the QuickAssistProcessor on a ClassFileEditor:  ClassFileEditor.createActions(): - create a variant of the QUICK_ASSIST action with runsOnReadOnly=true  ClassFileEditor.createJavaSourceViewer(): - adjust signature to override the corresponding super method,    so we actually get invoked   FIXME: is that signature mismatch a bug? The method is currently unused! - in the anonymous JavaSourceViewer override canDoOperation and   doOperation to handle QUICK_ASSIST (similar to CompilationUnitEditor)  JavaCorrectionProcessor.computeQuickAssistProposals(): - add an "else" to the block guarded by "if (model != null ..."   - fetch the IClassFile   - from the IClassFile obtain a ClassFileWorkingCopy   - using that working copy create an AssistContext   - proceed as the block above  The part regarding the ClassFileWorkingCopy poses a problem: I could not find any API in JDT/Core that would allow this (my experiments had to set discouraged access to warning for this reason). BTW, ITypeRoot.getWorkingCopy() is close but no cigar.  Other than that the experiment was quite smooth and successful up-to the point mentioned above: invoking QuickAssistProcessor.hasAssists() - just we didn't find any applicable assists :) but that would then be the job of bug 458200.
This is the root bug to track Java 9 support in JDT/UI.
"Created attachment 250202 [details] Failing snippet.  It seems the compilation of method references has a limit if used as in the given testcase. The snippet works if there are only 200 Test::main method references each. With 250 as in the snippet, running the compiled class fails with:  Exception in thread ""main"" java.lang.NoSuchMethodError: Test$Data.access$0()[LTest$MethodRef; 	at Test.main(Test.java:8)  Expected output (javac works): 250  This is a blocking bug for me because for my automatic Java code generation this initialization layout is the only one that works around various Java, javac compiler and ecj compiler limitations. At least I thought so.  This bug would probably be fixed by fixing https://bugs.eclipse.org/bugs/show_bug.cgi?id=430157 But the same might happen with lambda expressions again."
Feeding source similar to this:  //--- public interface MyMap<K,V> extends Map<K,V> {     @Override     public @Nullable V get(@Nullable Object key);     ... } //---  Into the reconciler causes:  NullPointerException:      SourceElementParser$1(ProblemReporter).illegalReturnRedefinition(AbstractMethodDeclaration, MethodBinding, char[][]) line: 9375      ImplicitNullAnnotationVerifier.checkNullSpecInheritance(MethodBinding, AbstractMethodDeclaration, boolean, boolean, boolean, MethodBinding, MethodBinding[], Scope, ImplicitNullAnnotationVerifier$InheritedNonNullnessInfo[]) line: 299         ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding, AbstractMethodDeclaration, boolean, Scope) line: 115      SourceTypeBinding.createArgumentBindings(MethodBinding, CompilerOptions) line: 2007      SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1974      SourceTypeBinding.methods() line: 1467       SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 856        CompilationUnitScope.faultInTypes() line: 445        CompilationUnitProblemFinder(Compiler).resolve(CompilationUnitDeclaration, ICompilationUnit, boolean, boolean, boolean) line: 958        CompilationUnitProblemFinder.process(CompilationUnit, SourceElementParser, WorkingCopyOwner, HashMap, boolean, int, IProgressMonitor) line: 197      CompilationUnit.buildStructure(OpenableElementInfo, IProgressMonitor, Map, IResource) line: 194      CompilationUnit(Openable).generateInfos(Object, HashMap, IProgressMonitor) line: 259         CompilationUnit(JavaElement).openWhenClosed(Object, boolean, IProgressMonitor) line: 579         CompilationUnit.makeConsistent(int, boolean, int, HashMap, IProgressMonitor) line: 1082      ReconcileWorkingCopyOperation.makeConsistent(CompilationUnit) line: 171      ReconcileWorkingCopyOperation.executeOperation() line: 90        ReconcileWorkingCopyOperation(JavaModelOperation).run(IProgressMonitor) line: 729        ReconcileWorkingCopyOperation(JavaModelOperation).runOperation(IProgressMonitor) line: 789       CompilationUnit.reconcile(int, int, WorkingCopyOwner, IProgressMonitor) line: 1247       JavaReconcilingStrategy.reconcile(ICompilationUnit, boolean) line: 126       JavaReconcilingStrategy.access$0(JavaReconcilingStrategy, ICompilationUnit, boolean) line: 108       JavaReconcilingStrategy$1.run() line: 89         SafeRunner.run(ISafeRunnable) line: 42       JavaReconcilingStrategy.reconcile(boolean) line: 87      JavaReconcilingStrategy.reconcile(IRegion) line: 151         JavaCompositeReconcilingStrategy(CompositeReconcilingStrategy).reconcile(IRegion) line: 86       JavaCompositeReconcilingStrategy.reconcile(IRegion) line: 104        JavaReconciler(MonoReconciler).process(DirtyRegion) line: 77         AbstractReconciler$BackgroundThread.run() line: 206    Passing null for nonNullAnnotationName doesn't look like a good idea.
"Created attachment 250220 [details] Eclipse project producing the bug  The attached project fails to compile (error occurs when opening the Main.java in the editor).  This does not look like it's the same issue mentioned in bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=446087 since the trace does not show the SyntheticBaseCallSurrogate class.   <pre> java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.codegen.CodeStream.invoke(CodeStream.java:4346) 	at org.eclipse.jdt.internal.compiler.codegen.TypeAnnotationCodeStream.invoke(TypeAnnotationCodeStream.java:116) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:437) 	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:705) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:325) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:270) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:609) 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.generateCode(QualifiedAllocationExpression.java:233) 	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.generateCode(FieldDeclaration.java:126) 	at org.eclipse.jdt.internal.compiler.ast.Clinit.generateCode(Clinit.java:305) 	at org.eclipse.jdt.internal.compiler.ast.Clinit.generateCode(Clinit.java:117) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1210) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) </pre>"
"I paste this into a source file X.java in eclipse: === interface IStoredNode<T> extends INodeHandle<DocumentImpl>, NodeHandle { }  interface NodeHandle extends INodeHandle<DocumentImpl> { }  class DocumentImpl implements INodeHandle<DocumentImpl> { 	public Object getNodeId() {return null;} }  interface INodeHandle<D> {     public Object getNodeId(); } 	  public class X { 	public void foo(IStoredNode bar) { 		bar.getNodeId(); 	}	 } === It builds with compliance 1.7, fails with compliance 1.8 (on the call getNodeId I get ""The method getNodeId() is ambiguous for the type IStoredNode""). It compiles fine with javac with -source 1.8."
Created attachment 250278 [details] proposed fixes  In experiments regarding bug 458201 I ran into an NPE.  It starts when I say     classFile.getWorkingCopy((WorkingCopyOwner)null, null);  on a classFile representing a class of an external jar, for which a source attachment exists.   In BecomeWorkingCopyOperation.executeOperation() we NPE upon a non-existent resource.  I tried two ways for avoiding the NPE:  1. If resource == null completely avoid adding a delta. This approach caused another NPE down the line: Util.getUnresolvedJavaElement(TypeBinding ...) found a SourceTypeBinding for which none of the following attempts succeed: - check if file is *.class -> create a ClassFile - else getCompilationUnit() In this situation fileName referred to a *.jar, => we return null. NPE occurred when the result of a recursive invocation was not checked for null (the type variable branch).  Should jars be handled here? Or is just the fileName wrong? Should it point to the class file insided the jar?  2. As an alternative I tried branching into "// report an ADDED delta". This one additionally(?) caused CCE in ClassFile.existsUsingJarTypeCache() where we expect a ClassFile but now have a ClassFileWorkingCopy. Here an instanceof check seems a natural solution.   I'm attaching a patch which should make all three locations safer - for good measure. It demonstrates (2) even though the other option might be preferrable(?)
"package p1;  import java.util.Arrays; import java.util.Comparator;  public class C1 { 	Comparator<String> c1 = (o1, o2) -> o1.compareToIgnoreCase(o2);  	public static void main(String[] args) { 		Comparator<String> c2 = (o1, o2) -> o1.compareToIgnoreCase(o2); 		Arrays.sort(new String[2], (o1, o2) -> o1.compareToIgnoreCase(o2)); // not shown in Ctrl+T 	} }  ---------------------------------------------------------  In the above example, invoke Quick Type Hierarchy (Ctrl+T) on ""->"". The third lambda is not shown in the quick type hierarchy result.  If Open Type Hierarchy (F4) is invoked on ""->"", all three lambdas are shown in the result."
"package p1;  import java.util.function.Function;  @SuppressWarnings(""unused"") public class CL<T> { 	private void newMeth() { 		Function<Integer, int[]> a1 = int[]::new; 	} }  ----------------------------------------------  In the Java Search tab of Search dialog, set: Search string: * Search For: Method Limit To: Match locations > '::' method references Scope: Workspace  and click ""Search"" with the above file in workspace. The result shows the constructor reference.  Now, comment the annotation line ""@SuppressWarnings(""unused"")"" and save. Search again with the same settings as above. The result does not contain the constructor reference.  Also, change the search string to: *new and search with or without the annotation. The result does not contain the constructor reference."
"It seems that declarations of methods inside an enum declaration should be indented, as they are inside regular classes. In this example, the method ""opposite()"" is indented here in my bug report, but it is not indented in my actual code window in the Eclipse editor (and the very last line is not outdented below, though it should be):   public enum Direction {NORTH, SOUTH, EAST, WEST; // note semicolon here 	public Direction opposite() { // method to return the opposite compass direction 		switch (this) { 		case NORTH: 			return SOUTH; 		case SOUTH: 			return NORTH; 		case EAST: 			return WEST; 		case WEST: 			return EAST; 		default: return null; 		} // switch 	} // opposite() 	} // enum Direction   -- Configuration Details -- Product: Eclipse 4.4.1.20150109-0740 (org.eclipse.epp.package.java.product) Installed Features:  org.eclipse.platform 4.4.0.v20140925-0400"
The JDT lexer allows hexadecimal floating-point literals without digits. For example 0XP00 is accepted as a valid literal by Eclipse. Javac correctly reports an error for this literal:  tests/lex/num_10f/Test.java:2: error: hexadecimal numbers must contain at least one hexadecimal digit       double _ = 0XP00;  The JDT should give a similar error. For other malformed literals such as 0X0P (missing exponent) JDT gives the error message "Invalid float literal number".
+++ This bug was initially created as a clone of Bug #407585 +++  Two features in JDT have obsolete "legal files" in them.   org.eclipse.jdt-feature in eclipse.jdt repo  epl-v10.html notice.html   Appears this "jdt.jeview.feature" is a "nested" feature?  
Failed in the latest I build:  http://download.eclipse.org/eclipse/downloads/drops4/S-4.5M5a-201502031300/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html  junit.framework.AssertionFailedError: Destination container not changed at org.eclipse.jdt.core.tests.model.CopyMoveTests.copyPositive(CopyMoveTests.java:110) at org.eclipse.jdt.core.tests.model.CopyMoveElementsTests.testCopyInitializerWithPositioningInDifferentProject(CopyMoveElementsTests.java:877) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76) at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) at org.eclipse.equinox.launcher.Main.main(Main.java:1438) at org.eclipse.core.launcher.Main.main(Main.java:34)  And test in local environment run alright.
In the help [1] I describe how null annotations at a type parameter affect the type variable (usage). From this explanation it is not obvious that this nullness can be overridden at each usage of the type variable, like:  interface I1 <T extends @NonNull Object> {    @Nullable T maybeGet(); }  interface I2 <@Nullable T> {    @NonNull T getNonNull(); }  A paragraph should be added to make this fact better known.  Additionally, this sentence from the javadoc of DefaultLocation should be made more prominent:  "Wildcards and the use of type variables are always excluded from {@link NonNullByDefault}."  [1] http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_type_annotations.htm&cp=1_3_9_1_0_0&anchor=typeVariables
"interface I <T,R> { 	R apply(T t); } public class X { 	 	Integer bar(Integer x) { return null;} 	 	Integer foo(){ 		 		 		I <Integer, X> i2 = (x) -> {ret /* type ctrl-space after ret */}; 		return 0; 	} }"
The code below should compile fine but gives the error: Lambda expression's parameter arg1 cannot redeclare another local variable defined in an enclosing scope.  import java.io.Serializable; import java.util.function.BiConsumer; import java.util.function.Consumer;  public class Snippet {   public static void main(String[] args) {     foo(arg1 -> bar(Snippet::baz));   }    private static <A1> void foo(Consumer<A1> c) { }   private static void baz(String s1, String s2) { }   private static void bar(VoidMethodRef2<String, String> mr2) { }   private static interface VoidMethodRef2<A1, A2> extends BiConsumer<A1, A2>, Serializable { } }
Created attachment 250583 [details] Fix in old ImportRewriteAnalyzer  Follow-up to bug 454914 comment 3.  ImportRewrite adds an unused import for the declared package when pasting into a compilation unit that is outside of the project's classpath.  Steps: - check out SWT from Git and set the project up for your platform (copy .classpath file) - open MenuItem#setToolTipText(String) from the classpath - copy doc line to clipboard:  * {@link Shell#setMenuBar(Menu) shell menubar} on Windows, Mac, and Ubuntu Unity desktop. - Open Resource..., open a MenuItem.java that is not on classpath - set caret to first line of class Javadoc - Paste  => bad import added: import org.eclipse.swt.widgets.*;  The attached fix is for the old ImportRewriteAnalyzer (before bug 430303). I still had this in my workspace and need to save it somewhere. Didn't release since it would conflict with bug 430303, and I guess it's better to get that one done first.
Patch contains some improvements for o.e.jdt.ui.examples.projects:          * Set "strictly compatible JRE" pref to warning (so it works out of the box for everyone)     * Bump BREE to 1.5 (this is highest BREE used by any eclipse.jdt.ui bundle)     * Drop useless non-javadoc comments     * Avoid use of nested jar (prevents workspace "dirt" at build time)
master  CompilationUnit#findDeclaringNode(..) finds ExpressionMethodReference instead of MethodDeclaration  Snippet:  public class E1 {     void foo(Object arg) {         IntSupplier s1 = arg::hashCode;     } }  In the ASTView, show the ExpressionMethodReference for arg::hashCode. Double-clicking its child node "> method binding: Object.hashCode()" calls findDeclaringNode(..), and that API wrongly returns the enclosing ExpressionMethodReference, which consequently gets selected.  findDeclaringNode(..) should return null in this case, since Object#hashCode() is not declared in the given AST.
The JEP 220 of the project jigsaw defines the new module run-time images. This needs to be supported in JDT.  At the moment, this is the list (not complete by any means) of things that need to evolve:  1. First and foremost, loading classes from a JDK9. JDT should be able to read classes from the new jrt format. We need to come up with a strategy for this - whether to use the provided jrt-fs that will be bundled with the JDK9 (even when eclipse itself runs on <= JRE 8) or something else (home-grown?). Without this, it's impossible to use JDK9 in project build path.  2. JREContainer should evolve to support the new VM installs. Some of the changes known at this point are, removal of /ext and /endorsed. Instead the new module system will be used for extensions.  3. Removal of certain JAR files: rt.jar and tools.jar have been removed. If we are hard-coding dependency anywhere, that should be addressed.
The following code:  List<Integer> numbers1 = Arrays.asList(1, 2, 3); List<Integer> numbers2 = Arrays.asList(3, 4); List<int[]> pairs = numbers1.stream().flatMap(i -> numbers2.stream().map(j -> new int[]{i,j})).collect(Collectors.toList()); pairs.forEach(System.out::println);  generates the error:  Type mismatch: cannot convert from List<Object> to List<int[]>.  This is not the case when compiling from command line using JDK1.8.0_31.
"buildId: N20150211-2000 platform: linux url: https://hudson.eclipse.org/hudson/job/ep45N-unit-lin64/201/  stacktrace:  junit.framework.ComparisonFailure: Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in X.java (at line 7)\n 	return null; // ERR\n 	       ^^^^\n Null type mismatch: required '@NonNull T' but the provided value is null\n ----------\n 2. ERROR in X.java (at line 11)\n 	@NonNull Number nnn = inum.process(null); // ERR on argument\n 	                                   ^^^^\n Null type mismatch: required '@NonNull Number' but the provided value is null\n ----------\n  ------------ but was ------------ ----------\n 1. ERROR in X.java (at line 7)\n 	return null; // ERR\n 	       ^^^^\n Null type mismatch: required '@NonNull T' but the provided value is null\n ----------\n 2. ERROR in X.java (at line 10)\n 	void test(Inner<Number> inum) {\n 	                ^^^^^^\n Null constraint mismatch: The type 'Number' is not a valid substitute for the type parameter '@NonNull T'\n ----------\n 3. ERROR in X.java (at line 11)\n 	@NonNull Number nnn = inum.process(null); // ERR on argument\n 	                                   ^^^^\n Null type mismatch: required '@NonNull Number' but the provided value is null\n ----------\n  --------- Difference is ----------  expected:<...in X.java (at line 1[]1)\n 	@NonNull Numbe...> but was:<...in X.java (at line 1[0)\n 	void test(Inner<Number> inum) {\n 	                ^^^^^^\n Null constraint mismatch: The type 'Number' is not a valid substitute for the type parameter '@NonNull T'\n ----------\n 3. ERROR in X.java (at line 1]1)\n 	@NonNull Numbe...> 	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259) 	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:946) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2499) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2297) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:2881) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractNullAnnotationTest.runNegativeTestWithLibs(AbstractNullAnnotationTest.java:130) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractNullAnnotationTest.runNegativeTestWithLibs(AbstractNullAnnotationTest.java:140) 	at org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest.testDefault06(NullTypeAnnotationTest.java:4839) 	at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56) 	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) 	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) 	at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) 	at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) 	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438) 	at org.eclipse.core.launcher.Main.main(Main.java:34)"
Missing nullness information for the JRE can be attached using external annotations (see bug 331651), but for some methods, we still don't have a place to put annotations, because those methods are never declared in any source.  Examples are the values() / valueOf() pair of methods generated into each enum type. Given we statically know the contract of those methods, the compiler should implicitly know about their nullness, too.  Basically, all kinds of SyntheticMethodBinding are candidates, to be scanned which ones can actually impact null analysis.
"Build: N20150215-2000 platform: win32/mac http://download.eclipse.org/eclipse/downloads/drops4/N20150215-2000/testResults.php  stack trace:  stacktrace: junit.framework.AssertionFailedError: Number of markers expected:<0> but was:<3> 	at org.eclipse.jdt.core.tests.model.ExternalAnnotations18Test.assertNoMarkers(ExternalAnnotations18Test.java:233) 	at org.eclipse.jdt.core.tests.model.ExternalAnnotations18Test.test3(ExternalAnnotations18Test.java:777) 	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104) 	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88) 	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76) 	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85) 	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657) 	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) 	at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) 	at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) 	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1465) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1438) 	at org.eclipse.core.launcher.Main.main(Main.java:34)"