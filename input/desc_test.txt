BETA_JAVA8:  This bug is to record & track a clarification request to the 335 EG:  // ---- 8< -------  The following lambda expression does not compile with 8b74, while the  implementation of the method in a class does compile:   // ------------  interface G1 {    <E extends Exception> Object m(E p) throws E;  }  interface G2 {    <F extends Exception> String m(F q) throws Exception;  }  interface G extends G1, G2 {}   // G has descriptor <F extends Exception> ()->String throws F   public class X {                   G g = (x) -> { // Elided type is inferred from descriptor to be F              throw x;    // ~== throw new F()          };  }   class Y implements G {          public <T extends Exception> String m(T t) throws T {                  throw t;          }  }  // -----------------------   Is this a bug in the implementation or the specification ?  Since the lambda cannot refer to the type variables of the  descriptor by name nor declare its own, if 8b74 behavior is  correct, that would mean that, no checked exceptions could  be thrown from a lambda if the descriptor of the target  interface method mentions a type variable in throws clause.   My analysis is that the lambda should be accepted as it does  not manufacture any fresh exceptions and simply throws an  exception that is known to have satisfied the constraints at  the invocation site, i.e no additional/unexpected surprises  are there due the lambda throwing the object it was handed.
+++ This bug was initially created as a clone of Bug #247845 +++  While it is good that JDT Core does not log those exceptions, it should pass them back to the client.  Currently, we can't show the user that the attached Javadoc could not be accessed.   T
4.3 M5a.  Currently JDT Core ignores some exceptions and returns 'null'. This violates the API/Javadoc. Bug 400060 tracks that part. Once this is fixed we need to adjust our code to handle those exceptions and show them to the user without logging them.
"this is the exception:  !ENTRY org.eclipse.ui 4 0 2013-02-08 23:36:40.932 !MESSAGE Unhandled event loop exception !STACK 0 org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.prepareDelayedProjection(JavaSourceViewer.java:658) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2582) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2571) 	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395) 	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4289) 	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4311) 	at org.eclipse.ui.internal.WorkbenchPage.reuseEditor(WorkbenchPage.java:2885) 	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3023) 	at org.eclipse.ui.internal.WorkbenchPage.access$22(WorkbenchPage.java:2969) 	at org.eclipse.ui.internal.WorkbenchPage$8.run(WorkbenchPage.java:2951) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2947) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2911) 	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2902) 	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:373) 	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:179) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.gotoSelectedElement(AbstractInformationControl.java:440) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.access$0(AbstractInformationControl.java:435) 	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$2.widgetDefaultSelected(AbstractInformationControl.java:227) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:119) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4169) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3758) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)   I already had that also in my 3.8.x version, but now i am on the 4.3 stream:  Version: 4.3.0 Build id: I20130205-0800  i i still have this. For that workspace i really need to say that it shouldn't close editors automatically for a specific number (16) now.  If this happens, i really have first to close 1 and then i can reopen on."
We're using Google Guice (com.google.inject) dependency injection, which means that a field annotated with @Inject cannot be null unless it is explicitly annotated as @Inject(optional=true). Since Kepler M5, JDT's null pointer analysis for fields reports errors on almost all fields now.
We have to document removal of 'org.junit4' and 'org.junit' 3.8.2 in the migration guide.
"BETA_JAVA8:  The following program compiles silently with HEAD:  // ---- X.java import p.I;  public class X { 	I i = (p) -> { return null; }; } // ---- I.java package p; public interface I { 	ReturnType doit(ParameterType p) throws ExceptionType; }  class ReturnType { }  class ParameterType { }  class ExceptionType extends Exception { } // ----------------------  It should report three errors, one each about ReturnType, ParameterType and Exception type as they are not visible at the lambda definition site.  Interestingly javac 8b74 complains:  X.java:6: error: ParameterType is not public in p; cannot be accessed from outsi de package X.java:4: error: ParameterType is not public in p; cannot be accessed from outsi de package         I i = (p) -> { return null; };               ^ 2 errors  // ----  Here is the relevant wording:   For each checked exception that can result from execution of the body of the lambda expression, a compile-time error occurs unless that exception type or a supertype of that exception type is mentioned in the throws clause of the descriptor of T'.   It is a compile-time error if any class or interface mentioned by either T' or the descriptor of T' is not accessible from the class in which the lambda expression appears."
Bug 391894 added support for type annotations Array creation nodes. This bug will be used to add the rewrite support for array creation with type annotations.
Created attachment 226944 [details] JDT branding plugin  Make the branding plugin qualifiers consistent with the buildId  PW
This appears to be a regression in Kepler M5. When debugging an Eclipse Application, codeassist does not work in Display view. This worked in Kepler M4.  Not sure if this makes any difference, I am on OSX 10.8.2 with Oracle Java 1.7.0_10.
For the entire Type Hieararchy (AnnotatableType) and Type Parameter hierarchy - ASTRewrite implementation [to be done in cases missing or corrected in cases existing if need be].  This is the ASTRewrite Equivalent of bug 391890.
"In a project with nullity annotations present I have a lot of warnings like:  Null type safety: the expression of type AppSession needs unchecked conversion to conform to '@Nonnull AppSession'.  On the warning message, click ""quick fix"" and select ""Change parameter type to @Nonnull"", select a single file, then press finish. Eclipse comes with a popup stating ""an exception occured while applying the quick fix"", and the message in the title of this bug report.  Selecting multiple files to fix dies without any kind of message, and no files are changed.  The log shows (dont't be scared, huge stack trace): !ENTRY org.eclipse.jdt.ui 4 10001 2013-02-13 11:41:55.559 !MESSAGE Internal Error !STACK 1 Java Model Exception: Core Exception [code 0] The fix 'Add Annotations' generated a null change. 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:50) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5332) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal$1.run(FixCorrectionProposal.java:218) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.resolve(FixCorrectionProposal.java:225) 	at org.eclipse.jdt.internal.ui.text.correction.CorrectionMarkerResolutionGenerator$CorrectionMarkerResolution.run(CorrectionMarkerResolutionGenerator.java:145) 	at org.eclipse.ui.internal.views.markers.QuickFixPage$11.run(QuickFixPage.java:565) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixPage.performFinish(QuickFixPage.java:554) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard$1.run(QuickFixWizard.java:97) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard.performFinish(QuickFixWizard.java:106) 	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:827) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:432) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3705) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3326) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.internal.views.markers.QuickFixHandler.execute(QuickFixHandler.java:165) 	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:76) 	at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:231) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:212) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:277) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:496) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:547) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:368) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:314) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:83) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1552) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1391) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1416) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1401) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1428) 	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:829) 	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3180) 	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:758) 	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2092) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5334) 	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:3566) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4532) 	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method) 	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:8549) 	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1241) 	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method) 	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2281) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3324) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: org.eclipse.core.runtime.CoreException: The fix 'Add Annotations' generated a null change. 	at org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFix.createChange(CompilationUnitRewriteOperationsFix.java:106) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:810) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80) 	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5332) 	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal$1.run(FixCorrectionProposal.java:218) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) 	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.resolve(FixCorrectionProposal.java:225) 	at org.eclipse.jdt.internal.ui.text.correction.CorrectionMarkerResolutionGenerator$CorrectionMarkerResolution.run(CorrectionMarkerResolutionGenerator.java:145) 	at org.eclipse.ui.internal.views.markers.QuickFixPage$11.run(QuickFixPage.java:565) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixPage.performFinish(QuickFixPage.java:554) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard$1.run(QuickFixWizard.java:97) 	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464) 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ui.internal.views.markers.QuickFixWizard.performFinish(QuickFixWizard.java:106) 	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:827) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:432) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3705) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3326) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.internal.views.markers.QuickFixHandler.execute(QuickFixHandler.java:165) 	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:290) 	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:76) 	at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:231) 	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:212) 	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131) 	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:277) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:496) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:547) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:368) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:314) 	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:83) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1552) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1391) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1416) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1401) 	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1428) 	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:829) 	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3180) 	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:758) 	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2092) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5334) 	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:3566) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4532) 	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method) 	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:8549) 	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1241) 	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method) 	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2281) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3324) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) !SUBENTRY 1 org.eclipse.jdt.ui 4 0 2013-02-13 11:41:55.561 !MESSAGE The fix 'Add Annotations' generated a null change."
"Created attachment 226996 [details] formatter settings to reproduce  Hi,  Version: Juno Service Release 1 Build id: 20121004-1855  I noticed that the Save Action 'correct indentation' conflicts with the formatter 'line wrapping'. I attached my formatter configuration as reference.  The issue can be seen when using arguments with enums. The formatter uses indentation so that all types are indented on the same column, as well as the arguments for the enums and arguments to those arguments (think arrays).  Desired result (which the formatter does correctly): <pre> public enum TestEnum {  	FIRST_ENUM(""first type"", 	           new SomeClass(), 	           new OtherEnumType[] { OtherEnumType.FOO}),  	SECOND_ENUM(""second type"", 	            new SomeClassOtherClass(), 	            new OtherEnumType[] { OtherEnumType.BAR}),  	THIRD_ENUM(""third type"", 	           new SomeThirdClass(), 	           new OtherEnumType[] { OtherEnumType.BAZ}),  	FOURTH_ENUM(""fourth type"", 	            new YetAnotherClass(), 	            new OtherEnumType[] { OtherEnumType.FOOBAR, 	                                  OtherEnumType.FOO, 	                                  OtherEnumType.FOOBARBAZ, 	                                  OtherEnumType.LONGERFOOBARBAZ, 	                                  OtherEnumType.REALLYLONGFOOBARBAZ, 	                                  OtherEnumType.MORELETTERSINHERE});  /* data members and methods go here */  } </pre>  However when using the save action 'correct indentation', the 'SECOND_ENUM' start on the column of the arguments for 'FIRST_ENUM', the 'THIRD_ENUM' start on the column for arguments to the second one, and so on. This creates the dreaded staircase effect."
"The following code generates wrong code:  interface I {     public void foo() default {         System.out.println(""default"");     } } public class C implements I {     public static void main(String[] args) {         C c = new C();         c.foo();     } }  At runtime this produces: Exception in thread ""main"" java.lang.NoSuchMethodError: java.lang.Object.foo()V 	at C.foo(C.java:1) 	at C.main(C.java:9)  The reason is in the way a synthetic method (SuperMethodAccess) for foo is generated: it is assumed that the super method must be in accessMethod.declaringClass.superclass(), which leads to trying to invoke java.lang.Object.foo(), which obviously doesn't exist."
"BETA_JAVA8:  Amends to JLS7 read:  ""It is a compile-time error if the name of a local class C is used to declare a new local class within the scope of C, unless the new local class is declared in the body of C or within another class whose declaration is within the scope of C.""  So the following program should be rejected, but is not.  // -------- interface I { 	void foo(); }  public class X { 	void foo() { 		class Y {}; 		I i = ()  -> { 			class Y {}; 		}; 	}	 }   // ---  javac complains:   X.java:9: error: class Y is already defined in method foo()                         class Y {};                         ^ 1 error"
"M5: The following 	 	boolean badFunction(int i) { 		return i > 0 ? true : null; 	}  gives no diagnostic. Whereas  	 	boolean badFunction(int i) { 		return null; 	}  gives a cannot convert null to boolean."
Created attachment 227060 [details] Project to reproduce the bug  OVERVIEW Selecting code fragments or using "Open Declaration" on a selected part of code causes an endless loop in AbstractCommentParser:177 and eclipse generates 100% cpu  load on one core. If main thread gets in the loop eclipse is not responding and can only be terminated by task manager with losing all unsaved code.  REPRODUCTION Import the attached project in a clean workspace. Open the class "Bug" and scroll to the "TODO" task tag. Double click on "componentShown" in the next line and press F3.  RESULT Eclipse is hanging in an endless lopp with 100% cpu load on one core.  EXPECTED Eclipse should jump to the marked method.  ADDITIONAL INFORMATION The problem is caused by the JavadocParse. The parser tries to parse the package-info.java of a referenced package. After that the actual source is parsed, but the scanner used by the parser has still the source of the package-info.java. This leads to parsing the same source range over and over again.  WORKAROUND Disable javadoc comment processing in compiler options.  POSSIBLE FIX Initialising the source of the Scanner in org.eclipse.jdt.internal.compiler.parser.JavadocParser:94  CURRENT CODE public boolean checkDeprecation(int commentPtr) {   [...]   // Parse   try {     this.source = this.sourceParser.scanner.source;     [...]   } finally {     this.source = null; // release source as soon as finished   }   return this.deprecated; }  CODE FIXING THE PROBLEM public boolean checkDeprecation(int commentPtr) {   [...]   // Parse   try {     this.source = this.sourceParser.scanner.source;     this.scanner.setSource(this.source); //updating source in scanner     [...]   } finally {     this.source = null; // release source as soon as finished     this.scanner.setSource((char[]) null); //release source in scanner   }   return this.deprecated; }
Update the code formatter for Java 8 constructs. Currently, the formatter just gives up if it e.g. sees an annotation on an array type or vararg.  ASTRewrite needs a working code formatter to work correctly. ASTRewriteFormatter formats snippets to find the current formatter settings, and it runs the code formatter for new nodes.
BETA_JAVA8:  A number of changes are being made to overload resolution mechanism to accommodate poly expressions in method invocation context.  ECJ needs to evolve to address this scenario, which creates some interesting problems: When a lambda expression occurs in method invocation context as an argument, the type of the lambda expression cannot be determined until the overloaded method is chosen and the overloaded method cannot be chosen until the lambda expression's type is known.  JLS8 15.12.2 (part F of JSR335 specification) spells out the amended  overload resolution rules to address this and other scenarios.
BETA_JAVA8:  A number of changes are being made to type inference mechanism to fix specification bugs, clarify issues, to address poly expressions etc.  These are captured in section 18 of JLS8 - part G of JSR335 specification. ECJ should evolve to cope with these changes.
This will be the master bug for this project.
0.6.1 9.8 is silent about descriptor computation in the presence of raw types. Is this specified somewhere else ? Discouraged though this scenario may be,  we can expect to run into this sooner or later, intentionally coded or otherwise.  The reference compiler at 8b74 seems to erase the descriptor as seen by the following program: This seems reasonable from one pov. From another, this is somewhat at odds with the ban on lambdas implementing generic methods in that, in both cases we have (or are likely to have) unadaptable type variable usage in various constituents of the descriptor. And the target type is raw in one case and the lambda is "raw" in the other case (by virtue of there being no grammar support for type parameter encoding)  I am happy erasing the descriptor, but (a) should this stay unspecified if it indeed is and (b) does the inconsistency in treatment with generic lambdas OK ?  // --- import java.util.List; interface I<T> {     void foo(List<T> f); }  class Y {     void goo(I<String> f) {     } }  class Z {     void zoo(I f) {     } } public class X {     public static void main(String [] args) {        new Y().goo((List<String> ls) -> {});  // Compiles OK with 8b74        new Z().zoo((List ls) -> {});          // OK     } }  --------------------  To see the correlation between generic lambdas and raw types in target type study this program in which 8b74 is inadvertently allowing a generic lambda since it does not see the descriptor as being generic due to erasure:  // ----- import java.util.List; interface I<T> {     <P> P foo(List<T> f); }  class Y {     void goo(I<String> f) {     } }  class Z {     void zoo(I f) {     } } public class X {     public static void main(String [] args) {       new Y().goo((List<String> ls) -> { return null; }); // Fails: descriptor is generic        new Z().zoo((List ls) -> { return null; }); // compiles fine, we are overriding a generic method with another that has no type variables!!     } }
BETA_JAVA8:  This ER will be used as the master/umbrella entry for search engine changes to support Java 8. Please don't attach patches/fixes here. Any high level discussions can be had here, but all activity should be on broken down blocker unit level tasks each with its own bug number.  Some quick experiments show that the search engine as is is able to discover types and variables properly for lambda expressions.  For type annotations and reference expressions, there are various things that appear broken.
"BETA_JAVA8:  // ---------  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.io.Serializable;  public class X extends @Marker Object implements @Marker Serializable { 	int x = (@Marker int) 0; }  @Target(ElementType.TYPE_USE)	 @interface Marker { 	 } // ------------------------   Searching for references to Marker brings up only one result - the one inside the cast. The other two are missing."
"BETA_JAVA8:  Attempt to search for the declarations of an interface method fails to find lambda methods:  // ---- interface I { 	void doit(); }  class X { 	static void foo() {} 	I i = () -> {}; 	I i2 = new I() { 		void doit() { 			 		} 	}; }  Search for implementations of I#doit, brings up the one inside the anonymous class, but not the anonymous lambda method."
"BETA_JAVA8:  Searching for references to Existing in the following program brings up only one - it should show two:  // --- import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.Map; import java.util.List; import java.util.Collection;  interface I { 	I doit(); }  class X { 	class Folder<F extends @Existing File> {  } 	Collection<? super @Existing File> s; }  @Target(ElementType.TYPE_USE) @interface Existing { 	 }"
"BETA_JAVA8:  0.6.1 pulled back the allowance made for an interface method to be tagged with the keyword synchronized.  As a result, the following should not compile, but does:  interface I { 	synchronized default void foo() { 		 	} }  // ---  While fixing this, also see if we need a Java8 version of this message: 359 = Illegal modifier for the interface method {0}; only public & abstract are permitted  Now interface methods can also have default and static as keywords.  Also see  1050 = Illegal modifier for the interface method {0}; only public, abstract, strictfp & synchronized are permitted"
BETA_JAVA8:  As a foundation for the new type inference (JSR 335) I will capture the concepts from JLS8 Section 18.1: - 18.1.1 Inference Variables - 18.1.2 Constraint Formulas - 18.1.3 Bound Sets  It remains to be seen if a direct mapping of these concepts onto code yields a practical implementation: Pro: structural similarity will facilitate implementation and maintenance of advanced algorithms Con: the new structures might conflict with our existing implementation or with performance goals. Let's see.
(1) 0.6.1, 15.28 says:   "It is a compile-time error if the ClassType of a constructor reference denotes a class that is an enum type or that is abstract. "   While JLS7 15.9 in addition says:   "It is a compile-time error if any of the type arguments used in a class instance  creation expression are wildcard type arguments (§4.5.1)."   So is the less restrictive version with constructor references intentional ? I don't see anything in  the design/motivation section regarding this to determine if it is.   I would like to use one definition of what can be instantiated unless the relaxation is deliberate.   So, should the following program compile ?   // ---  interface I {    X<?> zoo(int x, String p);  }  public class X<T> {          X(int x, String p) {}          I i = X<? extends String>::new; // will compile        X<?> x = new X<? extends String>(); // will not compile.  }   I don't see a type safety issue here since the parameterization would have pass bounds check, only a consistency issue.   (2) And since the production for ClassType (despite the name) cannot prune type variables and  annotation types, should these also be called out as error scenarios ?   (3) Should the (obvious) point about primary evaluating to base type being a forbidden scenario  be mentioned ?   (4) "The immediately enclosing instance of an inner class instance (15.9.2) must be provided for a constructor reference by a lexically enclosing instance of this (8.1.3). "  Is this restrictive ? Can this be supplied at method invocation time or even via a primary from ? Implementable != useful and  I don't have an assessment as to how useful practically it would be though. Again this is a consistency issue: the call to  new Inner() can occur outside of the enclosing class in an entirely unrelated class as long as there an enclosing instance is  available and the types are visible.
From bug 378724 comment 15:  ---- Cast obscures nullness of a field:  class NPEonCast {      @Nullable     private Object nullable;      public void test() {         if (nullable instanceof Number) {             ((Number)nullable).intValue(); // A         }         if (nullable != null) {             nullable.toString(); // B         }         nullable.toString(); // C     }  }  Error missing for A (while correct for B and C) ----  While the result would be correct when syntactic analysis for fields is enabled (because the instanceof provides protection), without syntactic analysis we should see a warning, which we don't.
BETA_JAVA8:  This may be broken.   LambdaExpression.resolveType is an amalgam of   MethodScope.createMethod SourceTypeBinding.resolveTypesFor AbstractMethodDeclaration.resolve  I may not have hooked up all portions needed for null inheritance/analysis since some of this code was too dependent on the method binding having an associated AbstractMethodDeclaration.  In particular, the call to SourceTypeBinding.createArgumentBindings is not there.  Please see Scope.isLambdaScope, Scope.isLambdaSubscope, scope.namedMethodScope et al which may help with an alternate implementation.
BETA_JAVA8:   org.eclipse.jdt.core.tests.compiler.parser.GenericDietRecoveryTest.test0025() and org.eclipse.jdt.core.tests.model.ReconcilerTests.testMethodWithError01() have started failing since yesterday.  At least on the first, I could see that if I roll back the clock to before c4baf766be166b04f595eec5cebbd2a64f399daa the problem goes away.
"// Try this public class WrongRedundantNullCheck {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static void open() throws Exception { 		occasionallyThrowException(); 	}  	private static void close() throws Exception { 		occasionallyThrowException(); 	}  	public static void main(String s[]) { 		Exception exc = null; 		try { 			open(); 			// do more things 		} 		catch (Exception e) { 			exc = e; 		} 		finally { 			try { 				close(); 			} 			catch (Exception e) { 				if (exc == null) // Wrong warning in this line 					exc = e; 			} 		} 		if (exc != null) 			System.err.println(exc); 	} }"
"// Compile this import java.util.Date;  public class WrongRedundantNullCheck {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static Date createDate() throws Exception { 		occasionallyThrowException(); 		return new Date(); 	}  	public static void main(String s[]) { 		Date d = null; 		try { 			d = createDate(); 			System.out.println(d.toString()); 			try { 				occasionallyThrowException(); 			} 			catch (Exception exc) { 			} 		} 		catch (Exception exc) { 			if (d != null) // Wrong warning in this line 				System.out.println(d.toString()); 		} 	} }"
In a local build I just happened to try this afternoon, I'm seeing following error. My guess is something was removed from a "project pom", but not from the "repo pom"? I know this as been changing ... not sure why this error shows up just now. (This will prevent next production build to fail, if still exists ... apologies if I'm must catching you in the middle of making changes not fully committed/pushed yet).   Here's full error message:  [ERROR] The build could not read 1 project -> [Help 1] org.apache.maven.project.ProjectBuildingException: Some problems were encountered while processing the POMs: [ERROR] Child module /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/org.junit4 of /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml does not exist @          at org.apache.maven.project.DefaultProjectBuilder.build(DefaultProjectBuilder.java:363)         at org.apache.maven.DefaultMaven.collectProjects(DefaultMaven.java:636)         at org.apache.maven.DefaultMaven.getProjectsForMavenReactor(DefaultMaven.java:585)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:234)         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)         at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:601)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352) [ERROR] [ERROR]   The project eclipse.jdt.ui:eclipse.jdt.ui:3.8.0-SNAPSHOT (/data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml) has 1 error [ERROR]     Child module /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/org.junit4 of /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.jdt.ui/pom.xml does not exist
Per the javadoc for org.eclipse.jdt.internal.compiler.apt.model.ElementsImpl#getAllAnnotations(Element), "Annotations are inherited only if the annotation type is meta-annotated with @Inherited". However, the check for the @Inherited meta-annotation does not occur, and indeed all annotations on super classes of the class represented by element are returned, regardless of whether they are annotated with @Inherited.  Steps To Reproduce: 1. create annotation @Foo which is *not* annotated with @Inherited   2. create annotation processor with @SupportedAnnotationTypes("*"), and have it call processingEnv.getElementUtils().getAllAnnotationMirrors(element) for each root element, and print out the results (or use a debugger to see what it gets) 3. use annotation and processor like this:    a. create BaseClass and apply the annotation @Foo    b. create SubClass inheriting BaseClass. 4. The processor will be told that SubClass has the @Foo annotation on it.
I tried to use null analysis on all of my workspace projects which includes a couple of test projects.  I got a lot of warnings in unit tests, that looked like this:  Something x = someService.getNullableThing(); org.junit.Assert.assertNotNull("x", x); x.doMore(); // warning on this line  It would be great of the semantics of org.junit.Assert could be respected. I'd be willing to work on this. Can you provide a hint where to start, e.g. were the special handling of o.e.c.r.Assert is implemented.
For the program below javac 8b76 reports: C:\jtests>C:\lambda-8-b76-windows-x64-05_feb_2013\jdk1.8.0\bin\javac -cp c:\jtes ts X.java X.java:5: error: incompatible types: bad type in conditional expression; int can not be converted to List<String>                 List<String> l = x== 2 ? (List<String>)(null) : 1;                                                                 ^ 1 error  while eclipse BETA_JAVA8 head and javac7 report that Object cannot be converted to List<String>  This difference needs to be investigated.
JSR 335 0.6.1 Part H  "A this expression may appear in a default method body; its type is the type of the enclosing interface. Similarly, an anonymous or local class may be declared in a default method body, so the enclosing instance of an inner class may have an interface type. "  This is actually a NOP, because this is already correctly handled by the compiler. Still corresponding tests should be added.
JSR 335 0.6.1 has a new exception in 8.4.8.4  "It is a compile-time error if a class C inherits a default method whose signature is override-equivalent with another method inherited by C, unless there exists an abstract method declared in a superclass of C and inherited by C that is override-equivalent with the two methods."  The "unless" part is new and must be implemented.
"I have the following conditional breakpoint running in indigo without any problems  text != null && text.contains("";"")  In Kepler M5 I get the following exception  The Exception occurs as soon as I connect two expressione with &&. So text == null && text != null also causes this Exception. The two expressions in isolation do not cause any trouble.  Message: An internal error occurred during: ""JDI Event Dispatch"". ========  Exception Stack Trace: ======================  java.util.EmptyStackException 	at java.util.Stack.peek(Unknown Source) 	at java.util.Stack.pop(Unknown Source) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.pop(ASTInstructionCompiler.java:293) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.storeInstruction(ASTInstructionCompiler.java:297) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.endVisit(ASTInstructionCompiler.java:686) 	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:138) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2562) 	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:565) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:348) 	at org.eclipse.jdt.internal.debug.core.breakpoints.ConditionalBreakpointHandler.breakpointHit(ConditionalBreakpointHandler.java:211) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread.handleSuspendForBreakpoint(JDIThread.java:1275) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.suspend(JavaBreakpoint.java:401) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleBreakpointEvent(JavaBreakpoint.java:390) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent(JavaBreakpoint.java:308) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:186) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)    Session Data: ============= eclipse.buildId=I20130204-1400 java.version=1.7.0_09 java.vendor=Oracle Corporation BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US Command-line arguments:  -os win32 -ws win32 -arch x86_64"
"When searching for References in the workspace, a StackOverflow occurs.  What steps will reproduce the problem? 1. Open a .class file with added sources (it has the J010-Icon and shows source code) 2. Select a method: click on ""getProperty"" (it will be highlighted)  public static String getProperty( final String key ) {  ... }  3. Press Shift-Ctrl-G or select from menu: Search->References->Workspace  A window pops up, reporting a StackOverflowError.   -- Error Details -- Date: Wed Feb 20 09:04:40 CET 2013 Message: An internal error occurred during: ""Java Search"". Severity: Error Product: Eclipse SDK 3.8.0.v201206081200 (org.eclipse.sdk.ide) Plugin: org.eclipse.core.jobs Session Data: eclipse.buildId=I20120608-1200 java.version=1.6.0_35 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US Framework arguments:  -eclipse.password /home/mm/.eclipse/Eclipse.password -keyring /home/mm/.eclipse-keyring/.keyring Command-line arguments:  -os linux -ws gtk -arch x86 -eclipse.password /home/mm/.eclipse/Eclipse.password -keyring /home/mm/.eclipse-keyring/.keyring  Exception Stack Trace: java.lang.StackOverflowError 	at org.eclipse.jdt.internal.compiler.lookup.Scope.compilationUnitScope(Scope.java:508) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2524) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526) ... 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2780) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2526)"
"Build id: I20130204-1400  - configure a project for an early-access JRE8 - open class AbstractList - search for references to method add(E e)  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding$3.compare(ReferenceBinding.java:69) 	at java.util.TimSort.countRunAndMakeAscending(TimSort.java:329) 	at java.util.TimSort.sort(TimSort.java:189) 	at java.util.Arrays.sort(Arrays.java:727) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.sortMethods(ReferenceBinding.java:171) 	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.availableMethods(BinaryTypeBinding.java:265) 	at org.eclipse.jdt.internal.core.search.matching.ClassFileMatchLocator.locateMatches(ClassFileMatchLocator.java:200) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1699) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1143) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1184) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1316) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53) 	 - search for references to get(int)  java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.search.matching.ClasspathSourceDirectory.directoryTable(ClasspathSourceDirectory.java:52) 	at org.eclipse.jdt.internal.core.search.matching.ClasspathSourceDirectory.findClass(ClasspathSourceDirectory.java:109) 	at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.findClass(JavaSearchNameEnvironment.java:146) 	at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.findType(JavaSearchNameEnvironment.java:185) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:145) 	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:197) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2798) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2516) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getType(MatchLocator.java:899) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding0(MatchLocator.java:955) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding(MatchLocator.java:907) 	at org.eclipse.jdt.internal.core.search.matching.MethodLocator.matchMethod(MethodLocator.java:327) 	at org.eclipse.jdt.internal.core.search.matching.MethodLocator.resolveLevel(MethodLocator.java:664) 	at org.eclipse.jdt.internal.core.search.matching.ClassFileMatchLocator.locateMatches(ClassFileMatchLocator.java:209) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1699) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1143) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1184) 	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1316) 	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231) 	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) 	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) 	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144) 	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53) 	 Neither of the problems occurs with JRE7."
Created attachment 227361 [details] Screen shot  When you search for a JDK/JRE on Mac, we use information from the plist file to compute a name. This works fine most of the time, but if you happen to have more than one of the same version of VM installed they are added with the same name.  To make matters a bit worse, if you edit one of the JREs the wizard starts out with an error complaining that the name is already in use.  The attached screen shot shows the duplicated names for the Java 7 JREs
4.3 M5.  Add test case for bug 346230.
JSR 355 0.6.1 uses the phrase "assignment or invocation contexts" to denote situations where an expression may be a poly expression.  The introduction of section 5 has an informal discussion  where item 2 bullet 1 starts:    "Assignment contexts (including return statements, etc.) are supported"   which implies that the term "assignment context" is used loosely, to include many more syntactic constructs. I cannot find a precise definition for this.  This needs clarification, for which I could envision two alternatives: (a) give a complete positive list of syntactic contexts (b) explicitly extend the notion to all expression contexts *except for*     statement contexts.
"Created attachment 227415 [details] Project that shows the error  Error is: The method addListener(App.Command_1<Object>) in the type App.ObservableEventWithArg.Monitor is not applicable for the arguments (new App.Command_1<String>(){})  I've narrowed down the code to simple repro, see attached project. The source is:  import java.util.List;  public class App {          public interface Command_1<T> {         public void execute(T o);     }     public static class ObservableEventWithArg<T> {         public class Monitor {             public Object addListener(final Command_1<T> l) {                 return null;             }         }     }         public static class Context<T> {           public ObservableEventWithArg<String>.Monitor getSubmissionErrorEventMonitor() {               return null;           }   }       	public static void main(String[] args) { 		compileError(new Context<List<String>>()); 	}  	private static void compileError(Context context) { 		context.getSubmissionErrorEventMonitor().addListener(new Command_1<String>() {             @Override             public void execute(String o) {             }         }); 	} }"
"interface I { 	def<CTRL+SPACE> }   For Java 8, we should propose default as a choice."
Some DOM/AST Javadocs like MethodDeclaration have become quite hard to read, because they start with outdated grammar rules. The corresponding API methods are already deprecated, and the old grammar doesn't matter any more.  Any opposition to removing the outdated grammar and just leaving the current version?
"BETA_JAVA8: -----------  While the broader issue of overload resolution is the subject matter of bug 400871, we can already enable lambda/reference expressions in non-overloaded scenarios : i.e where we have just a single candidate method that is both potentially applicable and applicable under one of strict, loose or variable arity invocation. This would enable us to compile the following program which fails to compile as of now:  // --- interface I {     void foo(); } public class X {    void foo(I i) {     System.out.println(""foo"");   } 	   public static void main(String[] args) {     new X().foo(()->{}); // incorrect complaint about non-functional interface.   } } // -----  This solution would also outline how the concern raised in https://bugs.eclipse.org/bugs/show_bug.cgi?id=382701 could be readily addressed and can serve as a sketch for how the overall overload resolution problem is planned to be tackled."
BETA_JAVA8 ----------  The smoke test RunAllJava8Tests should also run RunCompilerTests, but only in 1.8 mode. We are missing some failures otherwise sometimes, which cause needless disruption to other committers.
We need UI for the Java 8 code formatter options from bug 400830.
master  No ITypeHierarchyChangedListener#typeHierarchyChanged(..) event is sent when I add a type with a parametrized supertype.  Steps: - paste into Package Explorer:  abstract class AAAList extends java.util.ArrayList<String> { } abstract class AAAListRaw extends java.util.ArrayList { }  - comment both lines - open Type Hierarchy on ArrayList - uncomment one of the lines and save the editor  => When I uncomment the type AAAListRaw, the Type Hierarchy view is updated and shows the new subtype. OTOH, when I uncomment AAAList, the TH is not refreshed.  The bug is in  org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.subtypesIncludeSupertypeOf(IType): "type.getSuperclassName()" and "type.getSuperInterfaceNames()" include the type arguments, but hasSubtypeNamed(String) expects a raw type.
BETA_JAVA8:  As outlined in https://bugs.eclipse.org/bugs/show_bug.cgi?id=400874#c12, in order to determine whether a lambda is compatible with a type T from its context, we need to compute the set of all "results expressions". These are the types of the expressions in return statements of the lambda body in all possible paths of execution.  Computing this set requires us to traverse the lambda more than once, one time each for possible target types from an overloaded call context.  The present solution adopted is from https://bugs.eclipse.org/bugs/show_bug.cgi?id=400874#c18. While this is a super clean solution, it is not also super efficient. The method LambdaExpression#isComptaibleWith is coded to minimize the copies - for example if the lambda is not even potentially applicable, we will not traverse it multiple times. Another opportunity is for isComptaibleWith to always return true, IFF we are in a INVOCATION_CONTEXT but not in an overload resolution scenario (i.e singleton potentially applicable method) - this could allow resolution to succeed where it should not, but the error will surface itself during resolve.  Even better solutions could exist - This bug is to explore them.
"BETA_JAVA8:  As a first step to supporting full blown usage of method and constructor reference in overloaded method calls, I'll use this ER to enable support for these expressions in non-overloaded calls (actually in calls which end up with just one applicable method - i.e deferring work on most specific method determination to a later date)  The following program should compile, but does not:  // ------------- interface I { 	void foo(X x); }  public class X { 	void foo(I i) {}  	void goo() {} 	 	{ 		foo(X::goo); 	} }  // --------------"
BETA_JAVA8: In bug 401610, I handled only message sends and overlooked explicit constructor calls and allocation expressions. I'll use this bug to address them.
"Consider this example:  public interface I1 { 	default void m() { } } public abstract class C1 { 	public abstract void m(); } public class C2 extends C1 implements I1 { }  I read the spec 0.6.1 part H, 8.4.8 as saying: - I1.m is inherited because C1.m does not override it from C1 - C1.m is inherited because I1.m does not override it from I1  In 8.4.8.4 none of the sentences starting with ""It is a compile-time error"" apply.  This puts the following sentence to action: ""Otherwise, the set of override-equivalent methods consists of at least one abstract method and zero or more default methods; then the class is necessarily an abstract class and is considered to inherit all the methods.""  Thus we should issue an error because C2 is not abstract. This error is not reported currently."
There are 5 failing tests on Windows and Linux for the PList parsing.  http://download.eclipse.org/eclipse/downloads/drops4/I20130225-2315/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html  The problem is that these are now Mac-specific - as they should have always been since the PList parser is only used to create Mac OSX VM installs.
"What steps will reproduce the problem? 1.  2.  3.    -- Error Details -- Date: Tue Feb 26 23:26:06 CET 2013 Message: Server returned HTTP response code: 403 for URL: http://www.junit.org/junit/javadoc/4.5/org/junit/Assert.html Severity: Error Product: Eclipse 1.5.1.20121004-1506 (org.eclipse.epp.package.jee.product) Plugin: org.eclipse.jdt.core Session Data: eclipse.buildId=M20120914-1800 java.version=1.6.0_27 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=ca_ES Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product  Exception Stack Trace: java.io.IOException: Server returned HTTP response code: 403 for URL: http://www.junit.org/junit/javadoc/4.5/org/junit/Assert.html 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1403) 	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:765) 	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037) 	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:619) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
"BETA_JAVA8:  The following triggers two errors. I believe it should be accepted:  // --------- interface I { 	Integer foo(X x); }  public class X {  	int foo(I ...i) { return 10;}  	int goo() { return 0;} 	 	{ 		foo(X::goo); 		foo(()-> {return 10;}); 	} }  // ---------- Interestingly javac accepts the first call to foo and rejects the second."
"BETA_JAVA8:  The following program should compile, but fails instead with a ClassCastException:  // --- interface I { 	Integer foo(X x); }  public class X { 	int foo(I ...i) { return 10;}  	int goo() { return 0;} 	 	{ 		foo(true ? X::goo : X::goo); 		foo(true ? x-> 1 : x->0); 	} }"
Created attachment 227640 [details] Testcase to reproduce the error  A "\n" introduced when an additional Annotation is added using rewrite
"Compiling the following code   --- import java.util.ArrayList;  public class ForLoopBug { 	public static void main(String[] argv) { 		for (long l : new ArrayList<Long>()) {} 	} } ---  With  ""Preserve unused (never read) local variables"" turned OFF (in the ""Java Compiler"" properties) leads to invalid bytecode:  --- public class ForLoopBug extends java.lang.Object  ...   public static void main(java.lang.String[]);   Code:    Stack=2, Locals=2, Args_size=1    0:   aconst_null    1:   invokeinterface #12,  1; //InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;    6:   astore_1    7:   goto    23    10:  aload_1    11:  invokeinterface #18,  1; //InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;    16:  checkcast       #24; //class java/lang/Long    19:  invokevirtual   #26; //Method java/lang/Long.longValue:()J    22:  pop    23:  aload_1    24:  invokeinterface #30,  1; //InterfaceMethod java/util/Iterator.hasNext:()Z    29:  ifne    10    32:  return   StackMapTable: number_of_entries = 2    frame_type = 252 /* append */      offset_delta = 10      locals = [ class java/util/Iterator ]    frame_type = 12 /* same */ } ---  invokevirtual at pc=19 pushes a long onto the stack (using two stack entries) but the pop at cp=22 removes just a single entry from the stack. This is also reported by the JVM bytecode verifier when the JVM tries to load that class:  --- java.lang.VerifyError: (class: ForLoopBug, method: main signature: ([Ljava/lang/String;)V) Attempt to split long or double on the stack Exception in thread ""main""  ---"
In the fix for bug 393143 we added a handmade icon for the Link With Selection icon that indicates out of sync.  We need to replace this with an official icon from our designers.  /org.eclipse.jdt.ui/icons/full/elcl16/sync_broken.gif
"BETA_JAVA8:  The following program should compile, but doesn't:  // --- interface I { 	int foo(); }  class X { 	void foo(I i) {} 	I i = ()->{ throw new RuntimeException(); }; // OK 	{ 		foo(()->{ throw new RuntimeException(); }); // Error: Bad 	} }  The lambda is value compatible, we conclude otherwise."
Large-scale review of all JLS8 DOM/AST changes.  Major topics: - removed "infos" from extra dimension APIs - added more instructions to ASTNode (and followed them) - fixed ordering of property declarations, in traversal/clone/match/etc. operations, and in implementations where regularity reduces errors - fixed @since tags (missing/redundant) - many Javadoc fixes (missing @exception UnsupportedOperationException tags, missing "added in JLS8 API", etc.) - properly implemented properties in abstract AST node types. VariableDeclaration was already in a bad shape in 3.8, but at least the necessary APIs were there and were correctly implemented. I cleaned this up, moved all fields and accessors etc. into the superclass, and added VariableDeclaration#getExtraDimensions2Property(). Added AnnotatableType#getAnnotationsProperty() and also moved all the implementations to the supertype.
"I was alerted by code in LocalDeclaration.analyzeCode() which relies on methodScope.referenceMethod() to perform ""can be static"" analysis, the latter method returning null within lambda expressions. While that particular piece of code might actually be OK, I noticed a problem with the following program:  interface I { 	void make(); } public class Nesting { 	int val; 	private I test() { 		return () -> System.out.print(val); 	} 	public void call() { test().make(); } }  When enabled, the following bogus warning is issued:   The method test() from the type Nesting can be declared as static  We should check what exactly is missing to let lambda expressions participate in this analysis."
Bug 401030 comment 9 raised a question regarding null annotations on reference expressions.  This bug to address any interaction between null analysis (w/ or w/o annotations) and reference expressions.  One thing clearly calls for action:    X x = null;   I i = x::bar;    This should report a null reference against x but doesn't.   As for null annotations on reference expressions it takes more investigation to see how and why this could be useful.  The easiest solution would be to let the target functional type completely determine any null contracts, and use only inference to see if the reference expressions meets the required null contract. I'll need to play with this a bit more to see if explicit null annotations on a reference expression will be needed in some cases.
"BETA_JAVA8:  I am unable to control+click or use F3 to jump to declaration from the method reference. Constructor reference may also be broken:  // --- interface I {     String foo(String x); }  public class X {     public  String goo(String x) {         return null;     }     void foo()     {     	X x = new X();     	I i = x::goo;  // control+click/F3 on goo.     } }"
"BETA_JAVA8:  No proposals offered at |  //----- interface I {     String foo(String x); }  public class X {     public  String longMethodName(String x) {         return null;     }     void foo()     {     	X x = new X();     	I i = x::longMethodN|     } }"
Code formatter should understand and process lambda expressions.
Method and constructor references should be understood by the formatter and processed properly.
BETA_JAVA8:  Overload resolution in Java 8 requires the same construct (lambda expression, method/constructor references) to be analyzed more than once. Any errors encountered during these steps should not be treated as an error in the program and should not be exposed to the programmer - they may at best steer the resolution in a certain direction.  Presently, we have a hackish solution in place that switches the compilation result object that accumulates the problem markers. We need a cleaner abstraction and this ER is raised for that purpose.
"BETA_JAVA8:  The following program is required to be rejected per 0.6.1 with a ""method is ambiguous"" error. Beginning 0.6.2 though, compile errors discovered during (potential and full) applicability analysis should disqualify an overload resolution candidate method and the program should compile.  // ---- interface I { 	String foo(String s1, String s2); }  interface J { 	X foo(X x1, X x2); }  public class X {  	void goo(I i) {} 	void goo(J j) {}     public static void main(String [] args) { 	new X().goo((p1, p2) -> p1 = p1 + p2);     } }   // -----  ECJ has already been ""partly"" implementing this semantics: if the body of the lambda were to be p1 + p2 instead of p1 = p1 + p2, we would not report any ambiguity - (because return expressions need to be analyzed for assignment compatibility as a part of cpmpatibility check, an erroneous return type would fail to quality)"
BETA_JAVA8:   Now that bug 399793 is closed, we should start work on ASTRewrite support for lambda expressions as a top priority.
BETA_JAVA8:  The most specific applicable overloaded method resolution in Java8 differs from  Java 7 in that it is not just a pair wise comparison of methods as in the case of Java 7. The expression that constitutes the argument must also be taken into consideration to decide which one of the parameter types is more specific.  This requires some infrastructure in the form of new methods in Expression and its subtypes.  (It can be argued this new method belongs in type binding, but if we take that route for poly expressions, we have to turn around and ask the expression itself - given you are who you are which of T and S is more specific - Given that I am proposing to implement this only in Expression)
"BETA_JAVA8:  The following program triggers an NPE: Noticing the missing semicolon after the return.  // ---- interface I { 	J foo(); }  interface J { 	void foo(); }  public class X { 	void foo(I i) {}; 	public static void main(String[] args) { 		new X().foo(() -> { return () -> { return}; }); 	} }"
"BETA_JAVA8:  The following program should compile, but does not and fails with: ""The method foo(I) in the type X is not applicable ..."" message  // ---  interface I { 	J foo(); }  interface J { 	void foo(); }  public class X { 	void foo(I i) {}; 	public static void main(String[] args) { 		new X().foo(() -> { class local { void foo() { return; }} return () -> { return;}; }); 	} } // ---  The return from the inner classes is confused to be a return from the lambda. However the return from the lambda that forms the return expression of the first lambda is handled properly."
No time to investigate recent changes, but my local test builds are now failing with the following.     buildPlatformDoc:      [copy] Copying 1 file to /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv  BUILD FAILED /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/buildDoc.xml:12: The following error occurred while executing this line: /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/buildDoc.xml:105: Either token or a nested replacefilter must be specified  Total time: 0 seconds  An error has occurred. See the log file /data/shared/eclipse/builds/4I/master/gitCache/eclipse.platform.releng.aggregator/eclipse.platform.common/bundles/org.eclipse.jdt.doc.isv/workspace/.metadata/.log.
When referencing an enum containing constants that override methods,the autocompletion suggestions for that enum don't always contain all enum fields, even with specific typing to narrow suggestions.  Upgraded to Juno from Helios - Helios did not exhibit this behavior.
"BETA_JAVA8:  The following program triggers an AIOOB:  interface I { 	void foo(X x); }  interface J { 	void foo(X x); }  abstract class Y { 	abstract void foo(); } public class X extends Y {  	void f(I i) {} 	void f(J j) {} 	 	void foo() { 	} 	 	public static void main(String[] args) { 		f(super::foo); 	} }"
"BETA_JAVA8:  The following program should fail to compile, but compiles successfully:  // ---- interface I { 	void foo(X x); }  public class X { 	void foo() { 	} 	 	public void main(String[] args) { 		I i = @Marker X::foo; 	} }   The compiler silently acepts the undefined annotation Marker"
"In LambdaExpressions, parameters of type VariableDeclarationFragment are missing a source range. The AST view shows such nodes with a red background color.  Example:  package jsr335;  public class SpecExamples335 { 	public static interface StringToInt { 		int stoi(String s); 	} 	public static interface ReduceInt { 		int reduce(int a, int b); 	} 	 	void foo(StringToInt s) { } 	void bar(ReduceInt r) { } 	 	void bar() { 		foo(s -> s.length()); 		foo((s) -> s.length()); 		foo((String s) -> s.length()); //SingleVariableDeclaration is OK 		 		bar((x, y) -> x+y); 		bar((int x, int y) -> x+y); //SingleVariableDeclarations are OK 	} }"
"ASTs before JLS8 must not try to create nodes that are only allowed in JLS8.  Hint: Open a call hierarchy on ASTNode#unsupportedIn2_3_4() and make sure all accesses are properly protected. You may want to set ""Search Scope > Project"" in the view menu.   E.g. LambdaExpression nodes:  package jsr335; public class RunnableTest { 	Runnable r = () -> System.out.println(""hi""); }  java.lang.UnsupportedOperationException: Operation only supported in JLS8 and later AST 	at org.eclipse.jdt.core.dom.ASTNode.unsupportedIn2_3_4(ASTNode.java:1906) 	at org.eclipse.jdt.core.dom.LambdaExpression.<init>(LambdaExpression.java:127) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2144) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1724) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3137) 	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3026) 	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:417) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2809) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1329) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
LambdaExpression#resolveTypeBinding() (inherited from Expression) always returns null. E.g. in examples from bug 402665 comment 0.
Created attachment 228095 [details] jdt.core.patch  eclipse.jdt.core R3_8_maintenance branch pom versions are out of sync. Attached patch updates the versions.
"BETA_JAVA8:  Java 8 allows code carrying methods in interfaces in the form of static methods (not inherited by subtypes even though public; They can be accessed only  statically using the declaring interface's type reference.) and default instance methods.  There are various issues in completing on these method names as shown by the snippet below:  | indicates cursor position.  // --- interface I { 	static void staticMethod() {} 	default void defaultMethod() { 		stat|  // no proposals here 	} }  public class X implements I { 	public void foo(I i) { 		i.defaultMethod(); // proposal for defaultMethod offered here 		I.stat|  // no proposals here. 		this.d| // no proposals here. 	} }"
"BETA_JAVA8:  Attempting to format the following program leaves the program unchanged both the classes and interface parts:  // --- class I { 	 int id(int x,      int y)  	{ 		return 0; 	} 	 	static void foo(int x      ,      int    y)  	{ 		 	} }  interface J { 	default int id(int x,      int y)  	{ 		return 0; 	} 	 	static void foo(int x      ,      int    y)  	{ 		 	} }"
"BETA_JAVA8:  The following program fails to get formatted properly. If you change the intersection type cast to a normal cast, all is well:  // ---- import java.io.Serializable; interface I { 	void doit(); } class X { 	void foo(   int x   ,     int   y ) {} 	I i = (I       &       Serializable   ) () -> {}; }"
BETA_JAVA8:  There is an abstraction/modeling problem in that ReferenceExpression implements ReferenceContext (through its parent FunctionalExpression) Only LambdaExpression needs to implement ReferenceContext to trap errors and signal incompatibility during applicability check phase of overload resolution.  ReferenceExpressions do not introduce a scope and their congruence with the target type is limited to there being a single compile time declaration with suitable return types and hence these need/should not implement ReferenceContext.  Patch will follow shortly.
BETA_JAVA8:  We need formatter support for JSR308 style annotations.
"Why would we not issue warnings on the two lines called out ??  // --- public class NPEonCast {  	private static void occasionallyThrowException() throws Exception { 		if ((System.currentTimeMillis() & 1L) != 0L) 			throw new Exception(); 	}  	private static void open() throws Exception { 		occasionallyThrowException(); 	}  	private static void close() throws Exception { 		occasionallyThrowException(); 	}  	public static void main(String s[]) { 		Exception exc = null; 		if (exc == null) 			; 		try { 			open(); 			// do more things 		} 		catch (Exception e) { 			if (exc == null) // no warning here ?? 				; 		} 		finally { 			try { 				close(); 			} 			catch (Exception e) { 				if (exc == null) // No warning here ?? 					exc = e; 			} 		} 	} }"
Backporting fix for bug 327193 to 3.6.2+.
"I20130311-2000  Have this detail formatter for org.eclipse.core.internal.registry.ConfigurationElementHandle:  return ""namespace: "" + getNamespace() + ""\nname: "" + getName() + ""\nattrs: "" + java.util.Arrays.asList(getAttributeNames());  Select such an element in the Variables view. My scenario was: - breakpoint in SearchDialog.getPreferredPageIndex() - in debug target: open Search dialog - step to SearchPageDescriptor descriptor - expand descriptor in Variables view and select child fElement   Error dialog:  java.util.EmptyStackException 	at java.util.Stack.peek(Stack.java:113) 	at java.util.Stack.pop(Stack.java:95) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.pop(Interpreter.java:156) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.Instruction.popValue(Instruction.java:109) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.BinaryOperator.executeBinary(BinaryOperator.java:83) 	at org.eclipse.jdt.internal.debug.eval.ast.instructions.BinaryOperator.execute(BinaryOperator.java:40) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.execute(Interpreter.java:66) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable$1EvaluationRunnable.run(ASTEvaluationEngine.java:684) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread.runEvaluation(JDIThread.java:765) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable.run(ASTEvaluationEngine.java:734) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)  Also found this in the log:  java.util.EmptyStackException 	at java.util.Stack.peek(Stack.java:113) 	at java.util.Stack.pop(Stack.java:95) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.storeInstruction(ASTInstructionCompiler.java:300) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.endVisit(ASTInstructionCompiler.java:695) 	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:138) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2562) 	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:566) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:504) 	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:465) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getCompiledExpression(JavaDetailFormattersManager.java:389) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.resolveFormatter(JavaDetailFormattersManager.java:154) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.access$1(JavaDetailFormattersManager.java:139) 	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager$1.run(JavaDetailFormattersManager.java:134) 	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"1.Create a class:   public class C1 { 	String s;   }  2. Hover on 'String' and click on the link for 'java' package.  The message shown in ""Note: The attached Javadoc could not be retrieved as the specified Javadoc location is either wrong or currently not accessible.""  The javadoc location is specified correctly and is accessible but for 'java' there is no javadoc available and hence no content can be retrieved.  The message indicates a problem with the url even though it is correct.  Cases for a wrong/Inaccessible url and a url where no content is available is not handled differently."
This bug is the parent of bug 403000, bug 403004, bug 403016 and bug 403023.
"from bug 382069 comment 10:  > class Y { > 	@Nullable String str; > 	int foo(@Nullable String str2) { > 		int i; > 		assert str2 != null; > 		i = str2.length();	// No warning > 		 > 		org.junit.Assert.assertNotNull(str2); > 		i = str2.length();	// No warning > 		 > 		org.junit.Assert.assertNotNull(str); > 		i = str.length();	// No warning >  > 		assert this.str != null; > 		i = str.length(); // Potential NPE warning >  > 		return i; > 	} > } >  > Why is the assert not having any effect on the nullable field?  Answer: I haven't yet integrated the conditional analysis of 'assert' with the syntactical analysis for @Nullable fields. I.e., we must combine bug 325342 with bug 383368."
"Created attachment 228323 [details] ASTConverter18Tests.java test case to reproduce the issue  Annotations are not converted (and displayed) correctly in case of annotations on inner classes.  Test program to reproduce:  import java.lang.annotation.ElementType; import java.lang.annotation.Target; public class X  { 	void foo1(@Marker X this) {} 	public class Y {		  	    void foo(@Marker X.@Marker Y this) {} 	} } @Target(ElementType.TYPE_USE)	 @interface Marker {}   OR   Add the attached test case to ASTConverter18Tests.java and the test will fail at the last assertion"
Bug 400761 has introduced some more diagnostics for NPE due auto-unboxing. This solution should be checked for completeness in two dimensions: - are all relevant AST nodes covered? - does the analysis create correct results within (nested) control structures that demand deferred checking? Hopefully, this will also simplify the code a bit, by reducing code duplication.
4.3 M6.  IJavaElement.getAttachedJavadoc(IProgressMonitor) should throw exception if base URL is wrong.  See bug 403036 comment 1 for details.  A point  to consider is a potential performance impact.
"As a result, when null analysis is enabled, the following code has one compilation error where there is none when not enabled:  import java.lang.annotation.ElementType; import java.lang.annotation.Target;  public class Test {}  class X { 	class Y { 		public void foo( @A X. @B Y this) {} 	} } @Target(value={ElementType.TYPE_USE}) @interface A {} @Target(value={ElementType.TYPE_USE}) @interface B {}  The result is a ParameterizedTypeBinding when null analysis is enabled and MemberTypeBinding otherwise for the explicit receiver type."
There are 3 failing tests in the M6 candidate: http://download.eclipse.org/eclipse/downloads/drops4/I20130313-2000/testResults.php  They have failed for the last three builds. It appears that one of the new tests added for bug 403028 forgets to clean up after itself and leaves a dead launch in the view, which leaks an instruction pointer and prevents the watch expression from updating (because the debug selection does not change).  This is a problem only in the tests.  The offending test is: ConditionalBreakpointsWithGenerics#testBreakpointWithGenericCondition4
The latest spec doesn't allow modifiers on explicit 'this' parameters:  FormalParameterOrReceiverDecls: Type [Identifier .] this [, FormalParameterDecls] FormalParameterDecls  The javac allows final but rejects static. But as per the spec, all modifiers should be rejected on receiver params.
"Inspect example from bug 402665 in ASTView with AST Level 4:  package jsr335;  public class SpecExamples335 { 	public static interface StringToInt { 		int stoi(String s); 	} 	public static interface ReduceInt { 		int reduce(int a, int b); 	} 	 	void foo(StringToInt s) { } 	void bar(ReduceInt r) { } 	 	void bar() { 		foo(s -> s.length()); 		foo((s) -> s.length()); 		foo((String s) -> s.length()); 		 		bar((x, y) -> x+y); 		bar((int x, int y) -> x+y); 	} }  When I drill down to the argument of ""foo(s -> s.length())"", I get this exception:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.LambdaExpression cannot be cast to org.eclipse.jdt.internal.compiler.ast.Literal 	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:735) 	at org.eclipse.jdt.core.dom.Expression.resolveTypeBinding(Expression.java:113) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:112) ..."
"BETA_JAVA8:  The following program triggers an NPE:  // --- //import java.util.Map; import java.lang.annotation.*;  public class X { 	void foo(Map<@Marker ? super @Marker Object, @Marker ? extends @Marker String> m){}    void goo(Map<@Marker ? extends @Marker Object, @Marker ? super @Marker String> m){} }  @Target(ElementType.TYPE_USE) @interface Marker { 	 }  If the import is uncommented, it compiles OK."
In Following test case too much frames gets dropped without need:  1. In the test program (TestHCR.java) set a breakpoint in TestHCR.run() 2. After the breakpoint gets hit, change TestHCR.run() (e.g. add new println) 3. Save the file.  Now, 2 frames are dropped and we are at the start of TestHCR.InnerClass.run()  even though we should be at the start of TestHCR.run() (only one frame should have been dropped, not two).  The reason for this behavior is that both methods TestHCR.run() and TestHCR.InnerClass.run() have the same name and in JavaHotCodeReplaceManager.getAffectedFrame(), CompilationUnitDelta.hasChanged() and MethodSearchVisitor.setTargetMethod() only name of the method gets checked without checking to which class the method belongs.   I've made a short bugfix (see MethodSearchVisitor.java, JavaHotCodeReplaceManager.java, CompilationUnitDelta.java in the attachment) which works for me but am not sure, if this is enought in general.
"BETA_JAVA8:  The following program is incorrectly rejected with three bogus syntax errors:  // --- import java.util.List;  public class X { 	void foo(List<String> @Marker ... ls) {} } @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker { 	 }  Fix is trivial and will follow shortly."
Created attachment 228586 [details] Code that reproduces the bug  Using a @Nullable enum value in a switch statement does not trigger the "Potential null pointer access" warning that it should, potentially leading to runtime NullPointerExceptions. The warning appears correctly when switching on a @Nullable String or Integer object (the latter, presumably, because of the auto-unboxing operation).  I've attached example code that, for me, shows an error when trying to switch on a @Nullable String value, but does not show errors when switching on @Nullable enum values.
"Created attachment 228601 [details] Screen shot of blank JRE tab in External Tools Config dialog  I recently upgraded to Eclipse Juno on my Windows XP machine:  Eclipse Java EE IDE for Web Developers. Version: Juno Service Release 2 Build id: 20130225-0426  When I open the External Tools Configurations dialog and try to select one of my Ant Build launch configurations, this message appears at the top of the dialog:  ""[JRE]: Unable to resolve JRE: jdk1.5.0_19 (Standard VM)"".  I try navigating to the JRE tab to fix this, but the UI of the tab is totally blank (see attached screen shot).  I also get a ""Problem Occurred"" pop-up dialog with the text ""An error has occurred.  See error log for more details.  java.lang.NullPointerException.""  I've tried closing and reopening the External Tools Configuration dialog, and running Eclipse with -clean, but the JRE tab is always blank now, so I can't figure out how to get into a state where I could designate the correct JRE.  Here is the full stack trace from the log file:  java.lang.NullPointerException 	at org.eclipse.core.runtime.Path.append(Path.java:261) 	at org.eclipse.jdt.launching.JavaRuntime.newJREContainerPath(JavaRuntime.java:1915) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.selectJRE(JavaJRETab.java:417) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.updateJREFromConfig(JavaJRETab.java:361) 	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab.initializeFrom(JavaJRETab.java:164) 	at org.eclipse.ant.internal.ui.launchConfigurations.AntJRETab.initializeFrom(AntJRETab.java:160) 	at org.eclipse.debug.ui.AbstractLaunchConfigurationTabGroup.initializeFrom(AbstractLaunchConfigurationTabGroup.java:86) 	at org.eclipse.ant.internal.ui.launchConfigurations.AntTabGroup.initializeFrom(AntTabGroup.java:50) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupWrapper.initializeFrom(LaunchConfigurationTabGroupWrapper.java:194) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.displayInstanceTabs(LaunchConfigurationTabGroupViewer.java:753) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer$8.run(LaunchConfigurationTabGroupViewer.java:624) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.inputChanged(LaunchConfigurationTabGroupViewer.java:641) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput0(LaunchConfigurationTabGroupViewer.java:603) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput(LaunchConfigurationTabGroupViewer.java:579) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:941) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog$3.selectionChanged(LaunchConfigurationsDialog.java:560) 	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:888) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49) 	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175) 	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:886) 	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1226) 	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1251) 	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:262) 	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:256) 	at org.eclipse.jface.util.OpenStrategy$3.run(OpenStrategy.java:433) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1132) 	at org.eclipse.debug.ui.DebugUITools$2.run(DebugUITools.java:600) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:608) 	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:542) 	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:81) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4169) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3758) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1053) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:942) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 	at java.lang.reflect.Method.invoke(Unknown Source) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438) !SESSION 2013-03-18 17:10:10.639 ----------------------------------------------- eclipse.buildId=M20130204-1200 java.version=1.6.0_31 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.jee.product -clean  Please advise if I need to provide any more details.  Thank you, Jennifer"
Created attachment 228605 [details] Failure List  Attached list of failures for b81.
For javadoc written like this:   /**    * Initialization for adminRatingScaleController.    * @throws AjaxServiceException    *           when AjaxServiceException    */  The output of ASTNode.toString() makes it "@throws AjaxServiceExceptionwhen AjaxServiceException", missing an important whitespace.    The below is my fix for your information (diff to master HEAD)                         // assume text elements include necessary leading and trailing whitespace                         // but Name, MemberRef, MethodRef, and nested TagElement do not include white space                         boolean currentIncludesWhiteSpace = (e instanceof TextElement); +                       if ((TextElement) e).getText.charAt(0) != ' ') { +                               currentIncludesWhiteSpace = false; +                       }                         if (previousRequiresNewLine && currentIncludesWhiteSpace) {                                 this.buffer.append("\n * ");//$NON-NLS-1$                         }  For the javadoc I'm working on, the TextElement does not have leading whitespace, so the assuming failed.
BETA_JAVA8:  At the moment, we have been tagging Java 8 API items (mostly IProblems) with "@since 3.9"  This needs to be adjusted to be "@since 3.9 BETA_JAVA8"  We don't want to use 3.9.1 since we want to be able to distinguish between what gets added in 3.9.1 in normal course and what got expressly added for Java 8 support.
Section 18.5 distinguishes Invocation Applicability Inference (18.5.1) from Invocation Type Inference (18.5.2).  Here the second phase is to reuse the bound set of the first phase, but any results of resolution, notably any instantiations have to be dropped and re-computed with more constraints in the lot.
"As part of the work for upgrading our test infrastructure to use 8b81, I had to modify org.eclipse.jdt.core.tests.compiler.regression.InterfaceMethodsTest.testSuperCall2 to be:  // --- import java.util.*; import java.util.stream.Stream; public abstract class X<E> implements OrderedSet<E> { 	@Override 	public Stream<E> stream() { 		return List.super.stream(); // List is not a direct super interface 	} 	@Override 	public Stream<E> parallelStream() { return OrderedSet.super.parallelStream();}    class Inner { 		public Stream<E> stream() { 			return OrderedSet.super.stream(); // not a super interface of the direct enclosing class 		} 	} 	@Override 	public boolean add(E o) { 		OrderedSet.super.add(o); // target not a default method 	} 	X() { 		OrderedSet.super(); // not applicable for super ctor call 	} } interface OrderedSet<E> extends List<E>, Set<E> { 	@Override 	boolean add(E o); 	@Override    default Spliterator<E> spliterator() { return List.super.spliterator(); } } // --  This program generates 4 errors when compiled with javac 8b81. Eclipse reports the same 4 errors, but in addition also reports againt class X an error about there being unrelated default methods spliterator().  This is suspect since OrderedSet's implementation has replaced List and Set's versions and these should be out of reckoning altogether.  See that there is no error reported against OrderedSet itself regarding duplicate unrelated defaults.  Strangely, the unmodified method must have had the same issue - but we never reported an error earlier."
"BETA_JAVA8:   There is no effect seen while formatting this program:  // --- public class X { 	void foo(@Marker X this) {} 	class Y { 		Y(@Marker X X.this) {} 		void foo(X.Y this) {} 	} }  @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker { 	 }  This could be due to assumptions that argument name is an TokenNameIdentifier, which is not true for receiver parameters."
Render TYPE_USE annotations in Javadoc hover/view.
Handle annotations on extra dimensions in the AST.  For jsr308, a new extraDimensions2 property has been added to MethodDeclaration and to the two concrete VariableDeclaration types. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.  File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
Replace usages of MethodDeclaration#thrownExceptions() in the AST.  For jsr308, MethodDeclaration's thrownExceptions property has been replaced with thrownExceptionTypes. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.  File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
Created attachment 228756 [details] patch.eclipse.jdt.core.binaries.R3_8_maintenance  To be applied right after I20130326-0800
Created attachment 228759 [details] patch.eclipse.jdt.R3_8_maintenance  To be applied right after I20130326-0800
This probably needs no additional rewrite work. But needs to be investigated and new tests can be added.
See, e.g., GenericTypeTest.test0805():   String s = foo(numbers, floats);    During Invocation Applicability Inference we find that T = Number[], but during Invocation Type Inference we find no solution matching the expected type String. This leads the initial implementation to report:    "The method foo(T, T) in the type X is not applicable for the arguments (Number[], Float[])" where we expect:   "Type mismatch: cannot convert from Number[] to String"    This can be rectified by falling back to the provisional result. I have a small correction in this regard, which will later need careful integration with overload resolution.
For these DefaultCodeFormatterConstants options, the value NEXT_LINE_ON_WRAP is not implemented:  FORMATTER_BRACE_POSITION_FOR_BLOCK_IN_CASE FORMATTER_BRACE_POSITION_FOR_SWITCH FORMATTER_BRACE_POSITION_FOR_ARRAY_INITIALIZER FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY  This can be seen in the Code Formatter preference dialog when you set "Line Wrapping > Maximum line width" to 10 and then play on the Braces tab.
Created attachment 228918 [details] wrong uploaded file  A lot of nested try-catch-finally-blocks leads to unrunnable Java byte code (JDT for Java 7). See the attached Java file.  When I compile the same code with javac (Java 7 Update 17) the Java byte code is valid and runnable.  JDT for Java 6 has also no problem with the attached Java file.
Since JUnit 4.11, junit.framework.Assert is deprecated. This creates a bunch of warnings in the test projects.  AFAIK, the goal is still to keep the tests runnable with Java 1.4 / JUnit 3, so the fix is to: - just drop the "Assert." if it occurs in a subclass of TestCase - replace the "Assert." with "junit.framework.TestCase."
Created attachment 228982 [details] Fix this bug by appending interval whitespaces  Please look at an expression like this:  threadMessagePrefix + "Processing " + ++i + " of " + total + "..."  ASTRewriteFlattener prints it as:   threadMessagePrefix + "Processing "+++i+" of "+total+"..."  Code is broken because '+++' is an invalid operator.
BETA_JAVA8  Deprecate AST.JLS4.
The 'step into selection' action lives in a different menu to the 'step into' action in the 'run' menu. This makes it difficult to discover for those are looking in the same place as 'step into'.
The DOM AST APIs are pretty type safe. ASTNode#checkNewChild(..) is used everywhere to ensure that new nodes are of the right type.  ASTRewrite is currently unsafe, since it doesn't do the type tests in ASTRewrite#set(..) and in ListRewriteEvent#insert(..) etc.  These tests should be added, so that type errors can be detected early. The API Javadoc already tell that an IllegalArgumentException is thrown "if the described modification is invalid".  However, before releasing the fix, we need to check fallout from bad client code that was accepted before. If it turns out this happens everywhere, then we maybe have to deprecate ASTRewrite.create(AST) and only ensure sanity in a new creation method.
"Here is the original source code:  public class A { 	public int i = 0; 	public void m(B b) { 		i++; 	}	 }  public class B { 	public void m() {		 	} }  When method m of A is moved to B by applying move-refactoring, Eclipse error occurs saying that ""A method with name 'm' already exists in the target type 'B'. But it should not be an error since method m will have different parameters in B:  public class B { 	public void m() {		 	}  	public void m(A a) { 		a.i++; 	} }"
"Example:  package jsr308.bug; import java.lang.annotation.*; public class AnnotatedQualifiedType { 	@Target(ElementType.TYPE_USE) 	@Retention(RetentionPolicy.RUNTIME) 	@Documented 	static @interface NonNull { }  	java.io.@NonNull IOException foo( 			java.io.@NonNull FileNotFoundException arg) 			throws java.io.@NonNull EOFException { 		try { 		} catch (java.io.@NonNull IOError e) { 		} 		return null; 	} }  The ""java.io.@NonNull XyException"" are all represented like this in the AST:  SimpleType                         ""java.io.@NonNull XyException"" + annotations: MarkerAnnotation            ""@NonNull"" + name: QualifiedName              ""java.io.@NonNull XyException""         + qualifier: QualifiedName ""java.io""         + name: SimpleName                          ""XyException""  This is incorrect. The first QualifiedName's source range cannot contain the ""@NonNull"". In the current API, the legal representation would be:  QualifiedType                       ""java.io.@NonNull XyException"" + qualifier: SimpleType             ""java.io""              + annotations: <empty>              + name: QualifiedName  ""java.io"" + annotations: MarkerAnnotation             ""@NonNull"" + name: SimpleName                                   ""XyException""  Alternatively, the first qualifier could also be a QualifiedType containing a SimpleType and a SimpleName. Both of these representations have the problem that the ""qualifier"" property of a QualifiedType is a Type, but ""java.io"" is not a type.  I don't have a good solution right now."
We are using Execution Environment Descriptions http://wiki.eclipse.org/Execution_Environment_Descriptions to contribute custom Java VM installations to eclipse. VM has ee.language.level=1.4 and eclipse IDE decides that it has support for JAXP for some reason. This is needed to evaluating VM system properties by executing special class org.eclipse.jdt.internal.launching.support.SystemProperties used for retrieving system information for the VM itself. This class uses JAXP which is NOT mandatory functionality for jdk 1.4. As result all features of eclipse which use these system properties doesn't work. New property should be added to the execution environment descriptions which informs eclipse to use the legacy org.eclipse.jdt.internal.launching.support.LegacySystemProperties instead of detecting XML support by language level.
Created attachment 229190 [details] jdt.core.patch  Parse error in pom file causing Maven to be unable to parse due to commit:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/diff/pom.xml?h=R3_8_maintenance&id=acb602ad4eb430f5d9505052936cd13d1f359884
As of 0.6.2 para 15.12.3 contains this:  " If the method invocation has, before the left parenthesis, the form ClassName TypeName . super . NonWildTypeArgumentsopt Identifier, then:     [...]     Otherwise, if the TypeName denotes an interface, let T be the type declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (9.4.1) the compile-time declaration from a direct superclass or direct superinterface of T."      This rule is yet unimplemented.
"BETA_JAVA8 follow-up of bug 382721:  The following program is currently accepted (except for the expected ""Missing code implementation in the compiler"" during code-gen):  public class EffectivelyFinalInLoop { 	void executeLater(Runnable r) { /*...*/ } 	void test() { 		int n; 		for (int i=0; i<3; i++) { 			n=i; 			executeLater(()-> System.out.println(n)); 		} 	} }  The analysis incorrectly believes that n is assigned only once.  I noticed this by analogy to definite-assignment analysis: The error duplicateInitializationOfFinalLocal() is triggered from 3 locations: - SingleNameReference.analyseAssignment() - FinallyFlowContext.complainOnDeferredChecks() - LoopingFlowContext.complainOnDeferredFinalChecks()  Of these locations only the first resets IsEffectivelyFinal, whereas all of them should consider to do so."
Created attachment 229203 [details] Patch file where the test case is mentioned. Can be applied to ASTRewritingExpressionTest.java  Expected Output: String myString = (@Annot String) myObject;\n"); Actual Output  : String myString = ( @AnnotString) myObject
Bug 391376 solves a problem that should actually be handled in the VM, see    http://bugs.sun.com/view_bug.do?bug_id=8009130  Once that bug is fixed we should revisit our strategy for generating bridges.
"Created attachment 229243 [details] Test case to reproduce  For the attached test case, JDT gives an NPE (although it shows an error message as well)   Stack shown below:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference.resolveType(QualifiedSuperReference.java:47) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:87) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:275) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:505) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1198) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:565) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"After upgrading to 4.2.2, after a few hours of usage of Eclipse IDE, entries under ""Run Configuration..."" are suddenly not available any more. None of the usual entries like ""Run Java Application"", ""Run JUnit Test"", ... appear, not on the project-tree and not in the JAva Editor as well. Also keyboard shortcuts like F11 and SHIFT-F11 stop working, they do not start the currently opened context any more, but always the last executed one, i.e. if I open another app, they still start the previously executed one.  Restarting Eclipse helps, but only for a while until it reappears.  I could not yet attribute it to something specific, only that it consistently happens at least after a few hours of usage on two different installations of Eclipse. Both were updated from 4.2 to 4.2.1 and then to 4.2.2.  Log contains a number of exceptions, but I am not sure which ones are directly related:  !ENTRY org.eclipse.ltk.core.refactoring 4 10009 2013-04-02 15:15:10.416 !MESSAGE Participant 'org.eclipse.jdt.debug.refactoring.launchConfiguration.typeMove' removed due to the following exception !STACK 1 Java Model Exception: Java Model Status [[Working copy] MyTextTest.java [in com.c.timesheet [in src [in TimesheetHelper]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:495) 	at org.eclipse.jdt.internal.core.Openable.getUnderlyingResource(Openable.java:343) 	at org.eclipse.jdt.internal.core.CompilationUnit.getUnderlyingResource(CompilationUnit.java:943) 	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:226) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:104) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:137) 	at org.eclipse.jdt.internal.debug.core.refactoring.LaunchConfigurationProjectMainTypeChange.perform(LaunchConfigurationProjectMainTypeChange.java:159) 	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306) 	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) !SUBENTRY 1 org.eclipse.jdt.core 4 969 2013-04-02 15:15:10.418 !MESSAGE [Working copy] MyTextTest.java [in com.compuware.timesheet [in src [in TimesheetHelper]]] does not exist    !ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2013-04-02 15:15:10.531 !MESSAGE Internal Error !STACK 1 Java Model Exception: Java Model Status [MyTextTest.java [in com.c.timesheet [in src [in TimesheetHelper]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:495) 	at org.eclipse.jdt.internal.core.Openable.getUnderlyingResource(Openable.java:343) 	at org.eclipse.jdt.internal.core.CompilationUnit.getUnderlyingResource(CompilationUnit.java:943) 	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:226) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:104) 	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:137) 	at org.eclipse.jdt.internal.debug.core.refactoring.LaunchConfigurationProjectMainTypeChange.perform(LaunchConfigurationProjectMainTypeChange.java:159) 	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306) 	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92) 	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) !SUBENTRY 1 org.eclipse.jdt.core 4 969 2013-04-02 15:15:10.531 !MESSAGE MyTextTest.java [in com.compuware.timesheet [in src [in TimesheetHelper]]] does not exist    Conflicting handlers for org.eclipse.debug.ui.commands.eof: {org.eclipse.debug.internal.ui.views.console.ProcessConsolePageParticipant$EOFHandler@27d399e8} vs {org.eclipse.debug.internal.ui.views.console.ProcessConsolePageParticipant$EOFHandler@27d399e8}   !ENTRY org.eclipse.equinox.event 4 0 2013-04-02 15:57:42.756 !MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/ElementContainer/selectedElement/SET] to handler org.eclipse.e4.ui.services.internal.events.UIEventHandler@6eef7d8f !STACK 0 java.lang.ClassCastException: java.lang.Object cannot be cast to org.eclipse.e4.core.commands.EHandlerService 	at org.eclipse.ui.internal.menus.MenuHelper$1.evaluate(MenuHelper.java:240) 	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.isVisible(ContributionsAnalyzer.java:248) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.computeVisibility(ToolBarContributionRecord.java:114) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.updateVisibility(ToolBarContributionRecord.java:68) 	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer$6.changed(ToolBarManagerRenderer.java:352) 	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:328) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:342) 	at org.eclipse.e4.core.internal.contexts.EclipseContext$1.changed(EclipseContext.java:738) 	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:328) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:342) 	at org.eclipse.e4.core.internal.contexts.EclipseContext.activate(EclipseContext.java:625) 	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.switchPerspective(PartServiceImpl.java:503) 	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:124) 	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:67) 	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:41) 	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:180) 	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:150) 	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4687) 	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:187) 	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38) 	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197) 	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197) 	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1) 	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) 	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) 	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135) 	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78) 	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39) 	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:80) 	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:58) 	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374) 	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135) 	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1) 	at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:3558) 	at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:2674) 	at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:2614) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager.switchToPerspective(PerspectiveManager.java:367) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$5.runInUIThread(PerspectiveManager.java:446) 	at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$1.run(PerspectiveManager.java:211) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1053) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:942) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)"
Preferences>Java>Debug>Open popup when suspended on exception doesn't work. Even if it is checked, ExceptionInspector won't popup.  Maybe because... It is stored at org.eclipse.jdt.internal.debug.ui.JavaDebugPreferencePage.performOk() with JDIDebugUIPlugin.getDefault().getPreferenceStore(). So I can see it in org.eclipse.jdt.debug.ui.prefs under .metadata. However, org.eclipse.jdt.internal.debug.ui.breakpoints.ExceptionInspector.ExceptionInspector() refers JDIDebugPlugin.getUniqueIdentifier(). I cannot see the option in org.eclipse.jdt.debug.prefs of course. (Sorry if I misunderstood)
"BETA_JAVA8  ""Correct Indentation"" doesn't indent a default method. It even removes the indentation here:  public interface DefaultMethod { 	void bar();  	default void foo() { 		System.out.println(""foo""); 	} }  The code formatter is fine."
Couple of cases being:  AST.JLS4 MethodDeclaration@thrownExceptions()  The former should be replaced with JLS8 and the code using thrownExceptions() should be changed to use thrownExceptionTypes().
Up until M6 given source text such as (@ is the cursor position)       @xxxx  it was possible to insert type       if (yyyy != null) {@xxxx  then new line to get       if (yyyy != null) {         xxxx      }  Now (in M6) and in eclipse-SDK-I20130402-0800-win32.zip we get       if (yyyy != null) {               }xxxx  Super-irritating.
Created attachment 229331 [details] jdt.core.binaries.patch  The parent group for one of the bundles does not match the group of it's actual parent. Attached patch updates the bundle pom to match.
Add a debug option to verify proper nesting of ASTNodes according to ASTParser#setKind(int):   * Source ranges nest properly: the source range for a child is always  * within the source range of its parent, and the source ranges of sibling  * nodes never overlap.  This should avoid issues like bug 404489 and bug 391894 comment 4 in the future.
After bug 399792 is released, AST rewrite support should be added to casts with intersection types.
master (from bug 405015)  IJavaProject#findType(String) should never find a secondary type. But if you call this methods with "x.y.z.test13outer" for the CU below, then you get an IType iff the CU is open in a Java editor.  -------------------------------------- package x.y.z;  public interface test13 { }  /**  * @noreference  */ interface test13outer {} --------------------------------------  The problem is that "considerSecondaryTypes" is dropped in org.eclipse.jdt.internal.core.NameLookup.findType(String, String, boolean, int, boolean, boolean, boolean, IProgressMonitor) line 662, and eventually, seekTypesInWorkingCopies(..) finds the secondary type.
When the search engine is primed (as part of calling JavaCore.initializeAfterLoad(IProgressMonitor)) then it populates the index manager based on the information returned from IndexManager#computeIndexLocation(IPath containerPath).  If the underlying index is a pre-built index but it has been deleted from the file-system, then the index is re-created in the workspace metadata and not in the location specified by the INDEX_LOCATION_ATTRIBUTE_NAME classpath attribute.  This is because search has no concept of the classpath containers - it simply knows a list of project and the corresponding archive files.  In JavaCore.initializeAfterLoad(IProgressMonitor) the call to refresh external archives (which populates the index manager with the correct classpath attribute information) happens after the search occurs.  Since the index has already been built from the search call then it ends up being used.  There are two ways to fix this:  1) In JavaCore.initializeAfterLoad(IProgressMonitor), move the call to refresh the archives to happen BEFORE the search engine is primed.  2) In IndexManager#computeIndexLocation(IPath containerPath, final URL newIndexURL) added via bug 395897, if the existing URL is different from the new URL then the index needs to be rebuilt after it is removed.  I think fix 1 makes more sense as, ideally, you want to know the latest archive state before a search is done.  This approach also ensures that the indexer manager is doing less work
BETA_JAVA8:  This ER will be used to implement the infrastructure support for generating code for lambda expressions and method references.  Among other things:  We need to add capability to generate:   - ConstantPool sections for MethodHandles, MethodType, InvokeDynamic   - Attribute section for BootStrapMethods  - Adding of InnerClass reference for MethodHandles.Lookup  The patch at https://bugs.eclipse.org/bugs/show_bug.cgi?id=400875 has support for these. The infrastructure portion needs to be separated out, reviewed and released.
BETA_JAVA8:  This ER will be used to implement/track generation of code for stateless lambda's.
BETA_JAVA8:  This ER will be used to implement/track code generation for lambda expressions that refer to effectively final variables or fields of its enclosing class.
BETA_JAVA8:  This ER will be used to implement/track code generation for method references
BETA_JAVA8:  This ER will be used to implement/track code generation for constructor references.
BETA_JAVA8:  This ER will be used to implement/track generate code for array constructor references.
Looking at QuickFixProcessor.process() two kinds of problems could actually trigger insertion of null annotations while annotation-based null analysis is disabled:   IProblem.NonNullLocalVariableComparisonYieldsFalse   IProblem.RedundantNullCheckOnNonNullLocalVariable  Checks should be inserted to prevent bogus proposals.  Even if null annotations are enabled, some proposals offered on this route don't make much sense, I'm afraid.   I'll investigate.
Editor save action "Remove unnecessary parentheses" makes code uncompilable.  Code line below before save: static final Short cache[] = new Short[-(-128) + 127 + 1]; //compilable  code line after save: static final Short cache[] = new Short[--128 + 127 + 1];  //uncompilable  This line of code is from java.lang.Short.
BETA_JAVA8:  This ER will be used to implement track support for serializeable lambdas.
"public interface Foo {  	int run(int s1, int s2);  }  interface X { 	      static Foo f = (int s5, int s6) -> x<ctrl-space>     static int x1 = 2; }  x1 should have been suggested in assist; but not happening that way.  Thanks Anirban"
"public interface Foo {  	int run(int s1, int s2);  }  interface X { 	      static Foo f = (int x5, int x11) -> x     static int x1 = 2; }  class C { 	void method1(){ 		int p = X.<ctrl-space> 	} }  Wrongly suggesting x5, x11. Only x1 should have been suggested."
"public interface Foo {  	int run1(int s1, int s2); 	static int x2 = 0; }  interface Foo1 { 	Foo run2(int argFoo1); }  interface X extends Foo{ 	     static int x1 = 2;     static Foo f = (x5, x6) -> x5;     static Foo1 f1 = af1 -> (a1,b1) -> {int uniqueName = 4; return uniqueName;};     		 }  eclipse compiler clean, reference commandline compiler crash and seemingly total breakdown of code-assist inside the curly braces in the above multilevel lambda.  Thanks Anirban"
"public interface Foo {  	int run1(int s1, int s2); }  interface X extends Foo{ 	     static Foo f = (x5, x6) -> {x<ctrl-space>     		 }  x5, x6 are not suggested."
Created attachment 229449 [details] Missing carriage return at the end of the error summary output.  When compiling a Java file that contains errors using ecj from command line, the error output lacks a final carriage return. This means that the shell prompt or the next output from the invoking shell script appears on the same line as the last line of the ecj error output.  For example, you get this output:   [mbooth@10-2-5-11 calameo]$ CLASSPATH=/usr/share/java/ecj.jar:. \   java org.eclipse.jdt.internal.compiler.batch.Main Envelope.java ... error output etc ... ---------- 4 problems (4 errors)[mbooth@10-2-5-11 calameo]$    When it would be more desirable to have this output:   [mbooth@10-2-5-11 calameo]$ CLASSPATH=/usr/share/java/ecj.jar:. \   java org.eclipse.jdt.internal.compiler.batch.Main Envelope.java ... error output etc ... ---------- 4 problems (4 errors) [mbooth@10-2-5-11 calameo]$    The attached patch makes a small change to the output so that instead of including a final carriage return *only* in EMACS log output mode, we include a final carriage return in every output mode *except* for XML log output mode.
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=41ef4898bfd4399802c4b7fddb8b2e4f958ada78 says "Clean up new warnings introduced by merge from master", but it actually reintroduces some of the warnings from bug 404169. This commit should be reverted.  Srikanth, could it be that you're running against an old target platform or a target that replaces org.junit 4.11 with an older version?
when compiling a project via the BatchCompiler on Java 7 I get an NPE thrown from org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202)  the problem seem to be at line 573:      return this.locations.get(location.getName());  which works fine in Java 6, but returns null for Java 7.  location.getName() is "PLATFORM_CLASS_PATH" at that point.  building the same project with Java 6 works fine.  see more details at: http://stackoverflow.com/questions/15819926/eclipse-jdt-compiler-ecj-throws-npe-in-java-1-7  stacktrace: java.lang.NullPointerException     at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202)     at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.handleOption(EclipseFileManager.java:669)     at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchProcessingEnvImpl.(BatchProcessingEnvImpl.java:88)     at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager.configure(BatchAnnotationProcessorManager.java:69)     at org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager(Main.java:3632)     at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:3737)     at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1679)     at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1372)     at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:80)     at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:52)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:601) ...     at java.lang.Thread.run(Thread.java:722)
Currently it doesn't recognize 1.8 as an option. There are probably other things to be taken care of as well. This bug is to make the batch compiler work in 1.8 mode with support for annotation processing.
import java.util.@<ctrl-space>
Investigate what we have to do for LambdaExpressions in the UI.  Possible pain points:  - code that traverses the parent chain to find the enclosing scope (e.g. to find visibility of variables, possible target position for Extract Local Variable or Extract Method)  - type of lambda expression is inferred from context (e.g. extracting a lambda expression into a local variable may need special handling to get the right type; compare to MethodInvocation.isResolvedTypeInferredFromExpectedType())  - problems with lambda parameters without a declared type  - ...
When using the formatter from the command line on a large number of files, an ArrayIndexOutOfBoundsException is thrown by the formatter. Here's the contents of the log file denoted by the resulting error dialog:  !SESSION 2013-04-09 21:49:29.546 ----------------------------------------------- eclipse.buildId=M20130204-1200 java.version=1.7.0_15 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments] Command-line arguments:  -os linux -ws gtk -arch x86_64 -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments]  !ENTRY org.eclipse.osgi 4 0 2013-04-09 21:49:31.580 !MESSAGE Application error !STACK 1 java.lang.ArrayIndexOutOfBoundsException: 100         at org.eclipse.jdt.internal.formatter.Scribe.printNewLinesCharacters(Scribe.java:4867)         at org.eclipse.jdt.internal.formatter.Scribe.addOptimizedReplaceEdit(Scribe.java:571)         at org.eclipse.jdt.internal.formatter.Scribe.addReplaceEdit(Scribe.java:663)         at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2553)         at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2406)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:4379)         at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:277)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:593)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.formatTypeMembers(CodeFormatterVisitor.java:2212)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:1217)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:5586)         at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1286)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:3305)         at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:679)         at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:863)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.formatCompilationUnit(DefaultCodeFormatter.java:241)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:163)         at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:146)         at org.eclipse.jdt.core.formatter.CodeFormatterApplication.formatFile(CodeFormatterApplication.java:223)         at org.eclipse.jdt.core.formatter.CodeFormatterApplication.start(CodeFormatterApplication.java:418)         at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)         at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)         at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)         at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)         at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:601)         at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)         at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)         at org.eclipse.equinox.launcher.Main.run(Main.java:1438)         at org.eclipse.equinox.launcher.Main.main(Main.java:1414)  The command I run is:  ~/eclipse-4.2/eclipse -nosplash -application org.eclipse.jdt.core.JavaCodeFormatter -config ...  In my particular case, it crashes when there are 183 or more files. This seems like a simple case of not checking the current size of the Scribe.edits array before appending to it.
R3.8.  The Open Input action in the info views should be disabled if the input is empty/null. Currently, it is not, and clicking it, gives an error dialog saying:  Problem opening editor for '': 'Could not get an editor input for the given element'
Follow-up to bug 399791. That bug only added API in Flags for AccDefaultMethod, but the flag isn't actually returned by IMethod#getFlags().  On the other hand IMethod#getFlags() currently includes the unspecified Bit18 (ClassFileConstants.AccAnnotationDefault) for an annotation type method with a default value, e.g. javax.annotation.Generated#date() -- but ONLY if it's coming from a class file. For source files, it's masked away in SourceElementNotifier #notifySourceElementRequestor(AbstractMethodDeclaration, ...)   For IMethod#getFlags() and IMethodBinding#getModifiers(), we need to decide which of these flags to include:  - Flags/ClassFileConstants#AccDeprecated: included in getFlags(), but not in getModifiers() (spec'd like this) => keep it like this  - ClassFileConstants#AccAnnotationDefault (no API yet): sometimes included in getFlags() => needs a new API constant in Flags => getFlags(): should always be returned since we may want to show this in the element icon => getModifiers(): not necessary; checking IMethodBinding#getDefaultValue() for null is good enough  - Flags/ExtraCompilerModifiers#AccDefaultMethod: currently not returned anywhere => getFlags(): should always be returned since we may want to show this in the element icon; absence of 'abstract' is not enough to detect this in source => getModifiers(): not necessary; if declaring type is an interface type and IMethodBinding#getModifiers() includes 'abstract', then we know it's a default method.
"Created attachment 229664 [details] Fix the javadoc comment typo  /** foobar(<ul> 	 * <li>    #fragment1, #fragment2,  </li> 	 * <li>     #fragment3, #fragment4, </li> 	 * </ul> 	 */ 	public static final int M_COMPACT_FIRST_BREAK_SPLIT = 32; ----- fragment5 should be fragment3, according to the context and neighbor fields."
"I believe I'm getting a false positive resource leak warning when resources are closed using apache dbutils closeQuietly methods. Simplified Code: public static void test(Connection con){  	PreparedStatement ps = null; 	try { 		ps = con.prepareStatement(""foo""); 		// Remove this loop for no warning  		for (int i = 0; i < 1; i++) { 			try { 				ps.executeUpdate(); 			} catch (SQLException e) { 				throw new SQLException(""Some message"", e); // << warning 			} 			// << move the closing finally to here for no warning 		} 	} catch (SQLException e) { 		throw new RuntimeException(e); 	} finally { 		DbUtils.closeQuietly(ps);  // << change this to ps.close for no warning 	} }    The warning is removed if:  1, I add the finally block after the inner try-catch  2, I change closeQuietly to ps.close() (with the required try-catch wrapper)  3, I remove the for-loop"
The constructor/method parameter tooltip (Ctrl+Shift+Space) indicates the wrong parameter as current under some circumstances. To provoke the behavior, the parameter list must span multiple lines. But that doesn't seem to be the only condition. Unfortunately I wasn't able to reproduce the behavior with a small self-contained snippet. However, it can be observed with the MessageDialogWithToggle constructor:     MessageDialogWithToggle dialog       = new MessageDialogWithToggle( parentShell,                                      "Dialog Title",                                      null,                                      message,                                      MessageDialog.INFORMATION,                                      new String[] { IDialogConstants.OK_LABEL },                                      0,                                      "&Don't show this again",                                      false ); Place the cursor e.g. on the 'false' parameter and hit Ctrl+Shift+Space. The tooltip appears but draws the 'Shell parentShell' parameter in bold letters instead of 'boolean toggleState'.
Created attachment 229713 [details] test code  I created a CompilationUnit, call recordModifications() and do some modifications on it, and then use CompilationUnit#rewrite(...) to generate changed code.  BUT such modifications come into problem:         cu.accept(new ASTVisitor() {             @Override             public boolean visit(CatchClause node) {                 if (node.getException().getType().toString().equals("RemoteException")) {                     AST ast = node.getAST();                     CatchClause newCC = (CatchClause) ASTNode.copySubtree(ast, node);                     newCC.getException().setType(ast.newSimpleType(ast.newSimpleName("ServiceApplicationException"))); // This has no effect,  isn't it recorded?                     TryStatement parent = (TryStatement) node.getParent();                     parent.catchClauses().add(newCC);                 }                 return true;             }         });  A modification has no effect. So is it normal or a bug?
Add an icon adornment for default methods and annotation type elements with a default value.  The overlay for both will be a blue "D" with colors borrowed from native_co.gif / final_co.gif.
"Created attachment 229715 [details] TypeUnsafe class  Steps to reproduce  * using Eclipse Indigo SR2 or Eclipse Juno SR1  * compile the following code  ---------------------------------------------------------------------- import java.util.Collection;  public class TypeUnsafe { 	public static <Type, 			CollectionType extends Collection<Type>> 			CollectionType 			nullAsCollection(Class<Type> clazz) { 		return null; 	}  	public static void main(String[] args) { 		Collection<Integer> integers = nullAsCollection(String.class); 	} } ----------------------------------------------------------------------  Expected  * compilation *error* like the one below, produced by javac 1.7.0_09  ---------------------------------------------------------------------- TypeUnsafe.java:13: error: invalid inferred types for CollectionType; inferred type does not conform to declared bound(s)                 Collection<Integer> integers = nullAsCollection(String.class);                                                                ^     inferred: Collection<Integer>     bound(s): Collection<String>   where CollectionType,Type are type-variables:     CollectionType extends Collection<Type> declared in method <Type,CollectionType>nullAsCollection(Class<Type>)     Type extends Object declared in method <Type,CollectionType>nullAsCollection(Class<Type>) 1 error ----------------------------------------------------------------------  Observed  * code compiles without error or warning"
3.8.  Remove no longer used bundles from 'eclipse.jdt' repository: org.eclipse.jdt.macosx-feature org.eclipse.jdt.macosx.source-feature org.eclipse.jdt.macosx.source org.eclipse.jdt.macosx org.eclipse.jdt.source-feature org.eclipse.jdt.source  NOTE: Must also update root pom.xml if necessary.
"Our org.eclipse.jdt.ui.tests.refactoring.ExtractMethodTests#test803() fails in BETA_JAVA8 because the error recovery in the AST doesn't work any more and we don't get the AST we expect.  Source:  package error_in;  public class A_test803 { 	void m(String[] names) { 		/*[*/ 		for (String string : names) { 			System.out.println(string.); 		} 		/*]*/ 	} 	} }   In master, the method body is recovered down to the method argument ""string."". In BETA_JAVA8, the whole method body is just one recovered Block whose children are missing.  The additional '}' at the end doesn't make a difference."
N20130414-2000, broken since 4.3 M5. Works fine in 3.x, 4.2, and 4.2.x.  1. start new workspace 2. open 'Resource' perspective 3. open the main 'Run' menu ==> disabled 'Step Into Selection' menu item which should not be there.
This bug to be used to discuss and come up with changes that are required in Java model to support type annotations (JSR 308). At this point there is nothing critical or broken, but the requirement will be driven largely by the client.  If needed, raise separate bugs to track individual requirements.  Some of the things that may need correction are method signatures, type parameter signatures etc.
BETA_JAVA8:  Spawned from https://bugs.eclipse.org/bugs/show_bug.cgi?id=405066#c2  review comment 4.
"master and BETA_JAVA8  package xy; import javax.annotation.Generated; @Generated() class Try { }  Get the binding for @Generated and then call getAllMemberValuePairs() => NPE.  The problem is that Generated declares an array-valued ""String[] value();"" without a default, but the reference doesn't supply a value.  java.lang.NullPointerException 	at org.eclipse.jdt.core.dom.DefaultValuePairBinding.<init>(DefaultValuePairBinding.java:31) 	at org.eclipse.jdt.core.dom.AnnotationBinding.getAllMemberValuePairs(AnnotationBinding.java:98) 	at org.eclipse.jdt.astview.views.Binding.getChildren(Binding.java:232) 	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getChildren(ASTViewContentProvider.java:95) ..."
Created attachment 229839 [details] possible patch  If the JDT index manager rebuilds a pre-built index (see bug 395897) then it is saved in the index manager with a SAVE_STATE rather than REUSE_STATE.  If a single project in the workspace uses these indexes, and is then deleted, then the underlying index is also deleted.  A pre-built index (even if rebuilt by JDT) should never be deleted programmatically by JDT.
Created attachment 229840 [details] Test case to reproduce  See  java.io.@NonNull EOFException node in the attached test case using ast viewer:  thrownExceptions are converted to Name in ast level prior to 8. These nodes should have malformed flag set (somewhere) in case of presence of type annotations in the thrown exceptions.
"While navigating some code in the Scala IDE v3.0.0 for Eclipse 3.7, the following exception was reported by the Eclipse platform: ""Next Word"" did not complete normally. I believe this happened while pressing ""CMD + Right arrow"" on a dirty (i.e., not yet saved) editor. Unfortunately, I can't reproduce it.  I'm filing a ticket here and not the Scala IDE issue tracker because in the stacktrace (see below) there isn't any call that involves the Scala IDE codebase. That being said, the Scala IDE could still be in fault, because the Scala Editor is built on top of the Java Editor.  Below follows the full stacktrace  org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jface.text.Position.<init>(Position.java:62) 	at org.eclipse.jface.text.link.LinkedPosition.<init>(LinkedPosition.java:43) 	at org.eclipse.jface.text.link.LinkedPosition.<init>(LinkedPosition.java:58) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor$NextSubWordAction.findNextPosition(JavaEditor.java:806) 	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor$NextSubWordAction.run(JavaEditor.java:768) 	at org.eclipse.ui.texteditor.TextNavigationAction.runWithEvent(TextNavigationAction.java:99) 	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:185) 	at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:109) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:476) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:468) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:885) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:567) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:508) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:123) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1069) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4127) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1457) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1480) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1465) 	at org.eclipse.swt.widgets.Control.traverse(Control.java:4768) 	at org.eclipse.swt.widgets.Control.translateTraversal(Control.java:4552) 	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1058) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5563) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68) 	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:587) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5473) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2095) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2253) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5535) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:4989) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5138) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610) 	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701) 	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665) 	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499) 	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)"
"BETA_JAVA8: The fix for bug 405067 addressed only block bodies lambdas. Expression body lambdas will be handled as the topic of this bug.  At the moment the following program generates a verify error:  // --- interface I { 	String id(String s); } public class X { 	public static void main(String[] args) { 		I i = (s) -> s; 		System.out.println(i.id(""Hello"")); 	} }"
Attached test case says it all, but basically the "current" JDKs BinaryOperator<T> which extends BiFunction<T,T,T> without adding methods, gives an error since the single abstract method cannot be found during code generation, possibly since the superinterfaces aren't searched for the most specific match.
BETA_JAVA8:   The following program triggers an IncompatibleClassChangeError very likely due to the fact that ECJ at this point does not generate a synthetic bridge method to paper over signature differences.  // --------------- interface I {   void foo(int x, int y); } public class X {   public static void main(String[] args) {     BinaryOperator<String> binOp = (x,y) -> { return x+y; };      System.out.println(binOp.apply("SUCC", "ESS")); // when lambdas run\n" +   } } @FunctionalInterface interface BiFunction<T, U, R> {      R apply(T t, U u); } @FunctionalInterface  interface BinaryOperator<T> extends BiFunction<T,T,T> {  }
"Consider the below interface package p1;  public interface I1 {	 	 default int defaultMethod(){ 		 return 10; 	 }	 }  Invoke 'Refactor-> Extract Interface...' on I1. Select #defaultMethod to be part of the new interface. Click 'OK' button. In the newly created interface the method is created as abstract and in the original interface the method is removed. So basically the method implementation is lost after refactoring."
BETA_JAVA8:   This is spawned by splitting Bug 405068. I'll retain that bug for capture of locals from enclosing context and use the present one for enclosing instance capture as these two topics are unconnected and involve altogether different implementation concerns.  When this is resolved, we should also reenable the tests disabled via: eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=92dfd6c989831ab263c5667f92428e6c9943c027
When I'm trying to build p2.tests in my workspace. I get the following error.   Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.isDefinitelyUnknown(UnconditionalFlowInfo.java:814)
"BETA_JAVA8: -----------  The following program when compiled and run with branch head, produces:  Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception 	at java.lang.invoke.CallSite.makeSite(CallSite.java:298) 	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:294) 	at X.main(X.java:7) Caused by: java.lang.NullPointerException 	at java.lang.invoke.MethodHandleInfo.<init>(MethodHandleInfo.java:53) 	at java.lang.invoke.AbstractValidatingLambdaMetafactory.<init>(AbstractValidatingLambdaMetafactory.java:110) 	at java.lang.invoke.InnerClassLambdaMetafactory.<init>(InnerClassLambdaMetafactory.java:109) 	at java.lang.invoke.LambdaMetafactory.metaFactory(LambdaMetafactory.java:188) 	at java.lang.invoke.CallSite.makeSite(CallSite.java:283) 	... 2 more  ------------------  // -- interface I {     Object copy(int [] ia); }  class X  {     public static void main(String [] args) {         I i = int[]::<String>clone;         i.copy(new int[10]);     } }  // ---  Thanks to Andy Clement for reporting this."
"BETA_JAVA8:  For the ER described by the bug 406319, we need to reliably identify those  lambda methods that cannot be static. Presently the ""method can be static"" diagnostics and analysis still has some issues and can stand for further clean up: See that in the following program we don't suggest that foo could be static when in fact it could be:  // ----  public class X  { 	int f; 	void foo() { 		class Y { 			int p; 			{ 				class Z { 					int f = p; 				} 			} 		}; 	} }"
"(1) In the following program, foo is not tagged as can be static, while goo is. Both can be static:   // --- public class X  { 	int f; 	int foo() { 		int f = 0; 		return f; 	} 	int goo() { 		return 0; 	} }  // ---  Problem stems from the fact we do a look up for any existing f, to report hiding diagnostics. That look up is confused with a real field access.   (2) See that in the following program we don't suggest that foo could be static when in fact it could be:  // ----  public class X  { 	int f; 	void foo() { 		class Y { 			int p; 			{ 				class Z { 					int f = p; 				} 			} 		}; 	} }  Basically the analysis as is implemented is broken and I don't see any quick fixes. We can take solace that we are not meant to report  every possible candidate, but what we report should be correct."
Follow-up to bug 404489.  package jsr308.bug; public class X {     @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)     @interface Marker {     }      class Y {         class Z {         }     }      jsr308.bug.X.Y.Z z0;     jsr308.bug.@Marker X.@Marker Y.@Marker Z z; }                                  ^ The QualifiedType for Y here     ^ has a type binding for Z, but should be for Y, like its "name" child.  The PackageQualifiedType for X also has a type binding for Z. The qualifier of X has the correct package binding for jsr308.bug.
"BETA_JAVA8:   interface I { 	X [][][] copy (int x); } public class X  { 	public static void main(String[] args) { 		I i = X[][][]::new; 		X[][][] x = i.copy(136); 		System.out.println(x.length);                 |  // - no completion proposals here.		 	} 	 }"
Implement ASTRewrite for PackageQualifiedType. Duplicate and adapt the visit(QualifiedType) methods of ASTRewriteFlattener and ASTRewriteAnalyzer.
I suggest to use the foreach loop in ContentAssistProcessor. Patch to follow soon.
Created attachment 230101 [details] Test case to reproduce the issue  Use the attached testcase to open in ASTViewer, select the type parameter F to see the AST in the viewer.  ASTViewer bailed out with error message: "could not create ast, bad ast node structure".  This is due to incorrect source positions of the parent node if there are annotations.
We should propose the keywords even if there is no prefix. We already do this when outside a class but not when inside a class or method.
"BETA_JAVA8:  From bug 406388 comment 5:   // ---- interface I {     Object copy(); }  class X  {     public static void main(String [] args) {     	int [] x = new int[10];     	I i = x::<String>clone;         System.out.println(i.copy());     } } // ---- produces:  Exception in thread ""main"" java.lang.ClassFormatError: Invalid method signature in class X referenced from constant pool index 19 in method X.main([Ljava/lang/String;)V 	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2474) 	at java.lang.Class.getMethod0(Class.java:2715) 	at java.lang.Class.getMethod(Class.java:1622) 	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:555) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:537)  // -------------  javac is OK."
"BETA_JAVA8:  The following program should trigger an error about missing enclosing instance but doesn't:  // ---- interface I { 	X.Y makeY(); }  public class X { 	public class Y { 	} 	static void foo() { 		I i = Y::new; 	} }"
Can't see an existing bug for this (apologies if there is one!). This came up whilst working on JSR308 code generation.  For this code: ==== import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.CLASS) @interface B {     int value() default -1; }  class X {   @B(1) java.lang.String field; } ====  javac flags that 'nested type cannot be annotated'.  ECJ just lets it compile.  IIRC as of the current spec version it should be written 'java.lang.@B(1) String field' for a type_use annotation that is intended to apply to the String reference.
"BETA_JAVA8:  ECJ is not passing enclosing instance for inner class constructors. As a result, we get errors shown below for the program shown below:  ----- Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception 	at java.lang.invoke.CallSite.makeSite(CallSite.java:298) 	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:294) 	at X.foo(X.java:10) 	at X.main(X.java:15) Caused by: java.lang.invoke.LambdaConversionException: Incorrect number of parameters for static method newinvokespecial X$Y.<init>:(X)void; 0 captured parameters, 0 functional interface method parameters, 1 implementation parameters 	at java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:189) 	at java.lang.invoke.LambdaMetafactory.metaFactory(LambdaMetafactory.java:190) 	at java.lang.invoke.CallSite.makeSite(CallSite.java:283) 	... 3 more ----------  Program:  // ---- interface I { 	X.Y makeY(); }  public class X { 	public class Y { 	} 	 	void foo() { 		I i = Y::new; 		Y y = i.makeY(); 	} 	 	public static void main(String[] args) { 		new X().foo(); 	} }"
"BETA_JAVA8:  The following program prints X.foo, while it should actually print Y.foo  // ---- interface I { 	void foo(); }  class Y { 	void foo() { 		System.out.println(""Y.foo""); 	} } public class X extends Y { 	void foo() { 		System.out.println(""X.foo""); 	} 	void goo() { 		I i = super::foo; 		i.foo(); 	} 	public static void main(String[] args) { 		new X().goo(); 	} }"
"BETA_JAVA8:  I get a hint from the compiler that default method foo of I can be declared static. Default methods cannot be static.  // --- interface I { 	default int foo(int x, int y) { 		System.out.println(""I.foo("" + x + "","" + y + "")""); 		return 10; 	} }"
"BETA_JAVA8:  Given the program below, annotations on lambda parameters do not show up in the class file, despite the retention being runtime. Interestingly JDK 8b81 also has the same problem.   // ---- import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  interface I { 	void doit (Object o, Object p); }  public class X { 	I i = (@Annotation Object o, @Annotation Object p) -> { 		 	}; 	void foo(@Annotation Object o, @Annotation Object p) {         } }  @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @interface Annotation { 	 }  // ---  Problem is in org.eclipse.jdt.internal.compiler.ClassFile.generateMethodInfoAttributes(MethodBinding) - there is an expectation of AMD, which needs to be reconciled."
"BETA_JAVA8:   The disabled test org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest._test014() when run generates an AIIOB exception with this stack:   java.lang.ArrayIndexOutOfBoundsException: 1434 	at org.eclipse.jdt.internal.core.util.ClassFileStruct.u2At(ClassFileStruct.java:56) 	at org.eclipse.jdt.internal.core.util.BootstrapMethodsEntry.<init>(BootstrapMethodsEntry.java:33) 	at org.eclipse.jdt.internal.core.util.BootstrapMethodsAttribute.<init>(BootstrapMethodsAttribute.java:45) 	at org.eclipse.jdt.internal.core.util.ClassFileReader.<init>(ClassFileReader.java:277) 	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:239) 	at org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest.verifyClassFile(Jsr335ClassFileTest.java:51) 	at org.eclipse.jdt.core.tests.compiler.regression.Jsr335ClassFileTest.test014(Jsr335ClassFileTest.java:2027)"
"BETA_JAVA8:  The following program when run produces strange messages about Exception in thread ""main"" java.lang.NoClassDefFoundError:  notional  	at X.f(X.java:13) 	at X.main(X.java:9) Caused by: java.lang.ClassNotFoundException:  notional   This is because code generation is not in place for intersection casts.  // --  interface I { }  interface J { 	 } public class X implements I, J { 	public static void main( String [] args) { 		f(new X()); 	} 	 	static void f(Object o) { 		X x = (X & I & J) o; 	} }"
BETA_JAVA8:  We generate bad code that triggers a LCE for this program:  // --- interface I {     void foo(Integer a1, Integer a2, String a3); }  class Y {     static void m(Number a1, Object... rest) {          System.out.println(a1);         print(rest);     }     static void print (Object [] o) {         for (int i = 0; i < o.length; i++)             System.out.println(o[i]);     }      }  public class X {     public static void main(String [] args) {         I i = Y::m;         i.foo(10, 20, "10, 20");     } }
"BETA_JAVA8:   The following program triggers a verify error:   Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stack Exception Details:   Location:     X$Y$Z.f()V @7: invokedynamic   Reason:     Type 'X' (current frame, stack[0]) is not assignable to 'X$Y$Z'   Current Frame:     bci: @7     flags: { }     locals: { 'X$Y$Z' }     stack: { 'X' }   Bytecode:     0000000: 2ab4 000a b800 14ba 001d 0000 4cb2 001e     0000010: 2bb9 0024 0100 b600 2a2a b400 0ab8 0014     0000020: ba00 3200 004c b200 1e2b b900 2401 00b6     0000030: 002a b1                                  	at X.main(X.java:18)   // ---- interface I { 	String doit(); } public class X extends B { 	class Y { 		class Z { 			void f() { 				 				 I i = X.super::toString; // Verify error 				 System.out.println(i.doit()); 				 i = X.this::toString; // This call gets dispatched OK. 				 System.out.println(i.doit()); 			} 		} 	} 	 	public static void main(String[] args) { 		new X().new Y().new Z().f();  	} 	 	public String toString() { 		return ""X's toString""; 	} }  class B { 	public String toString() { 		return ""B's toString""; 	} }"
"BETA_JAVA8:   The following error is triggered by the program below:  Exception in thread ""main"" java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at X$Y.f(X.java:12) 	at X.main(X.java:25) Caused by: java.lang.IllegalAccessException: member is private: X.<init>(int)void/invokeSpecial, from X$Y 	at java.lang.invoke.MemberName.makeAccessException(MemberName.java:732) 	at java.lang.invoke.MethodHandles$Lookup.checkAccess(MethodHandles.java:1135) 	at java.lang.invoke.MethodHandles$Lookup.getDirectConstructor(MethodHandles.java:1243) 	at java.lang.invoke.MethodHandles$Lookup.linkMethodHandleConstant(MethodHandles.java:1270) 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:381) 	... 2 more   // --- interface I { 	X makeX(int x); } public class X { 	class Y extends X { 		private Y (int y) { 			System.out.println(y); 		} 		Y() { 		} 		void f() { 			I i = X::new; 			i.makeX(123456); 			i = X.Y::new; 			i.makeX(987654); 		} 	} 	private X(int x) { 		System.out.println(x); 	} 	X() { 	} 	 	public static void main(String[] args) { 		new X().new Y().f(); 	} }"
"Consider the following interfaces: I2 (having lambda expression) and I3 (having default and static methods).  Perform ""Extract Method"" refactoring on the lines with comments. We get exception and no refactoring is performed. It should be possible to extract methods in interfaces which would be created as default or static methods in those interfaces.  @FunctionalInterface public interface I1 { 	int foo(int a); }  interface I2 { 	I1 i1= (a) -> { 		int b= 10; // Exception on extracting to method 		return a + b; 	}; }  interface I3 { 	default int foo () { 		int a= 10; // Exception on extracting to method 		return a; 	} 	 	static int bar() { 		int a= 10; // Exception on extracting to method 		return a; 	} }"
Refer to bug 401040.  CBI produced ECJ contains META-INF/maven, which isn't necessary. The folder needs to be removed.
"The following test fails with a JavaModelException (does not exist) on #getParameterNames for binary types:  ASTParser parser = ASTParser.newParser(AST.JLS3); parser.setIgnoreMethodBodies(true); parser.setProject(javaProject); IType type = javaProject.findType(""TestEnum""); IBinding[] bindings = parser.createBindings(new IJavaElement[] { type }, null); ITypeBinding typeBinding = (ITypeBinding) bindings[0]; IMethodBinding[] methods = typeBinding.getDeclaredMethods(); for(IMethodBinding method: methods) { 	if (method.isConstructor()) { 		IMethod element = (IMethod) method.getJavaElement(); 		String[] parameterNames = element.getParameterNames(); 		// BOOM 	} }  The enum declaration:  public enum TestEnum {  	FirstValue(""Zonk"") { 		@Override 		public String toString() { 			return super.toString(); 		} 	}, 	SecondValue(""Bla""); 	 	String string; 	 	TestEnum(String string) { 		this.string = string; 	}  }  I can apply a local fix by using a handcrafted BinaryKey to obtain the enum constructor, e.g. use   String[] parameterTypes = Signature.getParameterTypes(   new BindingKey(""Lx;.x(Ljava/lang/String;ILjava/lang/String;)"").toSignature()); IMethod constructor = type.getMethod(name, parameterTypes);  The parameter types cannot be obtained from the BinaryMethod afterwards, since BinaryMethod.getParameterNames uses   // let's see if we can retrieve them from the debug infos char[][] argumentNames = info.getArgumentNames(); if (argumentNames != null && argumentNames.length == paramCount) {   String[] names = new String[paramCount];   for (int i = 0; i < paramCount; i++) {     names[i] = new String(argumentNames[i]);   }   return this.parameterNames = names; }  to read the param names from the debug information. The number of arguments in the info object is different from the number of arguments in the key. The paramCount == 3 but the argumentNames contain only a single entry ['string'] which is correct but fails to fulfil the condition."
Clean up APIs IField#getConstant() and IVariableBinding#getConstantValue().  These APIs are supposed to implement JLS7 4.12.4 and should return a non-null value iff the field is a constant variable.  Unfortunately, there's a bug in JLS7: It would also allow an instance field to be a constant variable. But this contradicts the JVMS7. I've sent a mail to the JLS maintainers to fix this.   Once the definition of "constant variable" is clear, our implementations and Javadocs should be adapted. Bugs I saw: - IVariableBinding#getConstantValue(): should return null for final instance fields - IField#getConstant(): should not return null for non-trivial initializers like "1<<8"   Test class:  package p;  public class B {     public static final int SFC = 1, SFC2 = 1<<8;     public final int IFC = 2;      public static final int SF = Integer.valueOf(-1).intValue();     public final int IF = Integer.valueOf(-2).intValue();      public static int SC = 3;     public int IC = 4;      public static int S = Integer.valueOf(-3).intValue();     public int I = Integer.valueOf(-4).intValue();      public static void main(String[] args) {         print(SFC);         print(SFC2);         print(SC);          print(SF);         print(S);          foo(new B());     }      private static void foo(B b) {         print(b.IFC);         print(b.IC);          print(b.IF);         print(b.I);     }      private static void print(int i) {         final int fi = i;         System.out.println(fi);     } }
"I was adding this lambda testcase as it didn't appear to be working for me when built with ECJ (I was adding it into LambdaExpressionsTest). It is *not* a finished test yet as the expected output is not right.  However, I accidentally ran it without 1.8 compliance and crashed ECJ.  public void test045() { 	this.runConformTest( 			new String[] { 					""C.java"", 					""import java.util.*;\n"" + 					""public class C {\n"" + 					""  public static <E> void printItem(E value, int index) {\n"" + 					""    String output = String.format(\""%d -> %s\"", index, value);\n"" + 					""    System.out.println(output);\n"" + 					""  }\n"" + 					""  public static void main(String[] argv) {\n"" + 					""    List<String> list = Arrays.asList(\""A\"",\""B\"",\""C\"");\n"" + 					""    eachWithIndex(list,C::printItem);\n"" + 					""  }\n"" + 					""  interface ItemWithIndexVisitor<E> {\n"" + 					""    public void visit(E item, int index);\n"" + 					""  }\n"" + 					""  public static <E> void eachWithIndex(List<E> list, ItemWithIndexVisitor<E> visitor) {\n"" + 					""    for (int i = 0; i < list.size(); i++) {\n"" + 					""         visitor.visit(list.get(i), i);\n"" + 					""    }\n"" + 					""  }\n"" + 					""}\n"" 			},""XXX""); }  During compilation of that:  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.redeclaresPublicObjectMethod(MethodBinding.java:1211) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getInterfaceAbstractContracts(ReferenceBinding.java:1681) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getSingleAbstractMethod(ReferenceBinding.java:1733) 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:494) 	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isCompatibleWith(TypeBinding.java:483) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4151) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:638) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:580) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1456) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1366) 	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2155) 	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:666) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1001) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:297) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:505) ...  I fixed it by changing:  Scope.parameterCompatibilityLevel  this bit (line 4151):  if (arg != param && !arg.isCompatibleWith(param.erasure())) 					return NOT_COMPATIBLE;  change that call to include the scope:  if (arg != param && !arg.isCompatibleWith(param.erasure(),this)) 					return NOT_COMPATIBLE;  and then the correct errors will come out:  		""1. ERROR in C.java (at line 3)\n"" +  		""	public static <E> void printItem(E value, int index) {\n"" +  		""	               ^\n"" +  		""Syntax error, type parameters are only available if source level is 1.5 or greater\n"" +  		""----------\n""  etc/etc. I will likely raise a separate issue for the lambda behaviour not working."
"Following on from bug 406846, once I got it compiling, this testcase (for LambdaExpressionsTest):  public void test045() {   this.runConformTest(     new String[] {       ""C.java"",       ""import java.util.*;\n"" +       ""public class C {\n"" +       ""  public static <E> void printItem(E value, int index) {\n"" +       ""    String output = String.format(\""%d -> %s\"", index, value);\n"" +       ""    System.out.println(output);\n"" +       ""  }\n"" +       ""  public static void main(String[] argv) {\n"" +       ""    List<String> list = Arrays.asList(\""A\"",\""B\"",\""C\"");\n"" +       ""    eachWithIndex(list,C::printItem);\n"" +       ""  }\n"" +       ""  interface ItemWithIndexVisitor<E> {\n"" +       ""    public void visit(E item, int index);\n"" +       ""  }\n"" +       ""  public static <E> void eachWithIndex(List<E> list, ItemWithIndexVisitor<E> visitor) {\n"" +       ""    for (int i = 0; i < list.size(); i++) {\n"" +       ""         visitor.visit(list.get(i), i);\n"" +       ""    }\n"" +       ""  }\n"" +       ""}\n""     },""XXX""); }  (expected output is not complete) It compiles but fails to run with:  junit.framework.AssertionFailedError: Unexpected error running resulting class file for C.java: --[START]-- java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at C.main(C.java:9) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:487) 	at ---[END]---  Same code works fine with javac (b81). Should produce the output:  0 -> A 1 -> B 2 -> C"
"BETA_JAVA8:   In the following program, the compiler hints the user that X.foo could be declared as static. This is wrong and will result in the code not continuing to compile:  // --- interface I { 	void foo(int i); } public class X { 	public static void main(String[] args) { 		X x = null; 		I i = x::foo; 		try { 			i.foo(10); 		} catch (NullPointerException npe) { 			System.out.println(npe.getMessage()); 		} 	} 	int foo(int x) { 		return x; 	} }"
"M6 and a bit, In  import org.eclipse.jdt.annotation.NonNull;  public class Test { 	boolean booleanFunction() { return true; } 	 	Boolean BooleanFunction() { 		@NonNull Boolean aBoolean = booleanFunction(); 		return aBoolean; 	} }"
"Not strictly a Java8 bug but it is a problem on BETA_JAVA8. Testcase (I had this in MethodVerifyTest):  Map compilerOptions16 = getCompilerOptions(); compilerOptions16.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, CompilerOptions.VERSION_1_6); compilerOptions16.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_6); compilerOptions16.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_6); this.runConformTest(   new String[] {     ""TestPointcut.java"",     ""interface MethodMatcher {\n""+     ""	boolean matches();\n""+     ""}\n""+     ""abstract class StaticMethodMatcher implements MethodMatcher { }\n""+     ""abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher { }\n""+     ""\n""+     ""class TestPointcut extends StaticMethodMatcherPointcut {\n""+     ""	@Override\n""+     ""	public boolean matches() { return false; } \n""+     ""}\n""   },   """",   null,   true,   null,   compilerOptions16,   null);  That code should not produce a warning for @Override but it does. It looks like some refactoring was done in MethodVerifier.computeInheritedMethods() in BETA_JAVA8 and the algorithm that collects up the super interfaces fails to collect 'MethodMatcher' in the above example (i.e. an interface on the superclass of the superclass of the class we are interested in).  Without knowing about that interface the @Overrides looks like an error.  I'll attach a patch in a moment containing the test and my fix (you may choose to fix it differently...)."
BETA_JAVA8:  We need to add support for JEP 118 & JEP 120 for Java 8.
The MethodParameters attribute must be recognized and correctly read by a class file reader in order to properly implement the Java SE platform class libraries (§2.12), if the class file's version number is 52.0 or above and the Java virtual machine implementation recognizes class files whose version number is 52.0 or above.
I20130430-2000.  The icons for ignored and assumption failed test should use the '/org.eclipse.jdt.ui/icons/full/ovr16/ignore_optional_problems_ovr.gif' decorator instead of crossing out the "normal" icon.
Generate the MethodParameters attribute into the attributes table of a method_info structure.
"package xy; public class CompletionTest { 	{ 		new File() 	} }  - put caret between () - press Ctrl+Space  => 4.3 M5a allowed me to choose a constructor proposal, press Enter, and then see context information. But now, I get a bunch of less interesting template proposals in front."
"With the automatic addition of ';' to void-returning method completion proposals, we don't show Context Information any more for such completions.  Example: Complete after ""wait"" here and choose a method with parameters:  package xy; public class CompletionTest { 	{ 		wait 	} }  The problem in this case is that JavaMethodCompletionProposal#computeContextInformation() needs another condition ""|| getReplacementString().endsWith(SEMICOLON)"".  Need to check other proposals as well."
Support the new PackageQualifiedType AST node from bug 404489 in JDT UI.  The node occurs when a type-use annotation is added to a package-qualified type. Before, such types were represented as SimpleType(QualifiedName).  See the explanations in the Javadoc of QualifiedType in BETA_JAVA8.
Created attachment 230399 [details] Fix  http://download.eclipse.org/eclipse/downloads/drops4/I20130501-2000/compilelogs/jdt.doc.isv.javadoc.txt has 7 warnings of this kind:  ../../../eclipse.jdt.ui/org.eclipse.jdt.ui/ui/org/eclipse/jdt/ui/wizards/NewPackageWizardPage.java:22: error: package org.eclipse.equinox.bidi does not exist import org.eclipse.equinox.bidi.StructuredTextTypeHandlerFactory;                                ^  The generated Javadoc is not affected, since the type is not used in an API.
"interface Foo {  	void run1(int s1, int s2); }  interface X extends Foo{ 	   static Foo f = (first, second) -> System.out.print(firs<ctrl-space>);     		 }  Code assist not making suggestion."
ASTRewritingTest should also support _since and _only on whole test class.   Currently, all tests in ASTRewritingTypeAnnotationsTest start with     if (this.apiLevel < AST.JLS8) return; , making it look like they also run on earlier AST levels.
1. In a Javadoc comment, type '@' and press Ctrl+Space. We can see tags like {@code}, {@link} etc in Default proposals. 2. Type a letter, say 'a'.  3. Press Backspace key to delete 'a'. We get the Default proposals but tags like {@code} are missing.
Although not documented in the JEP, the current EA javac supports generation of parameter names by option '-options' in javac. ECJ should follow this lead for now. There should be a distinct Java Code Generation option for this in the UI, too.
ASTRewrite testcases for QualifiedType need to be added to complete the list.
"1. Open a new workspace. 2. Go to File -> New -> Class. (Open any New type wizard). 3. Check ""Enclosing type"". 4. Press Ctrl+Space in the text field of Enclosing type. We get an exception in Error Log view.  org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63) .... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.ui.refactoring.contentassist.CUPositionCompletionProcessor.computeCompletionProposals(CUPositionCompletionProcessor.java:159)"
Bug 407383 creates the initial document with all the M1-M7 JDT items. Those items now need to be grouped, like in the past release [1]. Similar items need to be collapsed into one.   [1] http://help.eclipse.org/juno/topic/org.eclipse.jdt.doc.user/whatsNew/jdt_whatsnew.html
We need to update the F1 Help and the documentation to cover our new features.
In windows & linux OS the checked JRE is the one defined in eclipse.ini (see screen-cap), on MAC OS the JRE listed in eclipse.ini is not even one of the listed JREs, what is checked instead is the defined Default OS JRE (could be different Java version entirely than what is listed in eclipse.ini)
"public class Test { 	void foo(int i) { 		bar(i); 	} 	 	static void bar(Integer i) 	{ 		 	} }  The compiler throws up a incorrect warning message Null type safety: The expression of type int needs unchecked conversion to conform to '@NonNull Integer'  at the function call: bar(i).    Discussion: Well, that's cheating :) No, the compiler correctly recognized the need to perform a boxing conversion from int to Integer. The bug is real: after converting to Integer it *thinks* it must continue converting from plain Integer to ""@NonNull Integer"", but in fact the boxing conversion already provides ""@NonNull Integer"". There is no int value that would yield a boxed value of ""null"".  cheers, Stephan  On 05/07/2013 03:00 PM, Shankha Banerjee1 wrote: > Hi Stephan, > I modified the example a bit : > > *package*test2; > > *public**class*Test { > *void*foo(*int*i) { > /bar/(i); >          } > > *static**void*bar(*int*i) //*_Changed the argument type from integer to > int_* >          { > >          } > } > > The warning disappears. Could it be that the compiler is correct in > throwing up the warning since it thinks the argument is a Integer type. > > Thanks, > Shankha > > > > From: Stephan Herrmann <stephan.herrmann@berlin.de> > To: Shankha Banerjee1/India/IBM@IBMIN, Jayaprakash > Arthanareeswaran/India/IBM@IBMIN, > Date: 05/07/2013 06:18 PM > Subject: Re: Query on Null Analysis and suggested quick fix > ------------------------------------------------------------------------ > > > > Hi Shankha, > > this is an interesting bug. > > After I've done some work on properly including *unboxing* in > null analysis, here we have the case where *boxing* is not > correctly analyzed. The quick fix isn't really to blame, > its the warning that is bogus: boxing a primitive value > can never produce a null value. > > Please file a bug. > > @Jay, this isn't strictly a regression, but a genuine bug > that will become more and more relevant as people are starting > to jump on the train of null annotations. > Please let me know if I should attempt a fix for Kepler, which > *might* be a fairly easy tasks. Haven't look yet. > > Thanks, > Stephan > > > On 05/07/2013 07:44 AM, Shankha Banerjee1 wrote: >  > Hi Stephan, >  > I had the following test case with null analysis enabled. >  > >  > *package*test2; >  > *import*_org.eclipse.jdt.annotation.NonNull_; >  > >  > *public**class*Test { >  > *void*foo(*int*i) { >  > /bar/(_i_); >  >          } >  > >  > *static**void*bar(Integer i) >  >          { >  > *assert*(i != *null*); >  >          } >  > } >  > >  > >  > There also exists a package-info.java as part of the package: >  > @org.eclipse.jdt.annotation.NonNullByDefault(*true*) >  > *package*test2; >  > >  > We report a error >  > at >  > bar(i) >  > Null type safety: The expression of type int needs unchecked conversion >  > to conform to '@NonNull Integer' >  > >  > The Quick fix suggests the following fix: >  > ... >  > public class Test { >  > void foo(@NonNull int i) { >  > bar(i); >  > ... >  > >  > >  > After following the quick fix: >  > >  > The error thrown up is: >  > The nullness annotation @NonNull is not applicable for the primitive >  > type int >  > at void foo(@NonNull int i). >  > >  > Do you think it is a possible bug as the quick fix results in a error? >  > >  > Thanks, >  > Shankha > >"
Yearly pass to find and remove unused NLS strings in platform and JDT debug.
Created attachment 230737 [details] screen shot  There should be a space in the name of the debug target before the host:port information.  See screen shot.
"Created attachment 230786 [details] Source file that causes error when cleanup is applied  Greetings. The stack trace reproduced below is generated when I try to run a cleanup operation on the attached source file.   My cleanup function is configured to run these operations: Change non static accesses to static members using declaring type Change indirect accesses to static members to direct accesses (accesses through subtypes) Convert control statement bodies to block Convert 'for' loops to enhanced 'for' loops Add final modifier to private fields Add final modifier to local variables Remove unused imports Add missing '@Override' annotations Add missing '@Override' annotations to implementations of interface methods Add missing '@Deprecated' annotations Remove unnecessary casts Remove unnecessary '$NON-NLS$' tags Sort members excluding fields, enum constants, and initializers Organize imports Format source code Remove trailing white spaces on all lines Correct indentation   eclipse.buildId=4.3.0.I20130314-1330 java.version=1.7.0_21 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Framework arguments:  -product org.eclipse.epp.package.classic.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.classic.product  Error Thu May 09 17:03:12 PDT 2013 Internal Error  java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421) 	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:502) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74) 	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114) 	at org.eclipse.jdt.internal.ui.fix.CleanUpRefactoringWizard$CleanUpConfigurationPage.getNextPage(CleanUpRefactoringWizard.java:456) 	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:908) 	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:428) 	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:826) 	at org.eclipse.jface.window.Window.open(Window.java:802) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202) 	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122) 	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38) 	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startCleanupRefactoring(RefactoringExecutionStarter.java:251) 	at org.eclipse.jdt.internal.ui.actions.AllCleanUpsAction.performRefactoring(AllCleanUpsAction.java:78) 	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:176) 	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:108) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275) 	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1108) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:992) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:137) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:600) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: java.lang.IllegalArgumentException: Comparison method violates its general contract! 	at java.util.TimSort.mergeHi(TimSort.java:868) 	at java.util.TimSort.mergeAt(TimSort.java:485) 	at java.util.TimSort.mergeForceCollapse(TimSort.java:426) 	at java.util.TimSort.sort(TimSort.java:223) 	at java.util.TimSort.sort(TimSort.java:173) 	at java.util.Arrays.sort(Arrays.java:659) 	at java.util.Collections.sort(Collections.java:217) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250) 	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134) 	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455) 	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41) 	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121) Root exception: java.lang.IllegalArgumentException: Comparison method violates its general contract! 	at java.util.TimSort.mergeHi(TimSort.java:868) 	at java.util.TimSort.mergeAt(TimSort.java:485) 	at java.util.TimSort.mergeForceCollapse(TimSort.java:426) 	at java.util.TimSort.sort(TimSort.java:223) 	at java.util.TimSort.sort(TimSort.java:173) 	at java.util.Arrays.sort(Arrays.java:659) 	at java.util.Collections.sort(Collections.java:217) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258) 	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302) 	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585) 	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514) 	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250) 	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134) 	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455) 	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41) 	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581) 	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894) 	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718) 	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85) 	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) 	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)"
And this results in problems, especially while processing annotations. Refer to bug 386901 for more details. The cause and the possible fix are discussed from bug 386901, comment #27 on.
Verified in I20130512-2000.  It misses the services and instead has the schemas in it. Plus, it has other useless/unexpected stuff in it.  Test Case: compare it with 3.8.2.
I20130512-2000.  ECJ download misses legal file (about.html).  This should be fixed for RC1 or RC2 at latest.
We need to add support for Java 8.  A starting point: http://mail.openjdk.java.net/mailman/listinfo/enhanced-metadata-spec-discuss
"Consider the following having lambda expressions: Class X and Interface I2. We get exception or incorrect refactoring by performing ""Extract Method"" refactoring on the lines with comments.  It should be possible to extract methods from a lambda expression, which would be created in its enclosing type.  @FunctionalInterface public interface I1 { 	int foo(int a); }  // Error: Extracted to m1() and placed in enclosing type.  // But replaced with ""m1();"" instead of ""int b= m1();"" class X { 	I1 i1= (int a) -> { 		int b= 10; // Error 		return a + b; 	}; 	 	class Y { 		I1 i1= (int a) -> { 			int b= 10; // Error 			return a + b; 		}; 	} 	 	void foo() { 		I1 i1= (int a) -> { 			int b= 10; // Error 			return a + b; 		}; 	} 	 	void bar() { 		Runnable r= new Runnable() { 			I1 i1= (int a) -> { 				int b= 10; // Error 				return a + b; 			}; 			 			@Override 			public void run() { 				I1 i1= (int a) -> { 					int b= 10; // Error 					return a + b; 				};				 			} 		}; 	} }  // see bug 406786 for Extract Method from lambda expr in interfaces interface I2 {	 	I1 i1= (int a) -> { 		int b= 10; // Exception on extracting to method 		return a + b; 	};	 }"
"Consider the example below:  @FunctionalInterface public interface I1 { 	int foo(int a); }  class X {	 	void foo() {	 		I1 i1= (int a) -> {return 10;}; // Extract lambda expr 		 		I1 i2= (a) -> {return 10;}; // Extract lambda expr 		bar(a -> 10); // Extract lambda expr 	} 	 	void bar(I1 i) { 	}  	// expected method after extraction 	I1 m() { 		return (int a) -> {return 10;}; 	} }  Try to extract only the lambda expr from the lines with comments to a method using Alt+Shift+M.   We get different error messages in above cases and it is not possible to extract the lambda expr to a method as shown in the expected method above."
"The erasure of a signature of a method has no type parameters. For example, if the following method declarations are added in a class a compiler error is generated. public <T>  String setArrayList(ArrayList<T> arrayList); 	public   String setArrayList(ArrayList arrayList);  The compiler error message, listed below, is not accurate: Method setArrayList(ArrayList) has the same erasure setArrayList(ArrayList<E>) as another method  Erasure of a method has no type parameters yet in the compiler error message the type parameter E is specified. The erasure of the first method is   public   String setArrayList(ArrayList arrayList);  The erasure of the second method is the same as the method declaration."
A common pattern when using proxies to serialize an object, is to place the "Externalize" class in a static inner class. For example:  private static final class ReceiptV1 extends Externalize {   public ReceiptV1(){}   public ReceiptV1(Receipt r){...} }  The externalization process requires a public no argument constructor. But the JDT complains that the public constructor is unused. You are then forced to add @SuppressWarnings("unused") to get rid of the warning.  The JDT should be doing the opposite when the class extends Externalize. It should give you a warning if the public no argument constructor is missing.
Created attachment 230978 [details] proposed fix  While looking at how the search works for bug 408059 I found that the search query checks twice to see if the wrapper class exists, when it should probably be testing if the properties file exists in the second check.
Version: 4.3.0 Build id: I20130513-2000  While scanning org.eclipse.jface I got the following during the search:  Undefined keys in: MenuManager.java - org.eclipse.jface.action (2 matches)  One of the matches is: ExternalActionManager.ICallback callback = ExternalActionManager.getInstance().getCallback();  with ExternalActionManager.ICallback highlighted. There are 17 of these flagged for all of jface.
"Since a lambda expression is like a method, it should be possible to extract local variables within its body.  Consider the following example and try to extract a local variable from the lines with comments, we get different error messages:  @FunctionalInterface interface FI { 	int foo(int a); }  public class TestExtractLocalVariable { 	FI fi1= (a) -> a + 10;	// Error 	 	FI fi2= (int a) -> {	 		int b= a + 10; // Error 		return b; 	}; 	 	void bar(FI fi) { 	     FI fi1= (a) -> a + 10; // Error, not extracted within lambda body 		 	     FI fi2= (a) -> {	 		    int b= a + 10; // Works here 		    return b; 	     };		 	}	 }"
"Perform Refactor > Extract Class... on the following example:  // comment public class Test { 	int i; }  We get this exception: java.lang.reflect.InvocationTargetException 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421) 	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) ... Caused by: java.lang.ClassCastException: org.eclipse.jdt.core.dom.CompilationUnit cannot be cast to org.eclipse.jdt.core.dom.TypeDeclaration 	at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractClassRefactoring.createParameterObject(ExtractClassRefactoring.java:479)"
When autocompleting for a method in a class, I am given the option to create a "Default constructor". However, this is incorrect. A default constructor is not something that a developer can create; per the JLS it's emitted solely by the compiler if one isn't provided in the source. The label should be "No-arg constructor" or "Empty constructor".
"Consider the following example and hover on ""a"" as mentioned in the comments:  public class C1 {	 	FI i1= (a) -> a++; // [1] Hover on ""a"" in ""a++"" 	void foo() { 		FI i2= (a) -> { 			return a; // [2] Hover on ""a"" 		}; 	} } interface FI { 	int f1(int a); }  We get these exceptions: [1] java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.util.Util.typeSignature(Util.java:2685) 	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:454) 	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1229)  [2] java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:187) 	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594)"
"Select foo() in the following example and open the Javadoc view:  public class Test { 	private void foo() {} }  Now, delete the method:  private void foo() {}  An error is logged in the Error Log view on deletion:  Java Model Exception: Java Model Status [foo() [in Test [in [Working copy] Test.java [in test.bugs.var [in src [in com.bugs.test]]]]] does not exist] 	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:498) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:532) ... at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:600) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:495) 	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.getJavadocHtml(JavadocView.java:1097) 	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.computeInput(JavadocView.java:908)"
"public class Test {  }  Right click and select 'Refactor > Extract Interface' for the above class. Give some name for interface and click ""Preview"". Use down arrow button i.e. ""Select Next Change"".     It expands the 1st change node and ""Add super interface"" is selected. No input in the details page. Error is logged in the Error Log view:  org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.ltk.core.refactoring.TextChange.getCurrentContent(TextChange.java:334) 	at org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer.setInput(TextEditChangePreviewViewer.java:192) ..."
"import java.util.Arrays; import java.util.List;   public class TypeMistmatchIssue { 	static interface A { 	} 	static class B implements A { 	} 	static class C implements A { 	} 	static class D implements A { 	} 	 	void illustrate() { 		List<Class<? extends A>> no1= Arrays.asList(B.class, A.class);						// compiles 		List<Class<? extends A>> no2= Arrays.asList(C.class, B.class, A.class);				// compiles 		List<Class<? extends A>> no3= Arrays.asList(D.class, B.class, A.class);				// compiles 		 		List<Class<? extends A>> no4= Arrays.asList(D.class, C.class, B.class, A.class);	// cannot convert error !!!  		List<Class<? extends A>> no5= Arrays.asList(A.class, B.class, C.class, D.class);	// compiles 		List<Class<? extends A>> no6= Arrays.asList(A.class, D.class, C.class, B.class);	// compiles 	} }"
After checking a "compiler log" message tonight, to make sure the RC1 version was being used, I saw:   <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="bundle_qualifier, 3.9.0">  So, 1) copyright needs to be updated to include 2013, and   2) appears "bundle_qualifier" has broken, moving to Tycho build, I assume, but appears it was correct for M6 ... oh, maybe then we were still using "old" compiler, produced by PDE M5a?   log from M6 says  <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="v20130129-050623, 3.9.0">   a log from SM5a says:   <compiler copyright="Copyright IBM Corp 2000, 2012. All rights reserved." name="Eclipse Compiler for Java(TM)" version="v20121208-144805, 3.9.0">
http://download.eclipse.org/eclipse/downloads/drops4/I20130518-1500/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html
Update JDT T&T document with relevant items from Kepler N&N documents.
Created attachment 231289 [details] Proposed ecj manpage  Many distributions package JDT core libraries, with an independent executable for ecj. Each of these must currently maintain a manpage, if they want one. Since it is unlikely that the documentation for ecj would differ widely across distributions, it would be great if this could instead be maintained upstream. Attached is proposed first cut, based on most current debian release but updated to reflect the output of -help (ie usage message) from eclipse compiler as of 4.2.1.
Created attachment 231292 [details] Shows the incorrect label text  In any "select documentation" dialog for Javadocs, the "file://" example only contains one forward slash ("file:/"), which is incorrect.  See similar bug 191965 (not a duplicate).  For convenience I have also included a screenshot.  JDT is 3.8.2 Eclipse Platform 4.2.1
Bug 331649 introduced the warning option JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS which is not yet supported at the command line of the batch compiler.
"Consider the following example and try to rename the variables mentioned in comments using ""Alt+Shift+R"":  @FunctionalInterface interface I { 	int foo (int x); }  public class C1 { 	I i= (int x) -> { // Unable to Rename ""x"" 		int p= 10; // Unable to Rename ""p"" 		I ii= (int a) -> a+100; // Unable to Rename ""ii"", ""a"" 		return ii.foo(x) + p; 	};  	void foo() { 		I i= (int x) -> x; // works here 	}	 }  We get the error, ""Only local variables declared in methods and initializers can be renamed"".   However, it should be possible to rename variables in any type of lambda expr also."
"Consider the following example and perform Refactor > Inline as per the comments:  @FunctionalInterface interface I1 { 	int foo(int x);	 }  public class X { 	public static final I1 a= (int x) -> x; 	 	void fun1() { 		int n = a.foo(0); // [1] Inline ""a"" => AFE	 		 		I1 i= (int x) -> { return x; }; // [2] Inline ""i"" 		I1 i1= x -> i.foo(x); // => Invalid inlining of ""i"" 		fun2(i); // => Valid inlining of ""i"" 	} 	 	void fun2(I1 i) {} }  [1] =>  java.lang.reflect.InvocationTargetException ... Caused by: org.eclipse.core.runtime.AssertionFailedException: assertion failed:  	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110) 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.setFragment(ASTFragmentFactory.java:194) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.visit(ASTFragmentFactory.java:133) 	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:547) 	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:566) 	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:149) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670) 	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2718) 	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:215) 	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.createFragment(ASTFragmentFactory.java:186) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.createFragmentFor(ASTFragmentFactory.java:115) 	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory.createFragmentForFullSubtree(ASTFragmentFactory.java:56) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitializer(InlineConstantRefactoring.java:789) 	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitialConditions(InlineConstantRefactoring.java:736) 	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83) ...   [2] => Results in: I1 i1= x -> (int x) -> { return x; }.foo(x); // => Invalid inlining of ""i"" fun2((int x) -> { return x; }); // => Valid inlining of ""i"""
"Consider the following example and apply the quick fix ""Add return statement"" on the lines with comments:  @FunctionalInterface interface I { 	int foo(int x);	 }  public class A { 	void fun1() { 		I i= (int x) -> { // [1] NPE on applying quick fix 			x++; 		};		 	} 	 	void fun2() { 		I i= (int x) -> { // [2] Incorrect result from quick fix 			x++; 		}; 		 		fun1(); 	} }  [1] => java.lang.NullPointerException 	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:132) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.evaluateReturnExpressions(MissingReturnTypeCorrectionProposal.java:154) 	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.getRewrite(MissingReturnTypeCorrectionProposal.java:113) 	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113) 	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234) ...   [2] => Adds return statement to method fun2() instead of the lambda expression. Results in: 	void fun2() { 		I i= (int x) -> {  			x++; 		}; 		 		return fun1(); // Incorrect result 	}"
"Created attachment 231493 [details] fix  FUP to bug 403475, if you have a local type defined that executes a method with the same name as the enclosing method, HCR drops to the enclosing method.  Run the following snippet, add a change to LocalClass#run, save and notice two frames are popped. We shold be popping the top frame annd be back in LocalClass#run, instead we end up in TestHCR#run (the enclosing method).  package a.b.c;  public class TestHCR { 	 	public void run() { 		System.out.println(""LocalHCR#run()""); 		 		class LocalClass { 			public void run() { 				System.out.println(""LocalClass#run()""); //BP here 			} 		} 		new LocalClass().run(); 	}  	static class InnerClass { 		public void run() { 			System.out.println(""InnerClass#run()""); 			new TestHCR().run(); 		} 	}  	public static void main(String[] args) { 		System.out.println(""TestHCR#main()""); 		new InnerClass().run(); 	} }"
BETA_JAVA8:  This will be the umbrella bug for the code generation effort for JSR308. Please don't post patches here, high level discussions can be here, low level ER/CR specific discussion should be on the individual bugs.
BETA_JAVA8:  "If the compiler eliminates an annotated cast, it is required to retain the  annotations on the cast in the class file (if the annotation type has at least  RetentionPolicy.CLASS retention). When a cast is removed, the compiler may need  to adjust (the locations of) the annotations, to account for the relationship between the expression’s type and the casted-to type. Consider:" ...  At the moment ECJ is not in compliance here.
BETA_JAVA8:  This bug will be used to cover the loose ends discovered in code review of the core implementation of JSR308 code generation.  (1) Should TypeAnnotationCodeStream.invoke(byte, MethodBinding, TypeBinding,  TypeReference[]) be checking for ASTNode.HasTypeAnnotations ?  (2) Is ExtendedAnnotation violating javadoc of  IExtendedAnnotation.getLocalVariableTable() ?  (3)  CodeStream(s): Is the method CodeStream.newArray(TypeReference,  ArrayBinding) needed ?   (4) ClassFile.addFieldAttributes: Needs a relook. When a field declaration  carries a type annotation (or for that matter when a type annotation occurs in  any place where a Java SE5 annotation can occur, we leave it annotating the  declared entity - i.e the type annotation is not moved to the type.) So code  fragments like if (fieldType.bits & ASTNode.HasTypeAnnotations) != 0) may not  get executed at all. Until the resolve phase, we don't know whether an  annotation is a type declaration and so the HasTypeAnnotations bit cannot be set  in these places.  For concern 4, Andy's initial response is available at  https://bugs.eclipse.org/bugs/show_bug.cgi?id=383624#c54  I feel the suggestion to set the bit only during resolution is a good one.
Created attachment 231612 [details] Screenshot - 'default' in Extract Method dialog  As per JSR 335 Part H and bug 401223: "To avoid confusion with the default modifier, the access level given implicitly to unmodified declarations in classes is now referred to as package access rather than default access;"  The access modifier 'default' used in different dialogs related to methods (like Extract Method, Change Method Signature), could now be changed to 'package-access' or something else to avoid confusion with the modifier 'default' used to declare a default method.
This is a special consideration in the area of bug 390889:  Try to compile this class     public abstract class Foo<E> implements java.util.List<E> { }  using ECJ 4.3 against early access JRE 1.8 (b90). Result is:    Duplicate methods named spliterator with the parameters () and () are inherited from the types List<E> and Collection<E>  While Oracle says that this situation isn't and shouldn't be supported, Andy Clement has the details why this *is* an important use case for Eclipse.   I was surprised to learn that this works just fine using ECJ 4.3 M6 but produces the above error since M7. I had hoped to find a bug in one of the commits of M7, but my analysis is this:  The change is caused by the fix for bug 395681, but its impossible to pin point a particular problem in that fix because parts of the relevant method MethodVerifier15.checkMethods() have been essentially re-written, so direct code  comparison doesn't help much.  However, I see a simple and safe way of fixing the issue for now. I have a one-line patch in testing that simply prevents the application of one particular check against unexpected non-abstract methods in interfaces. Looking at MethodVerifyTest this already reduces the number of failures (when running on JRE 1.8), I'm currently looking for a way to make this test run green even on JRE 1.8.  I'll post a proposed patch in a little while.
BETA_JAVA8 and master  The "Add unimplemented methods" quick fix should not create stubs for default methods.  public class MyString implements CharSequence { }  => When compiling against a 1.8 JRE, the quick fix also adds stubs for chars() and codePoints(), which are new default methods in CharSequence.  "Source > Override/Implement Methods" already looks good (only selects abstract methods).
"According to Lambda specification ""Any local variable used but not declared in a lambda body must be definitely assigned  before the lambda body."" http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/B.html  Eclipse 4.3 permits assigning a local variable before a lambda expression within the lambda expression.  public class Sample{  interface Int { 		void setInt(int[] i);  	} public static void main(String[] args) {    int j; 		  		Int int1 = (int... i) -> { 			j=10; 		};  }  }"
Up to Java 7, every reference to a type had the same ITypeBinding, and the annotations could only come from the type's declaration. Now, reference type bindings can carry different TYPE_USE annotations, but this is not reflected in the ITypeBinding API.  We need to find the right solution to identify TYPE_USE annotation from ITypeBinding.
MoveInnerToTopLevelTests.test25 throws error during tearDown because it can't delete some resource.  test26 then probably fails due to this.   http://download.eclipse.org/eclipse/downloads/drops4/I20130602-2000/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html   Problems encountered while deleting resources.  Java Model Exception: Core Exception [code 566] Problems encountered while deleting resources. at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:175) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.PackageFragment.delete(PackageFragment.java:158) at org.eclipse.jdt.ui.tests.refactoring.RefactoringTest.tearDown(RefactoringTest.java:141) at org.eclipse.jdt.ui.tests.refactoring.MoveInnerToTopLevelTests.tearDown(MoveInnerToTopLevelTests.java:85) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Workspace.delete(Workspace.java:1441) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResources(JavaModelOperation.java:345) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.deletePackageFragment(DeleteResourceElementsOperation.java:53) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:110) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Workspace.delete(Workspace.java:1441) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResources(JavaModelOperation.java:345) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.deletePackageFragment(DeleteResourceElementsOperation.java:53) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:110) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.PackageFragment.delete(PackageFragment.java:158) at org.eclipse.jdt.ui.tests.refactoring.RefactoringTest.tearDown(RefactoringTest.java:141) at org.eclipse.jdt.ui.tests.refactoring.MoveInnerToTopLevelTests.tearDown(MoveInnerToTopLevelTests.java:85) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Contains: Could not delete '/TestProject1370245265306/src/A.java'. Contains: Could not delete 'C:\hb\workspace\ep4-unit-win32\workarea\I20130602-2000\eclipse-testing\test-eclipse\eclipse\refactoring_folder\TestProject1370245265306\src\A.java'.
IntroduceIndirectionTests.test31 fails with an error while deleting resources.  http://download.eclipse.org/eclipse/downloads/drops4/I20130602-2000/testresults/html/org.eclipse.jdt.ui.tests.refactoring_win32.win32.x86_7.0.html   Problems encountered while deleting resources.  Java Model Exception: Core Exception [code 273] Problems encountered while deleting resources. at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:175) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.CompilationUnit.delete(CompilationUnit.java:471) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helper(IntroduceIndirectionTests.java:122) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helperPass(IntroduceIndirectionTests.java:127) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.test31(IntroduceIndirectionTests.java:306) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Resource.delete(Resource.java:816) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResource(JavaModelOperation.java:331) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:107) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources. at org.eclipse.core.internal.resources.Resource.delete(Resource.java:816) at org.eclipse.jdt.internal.core.JavaModelOperation.deleteResource(JavaModelOperation.java:331) at org.eclipse.jdt.internal.core.DeleteResourceElementsOperation.processElement(DeleteResourceElementsOperation.java:107) at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:163) at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:90) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:793) at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:135) at org.eclipse.jdt.internal.core.CompilationUnit.delete(CompilationUnit.java:471) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helper(IntroduceIndirectionTests.java:122) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.helperPass(IntroduceIndirectionTests.java:127) at org.eclipse.jdt.ui.tests.refactoring.IntroduceIndirectionTests.test31(IntroduceIndirectionTests.java:306) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34) Contains: Could not delete 'C:\hb\workspace\ep4-unit-win32\workarea\I20130602-2000\eclipse-testing\test-eclipse\eclipse\refactoring_folder\TestProject1370245576152\src\p\Test.java'.
I20130531-2000.  PropertiesFileQuickAssistTest.testRemoveProperty3 and testRemoveProperty4 failed.  http://download.eclipse.org/eclipse/downloads/drops4/I20130531-2000/testresults/html/org.eclipse.jdt.ui.tests_macosx.cocoa.x86_5.0.html   nls file expected:<... static String Test_[]2; } > but was:<... static String Test_[1; public static String Test_]2; } >  junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]2; } > but was:<... static String Test_[1; public static String Test_]2; } > at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty3(PropertiesFileQuickAssistTest.java:641) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)   nls file expected:<... static String Test_[]5; public static...> but was:<... static String Test_[3; public static String Test_4; public static String Test_]5; public static...>  junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]5; public static...> but was:<... static String Test_[3; public static String Test_4; public static String Test_]5; public static...> at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124) at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty4(PropertiesFileQuickAssistTest.java:709) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.extensions.TestSetup.run(TestSetup.java:27) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
The Javadoc in javax.lang.model's package-info.java (in attached source) contains: "{@linkplain javax.annotation.processing annotation processing}"  The parsing of this link fails in JavaElementLinks#parseURI(URI) because the "if (element instanceof IPackageFragment)" branch only resolves types, but not packages. We should use the same code as in "if (element instanceof IType)" to resolve a link to package as well.  Also need to check whether the Javadoc tool supports links to members. If it does, then reuse that part of "if (element instanceof IType)" as well.  And last but not least, Javadocs of JavaElementLinks need to tell that refTypeName can also refer to a package.
Created attachment 231869 [details] Screenshot  In Refactoring wizards like Change Method Signature and Introduce Parameter Object, the Method signature preview for default methods does not show the default modifier. Attached the screenshot.
"Created attachment 231871 [details] Screenshot  Refactor > Introduce Indirection on default and static methods in an interface gives the error ""Cannot place new method on an interface."" as shown in the attached screenshot.  Expected result for the default method is shown below:   public interface I {  	public static void foo(I i) { 		i.foo(); 	}  	default void foo() {  	} }"
"Extracting Javadoc from Java-SE-7-style generated doc doesn't work reliably.   In some cases, only parts of the main description are shown (classes, enums, interfaces). In some cases (annotations, methods), there are unnecessary bullets.  Example:  package p;  import java.util.ArrayList; import java.util.List; import javax.annotation.Generated;  public class P { 	@Generated(value = { ""meee"" }) 	ArrayList<Integer> f = new ArrayList<>((List<Integer>) null); 	@Deprecated 	Thread.State s; 	{ 		s.equals(f); 	} }"
Created attachment 231928 [details] Video of the problem with autocompletion  If you have a method signature like this: StringTools.concatenateWithSeparator(String sep, String... input) Typing "," as seperator will not work as expected.  When you have typed ",  it will not write the comma out, but jump to next field. It also happens if you first type "" and then later want to add comma inside the String. It will not write comma out but jump to next field.  However sometimes when you try it the second time, it seems to work.  I have attached video of the problem  What it should do: When you are inside String delimiters, do not jump to next field on comma
"Created attachment 231968 [details] Screenshot  Consider the following example:  public interface I {  }  class X { 	static int get() { // Move 'get' 		return 0; 	} }  Refactor > Move on get(). We get Move Static Members wizard.  Select Destination type for get() as the interface I. Click Preview -> Error is shown as in the attached screenshot. Click Continue and then OK. Refactoring is completed without any compilation error.  The error in the Preview should not be shown."
Created attachment 232033 [details] Fix  schema.css is missing in /org.eclipse.jdt.doc.isv/build.properties since bug 396098. This makes the rendering of all JDT extension point docs ugly.
"public interface I {         default void foo(XYZ xyz) {	 	} }  class XYZ {}  Refactor > Move on method ""foo(XYZ)"". It brings up the ""Textual Move"" wizard.  Moving a default method is like moving an instance method, so Move Instance Method refactoring should be adjusted to handle it.  Default methods can be with/without a valid target type and we will have to retain or remove 'default' depending on the target type."
Created attachment 232043 [details] Fix  4.3.0.I20130605-2000, spawned from bug 409765  Some Javadoc extracted from generated html is rendered with bullets that don't make sense. The problem is the new Javadoc tool/stylesheet that is used since JDK 7. It generates <ul> tags that are set to "list-style:none;" via CSS.  I think the best fix is to include these CSS tweaks in our CSS.  The bullets are visible at the beginning of extracted methods, constructors, and fields, and at the end of class/interface Javadocs.
"BETA_JAVA8  CCE when trying to parse method reference expression with inappropriate type arguments:  //--------------------- package jsr335;  import java.io.Serializable; import java.util.concurrent.Callable;  public class MethodReference {     class Inner<E> {      }      void foo() {         Callable<Inner<String>> fi = MethodReference.Inner::<Serializable> new;     } } //---------------------  Note that the example doesn't make sense, and I didn't try to make it ""right"". Similar exceptions happen when I remove the <Serializable> or add type arguments after MethodReference.Inner.   java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding 	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:119) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.generateCode(LocalDeclaration.java:143) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:304) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:249) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:367) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1213) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
"interface I { 	private static void foo() { // Error [1] 	} 	 	private default void bar() { // Error [2] 	}	 }  [1]  'Remove invalid modifier' quick fix removes 'static' modifier also along with 'private'.   [2]  No quick fix is available.  The quick fix should be updated to handle static and default interface methods at ModifierCorrectionSubProcessor.addRemoveInvalidModifiersProposal(..)."
"public interface I1 { 	default void foo(int i) { // quick assist on 'i' [1] 		System.out.println(i); 	} 	 	static void bar(int i) {  // quick assist on 'i' [2] 		System.out.println(i); 	} }  Quick assist 'Assign parameter to new field' on 'i' as shown above, creates the following:  [1] private int i; default void foo(int i) { 	this.i = i; 	System.out.println(i); }  [2] private static int i; static void bar(int i) { 	I1.i = i; 	System.out.println(i); }  The modifier 'private' on newly created fields is incorrect. Also, fields in an interface are 'final' and cannot be assigned again in the method.  This leads to compilation errors."
Created attachment 232112 [details] Reduced Test Case  I know there other bugs related to this message (ie. 239639, 320965, 391528) but this issue deals with backward compatibility with JDK 1.4 'built' jars.  Steps to reproduce the problem:  1. Import the two projects from the attached zip J14 (1.4 level) J16 (1.6 level) 2. Export J14 as a jar 3. Bring up the properties for J16 and add the jar to its Java build path. 4. Open the Main class in J16 using the Java Editor --> You will see the errror message 5. If you run the Main class as a Java Application, it works as expected. This shows backward compatibility of 1.4 level jars.    The error message is misleading because the type/class is actually present in the jar.
"Created attachment 232173 [details] Class that compiles to different override behaviors between javac and eclipse (4.3RC3)  When compiling the attached java file using javac and eclipse 4.2, no compilation errors occur. Using Eclipse 4.3RC3 (4.3M6 also has this issue) gives a compilation error:  The type Main.SubSub must implement the inherited abstract method Main.Base<Main.F3>.foo(Main.F3)	Main.java(42)  Removing the 'abstract' keyword from the Main#Sub class also removes the compilation error, as does implementing a `foo(F3 f)` method. The Eclipse generated byte code results in different runtime behavior when compared to the output generated by the javac compiler.  An implementation of the foo(F3) method in the SubSub type (with the Sub type remaining abstract):   	@Override 	public void foo(F3 bar) { 		System.out.println(getClass().getSimpleName() + "": F3 + "" 				+ bar.getClass().getSimpleName()); 		bar.bar(); 	}  The expected result as given by javac/java      SubSub: F3 + F3     bar in F3     SubSub: F3 + F3     bar in F3     SubSub: F3 + F3     bar in F3     SubSub: F2 + F2  The result as given by the eclipse compiler:      SubSub: F3 + F3     bar in F3     SubSub: F2 + F3     SubSub: F3 + F3     bar in F3     SubSub: F2 + F2  As you can see the call to 'sub2.foo(f3);' performed in Main#main(), line 11 gives a strange result, whereas the call in line 12 does call the correct function (giving the expected result when compared to javac)  Commandline java version:  java version ""1.7.0_21"" Java(TM) SE Runtime Environment (build 1.7.0_21-b12) Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)"
Created attachment 232190 [details] Fix  4.3 RC4  In BETA_JAVA8 in org.eclipse.jdt.core.dom.ASTConverter, I tried to generalize a type reference "org.eclipse.jdt.internal.compiler.ast.LambdaExpression" to "org.eclipse.jdt.internal.compiler.ast.Expression".  The refactoring added an import for "Expression", although a homonym from the enclosing package org.eclipse.jdt.core.dom was already in use.
4.3 RC4.
4.3 RC4.
"The closing bracket hover after an ""else if"" should include all preceding ifs.  Example:  		if (i == 1) { 			int i1; 			int i2; 			int i3; 			int i4; 		} else if (i == 2) { 			new I1(); 			new I2(); 			new I3(); 			new I4(); 		} else {         // hover on ""}"" only shows one if, not both 			test1(); 			test2(); 			test3(); 			test4(); 		}                // hover on ""}"" shows all ifs     After bug 377141, the hover on the ""}"" of an ""else"" branch now shows all preceding ""if"" expressions. The same should be implemented for the ""}"" of an ""else if"" branch in the same ""if"" (... ""else if"")+ (... ""else"")? structure."
In Java source editors, the argument of an {@code *} or {@literal *} tag in Javadoc should not use "HTML markup" coloring.  E.g. "<String>" is not an HTML tag and should be rendered the same as "Set" here:   * {@code Set<String>}
- Create a package com.p1 and add the following annotation type in it:  package com.p1;  import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; i
http://download.eclipse.org/eclipse/downloads/drops4/I20130618-0800/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html  Although there is another failure reported with the same test via bug 399351, this failure is quite different from the previously reported one.  Stack trace:  zip file closed  java.lang.IllegalStateException: zip file closed at java.util.zip.ZipFile.ensureOpen(ZipFile.java:632) at java.util.zip.ZipFile.getInputStream(ZipFile.java:345) at java.util.jar.JarFile.getInputStream(JarFile.java:403) at org.eclipse.jdt.internal.core.index.JarIndexLocation.getInputStream(JarIndexLocation.java:89) at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:623) at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:199) at org.eclipse.jdt.internal.core.index.Index.query(Index.java:143) at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:310) at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2297) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:269) at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:109) at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:65) at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:277) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:214) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515) at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:844) at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:832) at org.eclipse.jdt.core.tests.model.JavaIndexTests.testPlatformJarIndexFile(JavaIndexTests.java:840) ...
The following code complains that the FileInputStream may leak. It is inside a try-with-resource statement therefore as far as I can tell this warning is erroneous.  ------------------------------------------ import java.io.FileInputStream;  class Bug {   void a(boolean b) throws Exception {     try(FileInputStream in = b ? new FileInputStream("a") : null){}   } }  --------------- Version: 4.3.0 Build id: I20130516-2200
We need to update the parent poms from 4.3.0-SNAPSHOT to 4.4.0-SNAPSHOT  PW
Created attachment 232557 [details] eclipse.jdt  We need to update the parent poms from 4.3.0-SNAPSHOT to 4.4.0-SNAPSHOT  PW
"import java.util.function.Function;  public class TestMethodRef {  	public static void main(String[] args) { 		Function<String, Integer> f = Integer::new; 	}  }  This is accepted by javac(of course, 8) but throw an error in my onw built BETA_JAVA8. From the semantics of lambda, it should be ok. Note, BETA_JAVA8 is a method ref, but not a method invocation.  This is so common, but we forget to implement it? Or, may I have a wrong build for BETA_JAVA8?  Anywhere, team, good work in these months!   thanks,  Jin"
In a project with 12000 jars in the classpath, resolveClasspath is taking more than 8 secs and in that more than 90% of time is spent on checking whether each library entry and it's source attachment is a file or directory.  Here is the call tree I captured with jProfiler.  8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath  8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath   8,836 ms org.eclipse.jdt.internal.core.JavaProject.resolveClasspath    8,548 ms org.eclipse.jdt.internal.core.JavaProject.addToResult     8,195 ms org.eclipse.jdt.internal.core.ExternalFoldersManager.isExternalFolderPath      7,548 ms java.io.File.isFile       7,548 ms java.io.UnixFileSystem.getBooleanAttributes        7,141 ms java.io.UnixFileSystem.getBooleanAttributes0  It's hitting us very badly, because we also use a classpath container to hold our jars and container classpath is resolved 8 to 10 times on UI thread while constructing the package explorer tree.  I am working on a patch to cache the external archives list (similar to nonChaineedJars) in JavaModelManager to avoid this repetitive I/O in resolve classpath and will soon attach it to the bug.
"package p; public class A { 	protected void m(){} }   package p; public class B { 	public void n(q.C c, A a) { 		a.m(); 	} }  package q; public class C {  }  When p.B.n(q.C, A) is moved to q.C, Eclipse move-refactoring pops up a warning message:  ""The visibility of method `p.A.m()' will be changed to public.""  When I click the `continue' button to finish the refactoring, p.A.m() is still `protected' (no changes).  That is an error."
If i do ctrl-shift-u on a identifier i get a list of lines in the search view where those are found. But the line numbers that are reported are 1 off. It does jump to the right line but it is funny to see that the search view reports "203:" and the actual code is according to the line of the ruler is on  204  It seems that the search view reports 0 based but the line number ruler starts with 1    Eclipse SDK  Version: 4.3.0 Build id: I20130605-2000
"With the save action ""Convert 'for' loops to enhanced 'for' loops"" enabled,  the conversion to enhanced loop might introduce a logical error.  Lets suppose you have an object ""s"" with a class implementing java.lang.Iterable and this class has also another method named ""iterator"", also with an ""Iterator"" return type, BUT with a __non empty signature__.  for (Iterator<Object> it = s.iterator(42) ; it.hasNext(); ) { 	Object obj = it.next(); 	// ... }  The save action will convert it to an enhanced loop assuming the use of ""s.iterator()"" instead of ""s.iterator(42)"" !  for (Object obj : s) {  	// ...		  }  (The bug exists also in 3.7.2 and probably in all releases until Kepler)"
"When JDT/Core will move up to 3.10.0 one of the regular expressions in export-ecj.xml will no longer work, see this snippet:  	<condition property=""bundleVersionOK""> 		<matches pattern=""\d\.\d\.\d.*"" string=""${bundleVersion}""/> 	</condition> 	<fail message=""bundleVersion variable had unexpected format. Should be digit.digit.digit,ANY but was ${bundleVersion}"" unless=""bundleVersionOK""/> 	<script language=""javascript""> 		var bundleVersion = project.getProperty(""bundleVersion""); 		var pattern = new RegExp(/^(\d+)\.(\d+)\.(\d+)\.(.*)$/);  the final pattern will work for 3.10.0, too, but the former will not, since it lacks the '+' tokens. Also the fail message could use improvement at that time.  BTW: when are we going to bump it up to 3.10.0?"
Created attachment 232751 [details] Stack trace  I noticed that when I saved a Java file, the UI would be come unresponsive for about 5 seconds.  I did a stack trace (attached) and noticed that the main thread seemed to be hung up somewhere in the project explorer.  When I unchecked "Link With Editor" this delay went away.  I tried doing the same action on the exact same workspace in Indigo and did not notice the same delay.  My workspace is very large (100+ projects, maybe 50-100K files).  I'm using: Version: 4.3.0 Build id: I20130605-2000
"If you are typing a floating point number say 3.14 then content assist window pops up after typing '.', e.g. in this situation below 	void bar() { 		System.out.println(3.); 	}  Tried this with 4.3 RC4. (Likely a consequence of changes for showing Template and keyword proposals without prefix)"
This is pretty similar to bug 380896 but the test case is slightly different -- the enum is declared in a separate file.   // file TestEnum.java enum TestEnum { FOO; }  // file NullTest.java public class NullTest {   public static TestEnum bla() {     @javax.annotation.Nonnull final TestEnum t = TestEnum.FOO; // Null type safety: The expression of type TestEnum needs unchecked conversion to conform to '@Nonnull TestEnum'     return t;   } }  Eclipse is configured to use 'javax.annotation.CheckForNull' for 'Nullable' annotation, 'javax.annotation.Nonnull' for 'NonNull' and the 'NonNullByDefault' is left unchanged. The annotations are as downloaded from http://code.google.com/p/jsr-305/ SVN.  Strangely enough, moving TestEnum to the same file as NullTest (as in the test case in bug 380896) makes the issue go away.  Eclipse SDK Version: 4.3.0 Build id: I20130605-2000
When I rerun a test by selecting "Run" from the JUnit test results view context menu the test launch is happening on the UI thread. When build before launch is enabled the project build is invoked on UI thread on Eclipse is frozen during the test launch process.  I am working on a patch to avoid it by delegating the rerun config launching to DebugUITools.launch() and will attach it to the bug soon.  A sample stack trace captured during the freeze is ...  java.io.UnixFileSystem.createDirectory(Native Method)                 java.io.File.mkdir(File.java:1239)                 java.io.File.mkdirs(File.java:1266)                 org.eclipse.core.internal.filesystem.local.LocalFile.mkdir(LocalFile.java:286)                 org.eclipse.core.internal.localstore.FileSystemResourceManager.write(FileSystemResourceManager.java:1132)                 org.eclipse.core.internal.resources.Folder.internalCreate(Folder.java:180)                 org.eclipse.core.internal.resources.Folder.create(Folder.java:107)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.createFolder(AbstractImageBuilder.java:470)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder$1.visit(AbstractImageBuilder.java:254)                 org.eclipse.core.internal.resources.Resource$1.visitElement(Resource.java:85)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:82)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)                 org.eclipse.core.internal.watson.ElementTreeIterator.iterate(ElementTreeIterator.java:127)                 org.eclipse.core.internal.resources.Resource.accept(Resource.java:95)                 org.eclipse.core.internal.resources.Resource.accept(Resource.java:52)                 org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.addAllSourceFiles(AbstractImageBuilder.java:219)                 org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:51)                 org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)                 org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)                 org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)                 org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)                 org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)                 org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)                 org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:256)                 org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:394)                 org.eclipse.core.internal.resources.Project$1.run(Project.java:618)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)                 org.eclipse.core.internal.resources.Project.internalBuild(Project.java:597)                 org.eclipse.core.internal.resources.Project.build(Project.java:114)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate$1.run(LaunchConfigurationDelegate.java:423)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)                 org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2326)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildProjects(LaunchConfigurationDelegate.java:430)                 org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildForLaunch(LaunchConfigurationDelegate.java:126)                 org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:823)                 org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:704)                 org.eclipse.jdt.internal.junit.model.TestRunSession.rerunTest(TestRunSession.java:485)                 org.eclipse.jdt.internal.junit.ui.TestRunnerViewPart.rerunTest(TestRunnerViewPart.java:2062)                 org.eclipse.jdt.internal.junit.ui.RerunAction.run(RerunAction.java:52)                 org.eclipse.jface.action.Action.runWithEvent(Action.java:498)                 org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)                 org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)                 org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)                 org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)                 org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1276)                 org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3554)                 org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3179)
In JSE7 we have no way to figure out the nullness of a foreach element variable. Using type annotations this becomes (easily) possible, it just needs special treatment in the compiler since we don't have the AST that assigns the element variable.  See also this TODO in ForeachStatement.analyseCode():  " once we have JSR 308 fetch nullStatus from the collection element type   and feed the result into the above check (instead of FlowInfo.UNKNOWN)"
We get an compiler error with the following code (one file for each interface / class):  @NonNullByDefault public interface Foo<V> {   V bar(String... values); }  @NonNullByDefault public class FooImpl implements Foo<String> {   @Override   public String bar(final String... values) {     return ("");   } }  The compiler reports the following error for the class: "Illegal redefinition of parameter values, inherited method from Foo<String> does not constrain this parameter".  Adding a @NonNull to the "values" parameter in Foo helps, but generates a warning because of a redundant annotation.  In 4.2.2 it works fine.
I would like to be able to make it a warning if the throwable that is caught, is not used in the surrounding block.  e.g. This would be a warning try {     somethingDangerous(); } catch(Exception e) {    throw new RuntimeException(); }  but this would not try {     somethingDangerous(); } catch(Exception e) {    throw new RuntimeException(e); }  I have encountered many instances where they fail to pass in the exception as a cause, or fail to log it appropriately which makes debugging a headache.  If it were an optional warning, I would certainly have it enabled.
Links in Javadoc hover/view headers don't resolve fully-qualified types correctly.  Many examples can be found in org.eclipse.jdt.core.dom.ASTConverter, e.g. recordNodes(ASTNode node, org.eclipse.jdt.internal.compiler.ast.ASTNode oldASTNode).  The Javadoc tool generates title attributes like "class or interface in org.eclipse.jdt.internal.compiler.ast" for links to types. We could also generate titles, but we better just use "in <package>" syntax.
When an annotation is repeated, it should be emitted as part of its container annotation.
If the annotation processing supports it, enable accessing the decoded method parameter names during processing of annotations.
If a Repeatable annotation is present on an annotation declaration (T), semantics must be checked: Informally:  - The collections type's (TC) declaration must have a array of Ts as its value()  - The @Retention meta-annotation of TC must at least include the retention of T  - TC's @Targets, if specified, must be a subset or the same as T's @Targets  - If T is @Documented, then TC should also TC be Documented  - If T is @Inherited, then TC should also TC be @Inherited
The current check for duplicated annotations need a going over. If an annotation T is repeated at its use, it should be allowed, if:  - If the annotation declaration T has a Repeatable meta-annotation mentioning TC as the container  - if TC is allowed as the target where T is repeated  If T and TC is both used in the same context, it is an error (even if neither T nor TC is repeated)  Further, if TC is deprecated, a deprecation warning should be issued, even if T is not deprecated.  We should have a configurable warning if the multiple T's aren't contiguous.
Created attachment 233006 [details] Two classes that reproduce the bug  Please refer to the attached java files to reproduce this:  When calling a method with a @Deprecated annotation from within a lambda method, the JDT core crashes with the following Exception:  eclipse.buildId=4.4.0.I20130630-1602 java.version=1.7.0_25 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Command-line arguments:  -os linux -ws gtk -arch x86_64   Error Tue Jul 02 16:11:10 PDT 2013 Error in JDT Core during AST creation  java.lang.ClassCastException   Please note that this only happens if the deprecated method belongs to a different class than the one that contains the lambda.
"Created attachment 233034 [details] Source Code  Build 20130614-0229  Create a new project with the attached source code and enable the annotation based null analysis and suppress optional errors with @SuppressWarnings. IllegalArgumentException is thrown in ""XYZManagementDialog"" (both in incremental and clean build).  Disabling the null analysis or removing one of the instance fields resolves the error. I have other dialogs with the same hierarchy and more or less the same design where the problem does not occur so it may be caused by some sprecific field pattern.  Stacktrace: !ENTRY org.eclipse.jdt.ui 4 2 2013-07-03 14:45:58.710 !MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". !STACK 0 java.lang.IllegalArgumentException: info cannot be null 	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81) 	at org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:4561) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:3375) 	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1190) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:296) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:228) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:562) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:631) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:360) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1206) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:685) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1181) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
Inspect all casts to and instance of checks for AbstractMethodDeclaration to eliminate potential CCEs" (when the operand of cast/instanceof is MethodScope.referenceContext)  This is a follow up of bug 412155 comment 3
Created attachment 233126 [details] Fix  While working on a regression test for bug 410207 I was puzzled why my test fails when I set compliance to 1.5 (expected without fix for bug 410207) but then surprisingly passes without any problem when I set compliance to 1.6. It turned out that "1.6" is not correctly transformed into compiler options inside AbstractJavaModelTests.createJavaProject(*). Unless there is a reason to ignore "1.6", it seems that all tests that use these helper methods with compliance "1.6" are tested with bad compiler options.
"Get git://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git BETA_JAVA8 and git://git.eclipse.org/gitroot/jdt/eclipse.jdt.ui.git master into Eclipse  Open new workspace Clone https://github.com/nurkiewicz/LazySeq. I used the CLI as I did not have then maven plugin at this time.  run mvn eclipse:eclipse compile (with the Java 8 EA) Create the library M2_REPO, point to ~/.m2/repository  Here is the tail of the stack trace  	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:75) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:100) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:75) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:100) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:140) 	at org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor.java:85)"
40 failures in Rename* tests.  Failed on a N-build [1] and on latest M-Build [2].   [1]http://download.eclipse.org/eclipse/downloads/drops4/N20130706-1500/testresults/html/org.eclipse.jdt.debug.tests_win32.win32.x86_7.0.html  [2] http://download.eclipse.org/eclipse/downloads/drops4/M20130703-0800/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html
N20130709-2000.  ResourceLeakTests.testBug381445_1b failed.  http://download.eclipse.org/eclipse/downloads/drops4/N20130709-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_linux.gtk.x86_6.0.html   Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in Bug381445.java (at line 8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed\n ----------\n ------------ but was ------------ ----------\n 1. ERROR in Bug381445.java (at line 15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type\n ----------\n --------- Difference is ---------- expected:<...81445.java (at line [8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed]\n ----------\n > but was:<...81445.java (at line [15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type]\n ----------\n >  junit.framework.ComparisonFailure: Invalid problem log . ----------- Expected ------------ ----------\n 1. ERROR in Bug381445.java (at line 8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed\n ----------\n  ------------ but was ------------ ----------\n 1. ERROR in Bug381445.java (at line 15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type\n ----------\n  --------- Difference is ---------- expected:<...81445.java (at line [8)\n ResultSet rset2 = stat.executeQuery(q2);\n ^^^^^\n Potential resource leak: 'rset2' may not be closed]\n ----------\n > but was:<...81445.java (at line [15)\n Closeables.closeQuietly(rset2);\n ^^^^^^^^^^^^\n The method closeQuietly(AutoCloseable) from the type Closeables refers to the missing type AutoCloseable\n ----------\n 2. ERROR in Bug381445.java (at line 30)\n public static void closeQuietly(java.lang.AutoCloseable closeable) {}\n ^^^^^^^^^^^^^^^^^^^^^^^\n java.lang.AutoCloseable cannot be resolved to a type]\n ----------\n > at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:238) at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:214) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:873) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2285) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2120) at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:1922) at org.eclipse.jdt.core.tests.compiler.regression.ResourceLeakTests.testBug381445_1b(ResourceLeakTests.java:4098) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
While compiling the Project mentioned in bug 412453 description. Will extract a small test case soon.
I believe there is an internal implementation for this - org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isFunctionalInterface(Scope)  See also bug 403749.
On the JREs preference page the only way you can tell if a JRE is contributed is if you select it and the 'Delete' button disables or you noticed the '(locked)' text in the label - which should probably be changed to '(contributed)'.   We should colour it the same way we do on other pages that show items that have been contributed - for example entries on the Classpath Variable page.
During the classpath validation first all the classpath entries are validated and then the validation status is not reported for the optional entries. Due to that when large number of optional entries existed on classpath a majority of portion is spent on their validation which is of no use.  In a project with 12000+ optional library jars, setRawclaasspath is spending  more than 90% of time on this unnecessary validation. Here is the call tree captured with a profiler ...  - 21,925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath  - 21,925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath   - 21,925 ms org.eclipse.jdt.internal.core.JavaModelOperation.runOperation    - 21,675 ms org.eclipse.core.internal.resources.Workspace.run     - 21,675 ms org.eclipse.jdt.internal.core.JavaModelOperation.run      - 21,675 ms org.eclipse.jdt.internal.core.SetClasspathOperation.executeOperation       - 20,500 ms org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged        - 20,376 ms org.eclipse.jdt.internal.core.ClasspathValidation.validate         - 20,214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry          - 20,214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry           - 19,978 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryEntry            - 13,461 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryContents             - 13,461 ms org.eclipse.jdt.internal.core.JavaModelManager.verifyArchiveContent              - 12,023 ms org.eclipse.jdt.internal.core.JavaModelManager.getZipFile               - 12,006 ms java.util.zip.ZipFile.<init>                - 5,511 µs org.eclipse.core.internal.resources.Workspace.getRoot                 - 5,439 µs org.eclipse.core.runtime.Path.toFile                  - 1,438 ms org.eclipse.jdt.internal.core.JavaModelManager.closeZipFile  I am working on a patch to avoid this unncessery validation and will send it across soon.
When I enable the conditional breakpoint checkbox, I often use the "Debugging by writing to console" trick from the JDT Tips & Tricks:    System.out.println("some info");   return false;  It would save some typing if the line    return false;  would already appear by default. This would also be a nice hint for new users that they should modify that expressions, since "return false;" is probably not the condition they actually need.
See bug 413067.
There is no (more) way "to create a Run/Debug Configuration for a Java  Project which contains "empty" Program Parameters." under windows.  From the commandline/shell (windows/linux) the parameter '""' would be parsed into an empty string as expected. Using the same argument in a Run/Debug Configuration (under Windows) you now get two double-quotes.  Maybe this bug(fix):  https://bugs.eclipse.org/bugs/show_bug.cgi?id=387504  ... reintroduced two old bugs:  https://bugs.eclipse.org/bugs/show_bug.cgi?id=24260 https://bugs.eclipse.org/bugs/show_bug.cgi?id=70955
N20130721-2000.  http://download.eclipse.org/eclipse/downloads/drops4/N20130721-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_linux.gtk.x86_6.0.html   Unexpected error output for invocation with arguments ["/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java" -extdirs "" -1.5 -g -preserveAllLocals -proceedOnError -referenceInfo -d "/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression" ]. ----------- Expected ------------ ----------\n 1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error) ------------ but was ------------ ----------\n 1. ERROR in /opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n --------- Difference is ---------- expected:<...-----\n 1. ERROR in [---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)]> but was:<...-----\n 1. ERROR in [/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n ]>  junit.framework.ComparisonFailure: Unexpected error output for invocation with arguments ["/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java" -extdirs "" -1.5 -g -preserveAllLocals -proceedOnError -referenceInfo -d "/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression" ]. ----------- Expected ------------ ----------\n 1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error) ------------ but was ------------ ----------\n 1. ERROR in /opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n  --------- Difference is ---------- expected:<...-----\n 1. ERROR in [---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)]> but was:<...-----\n 1. ERROR in [/opt/users/hudsonbuild/workspace/ep4-unit-lin64/tmp/comptest/run.1374471774974/regression/X.java (at line 3)\n sun.net.spi.nameservice.dns.DNSNameService dummy;\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n sun.net.spi.nameservice.dns cannot be resolved to a type\n ----------\n 1 problem (1 error)\n ]> at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:238) at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:214) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runTest(BatchCompilerTest.java:635) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runNegativeTest(BatchCompilerTest.java:463) at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.test024(BatchCompilerTest.java:2550) at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
4.3.  When having the jdt.debug tests installed, VMInstallTests destroys error reporting because AbstractDebugTest sets ErrorDialog.AUTOMATED_MODE = true when the library location resolvers is loaded.
"REPRODUCING THE PROBLEM: Create a workspace with two java projects. In the Java-Compiler ""Errors/Warning"" -settings turn on ""enabled annotation-based null-analysis"".  Put the following Class into the first project:  import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class Class2 { 	public Class2(String nonNullArg) { 		assert nonNullArg != null; 	}  	public static Class2 create(String nonNullArg) { 		return new Class2(nonNullArg); 	} }  Now create this class in the other project, configure the build path settings.  public class Class1 { 	public static Class2 works() { 		return Class2.create(null); 	}  	public static Class2 bug() { 		return new Class2(null); 	} }  Do a clean build.  PROBLEM: If you open Class1 in the editors, you will see two warnings, but in the problems view, there will be only one warning for ""works"", but no warning in ""bug"".  ANALYSIS: When compiling for the editor, Class2 is accessed via a SourceTypeBinding, and org.eclipse.jdt.internal.compiler.lookup.MethodBinding.parameterNonNullness is initialized in both cases. The compilation for the ""problems view"" accesses Class2 as BinaryTypeBinding.  In BinaryTypeBinding, there is code to inherit the nullness-settings in  org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanFieldForNullAnnotation(IBinaryField, FieldBinding) and org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanTypeForNullDefaultAnnotation(IBinaryType, PackageBinding, BinaryTypeBinding), but not for methods in org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanMethodForNullAnnotation(IBinaryMethod, MethodBinding).  It still works for the ""Class2#create"" invocation from ""Class1#works"", because org.eclipse.jdt.internal.compiler.lookup.MethodBinding.parameterNonNullness is initialized in org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(BlockScope) with ImplicitNullAnnotationVerifier. The corresponding code in org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(BlockScope) seems to be missing. Adding it like in the following patch makes the warnings appear in the problems view.   diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java index 2f4b127..5319d9e 100644 --- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java +++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java @@ -28,6 +28,7 @@  import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;  import org.eclipse.jdt.internal.compiler.codegen.*;  import org.eclipse.jdt.internal.compiler.flow.*; +import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;  import org.eclipse.jdt.internal.compiler.impl.Constant;  import org.eclipse.jdt.internal.compiler.lookup.*;  import org.eclipse.jdt.internal.compiler.problem.ProblemReporter; @@ -435,6 +436,11 @@  	if (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {   		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);   	} +	final CompilerOptions compilerOptions = scope.compilerOptions(); +	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) { +		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations) +				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope); +	}  	return allocationType;  }"
"The AST for a multi-dimensional array type with annotations on the array dimensions is not well-formed. The problem is that for ArrayType nodes, the linearization of the AST (i.e. the source order of AST nodes) doesn't correspond to the language model. This is a new problem, not bug 403834 or bug 391894 comment 4.  Example:  import java.lang.annotation.*;  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented @interface A { 	int value() default 0; }  public class TestArrayAnnotations { 	@A(3) String @A(1)[] @A(2)[] arr = 			new @A(3) String @A(1)[11] @A(2)[12]; }  The AST node for the type of field 'arr' is:  ASTNode type/property  Source range ---------------------  --------------------------------- ArrayType              String @A(1)[] @A(2)[] +annotations                          @A(2) +componentType         String @A(1)[]  +annotations                 @A(1)  +componentType        String   +name                String  The problem is that this componentType is just a parsing artifact, but it doesn't make sense from a semantic point of view. As http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#array-syntax explains, the type nesting in the language model is actually going like this:  ArrayType        @A(3) String @A(1)[] @A(2)[] +annotations                  @A(1) +componentType   @A(3) String         @A(2)[]  +annotations                         @A(2)  +componentType  @A(3) String   +annotations   @A(3)   +name                String  As long as nobody could actually distinguish the different array brackets, we could live with that. I.e. it usually doesn't matter whether the component type of String[][] is String[] with the first or with the second set of brackets.  But as soon as we add annotations, the picture changes. With the current AST node structure, it's e.g. impossible to implement bug 409586 correctly, because the top-level ArrayType's annotation is ""@A(2)"", but the binding of the top-level ArrayType must have annotation ""@A(1)"", because that's the annotation on the outermost array brackets.  The type ""String @A(1)[]"" doesn't exist from a language point of view, because the annotation ""@A(1)"" annotates the type String[][], not a String[].  The only way I see how we could reconcile AST nodes and bindings would be to replace the nestable ArrayType by a FlatArrayType node with these properties: +componentType: Type (cannot be another FlatArrayType) +dimensions: List<ExtraDimension>  Then, the binding of the FlatArrayType would be identical to the binding of the leftmost dimension."
Bug 366014 added support for automatically configuring projects for the use of null annotations. For plug-in projects it inserts an additional.bundles stanza into build.properties.  I never fully understood the effect, but today I ran my first headless PDE-build on a bundle with null annotations, which failed due to bug 354724. If I understand that bug correctly, it is actually a "works-as-designed":    "The fact that PDE Build does not consider the additional.bundles property can lead     to a slightly different issue.  The property is not intended to add anything to the    build classpath, but instead allow the workspace to build when there are indirect    dependencies.  Another bundle should be adding the additional bundle as a real    (manifest) dependency."  Thus I propose to change the mechanism from bug 366014 (and the documentation) to use an optional import instead (I tried Require-Bundle, which worked, not sure if Import-Package would work and be more appropriate, or not).  As an extra data point I may want to check if/how tycho interprets these settings ...
"On extracting a default method in an interface [WIP, bug 406786], the new extracted default method is not formatted.	  For example, selecting ""return 0;"" and extracting it to a method:  interface A_test1 { 	default int foo() { 		return 0; // extract to method 	} }  Results in:  interface A_test1 { 	default int foo() { 		return extracted(); // extract to method 	}  	default int extracted(){return 0;} } -------------------------------------------  However, standalone formatting (Ctrl+Shift+F) of the above created default method works properly. Select ""default int extracted(){return 0;}"". Pressing Ctrl+Shift+F, results in:  	default int extracted() { 			return 0; 	} ------------------------------------------  On debugging, it was found that the 'kind' passed to DefaultCodeFormatter.format(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator) is K_COMPILATION_UNIT in stand-alone case (via org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format()).   And, the 'kind' is K_CLASS_BODY_DECLARATIONS (for MethodDeclaration via ASTRewriteFormatter.formatNode(ASTNode node, String str, int indentationLevel)) where it does not work. 	 In the latter case, in DefaultCodeFormatter#formatClassBodyDeclarations(..), parseClassBodyDeclarations(..) returns null. So it could be that parser encounters some error and hence further formatting is not done."
http://www.eclipse.org/jdt/apt/introToAPT.php  Follow the instructions in the given page to create a test project with annotation processing enabled. Use the demo APT provided in the same page and create the following test file:  import demo.DemoAnnotation; @DemoAnnotation(what = "spam") public class DemoAnnotationTest { }  With APT enabled, spam" should be reported by the APT and it is reported when the project's compliance level is set to 1.7. However, the same behavior can't be seen when the compliance of the project is set to 1.8. At this point, I don't know what is causing this and whether or not the APT is kicked of at all. Log file shows nothing.
APT currently handles only SE7 annotations and new code has to be added for annotations in SE8 locations, such as receiver, type use etc.  I believe AnnotationDiscoveryVisitor should be updated to provide support for new annotatable AST nodes. This needs further investigation, though.
N20130727-1500.  Error and Failure in HcrTests.  http://download.eclipse.org/eclipse/downloads/drops4/N20130727-1500/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html
The ASTParser has various problems where it generates wrong source ranges with nontrivial annotations. While investigating these problems I found the problem with the wrong nesting of ArrayType nodes (bug 413569).  The problem is that various ASTConverter#retrieve*(..) methods make wrong assumptions about the possible form of annotations. E.g. retrieveExtraDimension(..) and retrieveEndOfElementTypeNamePosition(..) assume they can just skip "@AnnotationName", but that strategy fails as soon as the annotation has arguments. retrieveProperRightBracketPosition(..) and its callers also use a similarly doomed strategy in trying to find the brackets of an array type starting from the beginning of the array type.  The loops in the retrieve*(..) methods should only skip over TokenNameCOMMENT_* tokens, and otherwise give up when they encounter an unknown token id.  The strategy should not be to scan over annotations, but to use the annotation nodes' source ranges to update the start position and then only scan for the brackets after the annotation node.   Test case with all kinds of problems (but syntactically correct):  public class ArrayTypeAnnotations extends @NonNull(int[].class) Object {     Object field = new ArrayList< @NonEmpty(Bla) int @NonNull(Bla) [] @NonEmpty(Blu) [ ]>() ;          int[][] xxx;     ArrayList<int[]> [][] yyy; // source ranges already broken in AST.JLS4     ArrayList<int[][]> [][][][] zzz;     ArrayList<Float> [][][] zzz2;     Object a = new ArrayList< @TakeType(int[].class) int @TakeType(float.class) [] @TakeType(double.class) []>() ;     Object b = new @NonNull(Math.PI) ArrayList< >() ;     Object c = new ArrayList<@NonNull(Math.PI) Object[]>() ;      void foo(int i) {         for (String tab@TakeType(int[].class) [] = null;; ++i) { break; }         for (@Deprecated String tab@TakeType(int[].class) [][]  = null;; ++i) {}     } }
"The overridden function icopy() is not able to convert to the extended Generic type.This however compiles clean in Indigo. Description	Resource	Path	Location	Type Type mismatch: cannot convert from ReadOnlyWrapper<TestA,TestB> to WritableWrapper<TestA,TestB>	TestGenerics.java	/TestGenerics/src	line 8	Java Problem  ------- public class ReadOnlyWrapper<A extends TestA, B extends TestB> {      protected A a;     protected B b;      public ReadOnlyWrapper(A ax,B bx){         this.a = ax;         this.b = bx;     }      public <X extends ReadOnlyWrapper<A,B>> X copy() {         return (X) new ReadOnlyWrapper<A,B>(a,b);     }      public <TA extends TestA,TB extends TestB,X extends ReadOnlyWrapper<TA,TB>> X icopy() {         return (X) new ReadOnlyWrapper<A,B>(a,b);     }       public A getA() {         return this.a;     }     public B getB() {         return this.b;     }  }  ---------   public class WritableWrapper<A extends TestA, B extends TestB> extends ReadOnlyWrapper<A, B> {        public WritableWrapper(A ax,B bx){         super(ax,bx);     }      @Override     public <X extends ReadOnlyWrapper<A,B>> X copy() {         return (X) new WritableWrapper<A, B>(a,b);     }      @Override     public <TA extends TestA,TB extends TestB,X extends ReadOnlyWrapper<TA,TB>> X icopy() {         // Works in Indigo, Fails in Kepler         return (X) new WritableWrapper<A,B>(a,b);     }      public void setA(A ax) {         this.a = ax;     }     public void setB(B bx) {         this.b = bx;     }  } --------    public class TestGenerics {     public static void main(String [] args) {          final WritableWrapper<TestA, TestB> v1 = new WritableWrapper<TestA, TestB>(new TestA(), new TestB());         final WritableWrapper<TestA,TestB> v2 = v1.copy();         final WritableWrapper<TestA,TestB> v3 = v1.icopy(); // does not compile in kepler, compiles in Indigo,Intellij...      }  }"
With the changes in bug 352626 the launch config API has been generified and JDT debug uses some of it.  This bug is to make sure I update to use it.
Somewhere during the implementation of bug 322817, the very important restriction "due to raw APIs" went missing from the documentation: The API name, API Javadoc, UI option name, and parts of the help documents at most mention raw types as part of an example. "Due to raw APIs" needs to be added as a necessary restriction of "unavoidable".  The goal of this option is not to suppress all generic type problems that can happen because the Java language has erasure-based generics. Users should still have to add @SuppressWarnings("unchecked") where type safety is at risk and cannot be checked locally.  The option was added to help in the transition phase where 1.5 projects refer to pre-1.5 APIs. The goal is to avoid a flood of @SuppressWarnings("unchecked") annotations that have to be removed as soon as raw APIs get generified (i.e. type arguments are added to raw types).  Problems are only considered "unavoidable" if they will disappear as soon as the raw API is generified. At that point, the reference will either: - not produce an "unchecked" warning any more (expected case), or - produce a compile error because the client's guess about the correct type arguments was wrong (not expected)  A compiler option that suppresses more problems than that would be unsafe and would go against the spirit of the mandatory "unchecked" warning (JLS7 5.1.9).
"Created attachment 233952 [details] Test case to reproduce the issue  Stack Trace:  java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.Annotation$TypeUseBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.FieldBinding 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:713) 	at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:281) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1474) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:775) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:753) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:757) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170) 	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"While running the test suite on Windows on I20130730-0800 I got the following exception in the console:  java.util.ConcurrentModificationException 	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:819) 	at java.util.ArrayList$Itr.next(ArrayList.java:791) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.removeAllBreakpoints(JDIDebugTarget.java:1567) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.cleanup(JDIDebugTarget.java:1526) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.terminated(JDIDebugTarget.java:1493) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.handleVMDeath(JDIDebugTarget.java:1001) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:158) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100) 	at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
"Consider the below code: 	interface test{ 		public void m1(){ 	} For m1(), currently user is provided with a single Quick Fix proposal which will remove the body of the method. Ideally from Java 1.8, the method can be either default or static, hence we need to provide 2 new proposals here. The Quick Fix proposals will be: 1. Remove method body 2. Add 'default' modifier 3. Add 'static' modifier"
"interface A_test109 { 	int i = foo(); // Error 	default int foo() {} }  The quick fix: ""Change modifier of 'foo()' to 'static'"" in the above example for compilation error: ""Cannot make a static reference to the non-static method foo() from the type A_test109"", produces the following result:  interface A_test109 { 	int i = foo(); 	default static int foo() {} }  The 'default' modifier should be replaced with 'static'."
"interface A_test109 { 	int i = foo(); // Error 	default int foo() { 		return 0; 	} }  Add a breakpoint in method: org.eclipse.jdt.internal.ui.text.correction.ModifierCorrectionSubProcessor#addNonAccessibleReferenceProposal(..)  Hover on the error in the above example.  The method binding for 'selectedNode' (case: ASTNode.SIMPLE_NAME) contains 'abstract' modifier instead of 'default'."
"public interface A_test1 { // creates default methods without body 	int i= aaa();  	 	default void defaultM() { 		int a= bbb(); 	} 	 	static void staticM() { 		int x= ccc(); 	} }  interface A_test2 { // creates static method without body 	int i = foo1(); 	static int foo() {return 0;} }  interface A_test3 { // creates abstract method 	int i = foo2(); } ------------------------------------------------------------- In the above example, 'Create method' quick fix creates incorrect methods as given below:  public interface A_test1 {	// creates default methods without body 	int i= aaa();  	 	default void defaultM() { 		int a= bbb(); 	} 	 	default int bbb();  	default int aaa();  	static void staticM() { 		int x= ccc(); 	}  	default int ccc(); }  interface A_test2 { // creates static method without body 	int i = foo1(); 	static int foo() {return 0;} 	static int foo1(); }  interface A_test3 { // creates abstract method 	int i = foo2();  	int foo2(); } ------------------------------------------------------------- It should not create an abstract method in any case. Also, we should check if a default or a static method has to be created and create the correct method with body accordingly."
"On a system with large RAM, the following error is logged when I start a 64-bit Eclipse using a 64-bit JRE and open the ""Plug-in development"" perspective. > Error > Fri Aug 02 10:44:03 CEST 2013 > Failed to retrieve default libraries for /proj/CoolTools/app/JRE/jre-7u25-linux-x64  This error is logged by org.eclipse.jdt.internal.launching.StandardVMType.generateLibraryInfo method, which starts a native process in order to obtain JVM properties. Using strace I was able to find out that it runs the following command: > /proj/CoolTools/app/JRE/jre64/bin/java -classpath /home/ekalmik/.eclipse/org.eclipse.platform_4.3.0_1947859192_linux_gtk_x86_64/configuration/org.eclipse.osgi/bundles/262/1/.cp/lib/launchingsupport.jar org.eclipse.jdt.internal.launching.support.LibraryDetector ... and gets the following results: > Error occurred during initialization of VM > Could not reserve enough space for object heap > Error: Could not create the Java Virtual Machine. > Error: A fatal exception has occurred. Program will exit.  Indeed, when I run the same command in shell, I observe the same behaviour. However, if I add -Xmx64m directly after the name of executable, I get correct data. > 1.7.0_25|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/resources.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/rt.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/sunrsasign.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jsse.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jce.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/charsets.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jfr.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/classes|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/ext:/usr/java/packages/lib/ext|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/endorsed  I've also verified that if I start the same Eclipse using a 32-bit JRE on the same system, no errors are printed. Of course, running the command above using a 32-bit JRE without specifying -Xmx works fine too.  According to [1], a 64-bit server-class JRE would allocate 1/4th of physical RAM if no -Xmx is given. The system I'm on has 250GB of RAM, and according to strace java has tried allocating 30GB of RAM in order to run LibraryDetector, which is ridiculous. -> cat /proc/meminfo | grep Mem MemTotal:       264118168 kB MemFree:        173739052 kB  A temporary workaround I employed is to set _JAVA_OPTIONS environment variable to -Xmx384m. Unfortunately, this trick overrides vmargs provided to Eclipse, and therefore I cannot set it lower. A proper solution would be to always specify -Xmx when starting a JVM in a subprocess. I've tried LibraryDetector with -Xmx2m, and it worked fine.   * References * [1] http://docs.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html   * System info * -> lsb_release -d Description:	Red Hat Enterprise Linux Server release 6.2 (Santiago) -> cat /proc/cpuinfo | grep processor | wc -l 32 -> cat /proc/meminfo | grep MemTotal MemTotal:       264118168 kB -> /proj/CoolTools/app/JRE/jre32/bin/java -version java version ""1.7.0_25"" Java(TM) SE Runtime Environment (build 1.7.0_25-b15) Java HotSpot(TM) Server VM (build 23.25-b01, mixed mode) -> /proj/CoolTools/app/JRE/jre64/bin/java -Xmx2m -version java version ""1.7.0_25"" Java(TM) SE Runtime Environment (build 1.7.0_25-b15) Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)   * Eclipse info * BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US Command-line arguments:  -os linux -ws gtk -arch x86_64 The installation I've used to get above info with was created with p2 director from Kepler repository and based on SR0. > org.eclipse.platform_4.3.0_1947859193_linux_gtk_x86_64 > org.eclipse.jdt.debug_3.8.0.v20130514-0841 > org.eclipse.jdt.launching_3.7.0.v20130515-1451.jar However, I've also verified that the same error is present in another installation created from Juno repository and based on SR2."
N20130801-2000.  JDT Debug and Ant tests DNF on all platforms.
Trying to find the token and sourcePosition that correspond to QNR#binding I wanted to use QNR#indexOfFirstFieldBinding but observed that this field is reassigned for *every* field in the chain.  So either the name or the usage of this field is wrong.  In bug 392384 I'm temporarily adding another field indexOfFirstFirstFieldBinding so I can test that errors are reported at the desired location. That change may need to be reverted via this bug.
Given the following class:  package p; import org.foo.*; // here we have type annotations for nullity public abstract class X1 {     public class Inner {}     public void nesting(@NonNull Inner i1, @NonNull X1.@Nullable Inner i2) { } }  This currently generates the following byte code:    public void nesting(p.X1$Inner, p.X1$Inner);    ...    RuntimeInvisibleTypeAnnotations:       0: #19(): METHOD_FORMAL_PARAMETER, param_index=0       1: #19(): METHOD_FORMAL_PARAMETER, param_index=1       2: #27(): METHOD_FORMAL_PARAMETER, param_index=1, location=[INNER_TYPE]   ...  AFAICS the first annotation is wrong, it should have the same shape as the last one.  In 3.4 the spec says: "The type path that is stored in the class file is with respect to the full type, not the source code representation. ..." ... and goes on explaining.  The full type of the first formal parameter is correctly rendered as p.X1$Inner (see  the method signature), accordingly the type annotation for Inner should be marked with "location=[INNER_TYPE]", no?
Following the discussion in bug 394539 the bundle org.eclipse.jdt.annotation will be bumped up to 2.0.0 to require a BREE of 1.8 and change our annotations for target TYPE_USE.  At the same time we don't want to loose the ability to run our tests in 1.7 mode. I'm currently trying how the tests could automatically switch between both versions of this bundle.
org.eclipse.jdt.core.tests.compiler has a wrong bundle version.  It was changed from 3.8.2 to 3.8.3 which is wrong. It must either be 3.9.0 or 3.8.100. I recommend the former.  NOTES: 1) please also check all other projects where you changed the version 2) the version (3.8.3) in the maintenance branch is correct
There are API changes in APT in Java 8 and JDT's implementation must support the changes. In essence, we must provide implementation for the following interface methods:  Note: '->' stands for "must implement"  ElementsImpl -> Elements.isFunctionalInterface(TypeElement) ExecutableElementImpl -> ExecutableElement.isDefault()  ExecutableTypeImpl -> ExecutableType.getReceiverType() ExecutableElementImpl -> ExecutableElement.getReceiverType()  Following types must implement AnnotatedConstruct.getAnnotationsByType(Class<A>) :      TypeElementImpl     TypeParameterElementImpl     PackageElementImpl     VariableElementImpl     TypeMirrorImpl     ExecutableElementImpl      NoTypeImpl  Following types must implement AnnotatedConstruct.getAnnotation(Class<A>) and AnnotatedConstruct.getAnnotationMirrors():      TypeMirrorImpl     NoTypeImpl
"When I run RunJDTCoreTest locally, most the time I get one random failure in SwitchTest, re-running that particular test always passes.  By instrumenting VerifyTests I see the following pattern:  - VM is launched for testMarysLamb() - this test runs fine, socket is working - the log file created for this VM reports only this one test.  - next VM is launched for testNestedSwitches() - between testMarysLamb() and testNestedSwitches() we have two tests:   - testBreakOut() -> pass   - testMultipleSwitches() -> fail, unexpectedly empty output   Why are those missing from the log?  In the console I find:  java.io.EOFException 	at java.io.DataInputStream.readBoolean(DataInputStream.java:244) 	at org.eclipse.jdt.core.tests.util.TestVerifier.loadAndRun(TestVerifier.java:583) 	at org.eclipse.jdt.core.tests.util.TestVerifier.verifyClassFiles(TestVerifier.java:643) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2516) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2317) 	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1361) 	at org.eclipse.jdt.core.tests.compiler.regression.SwitchTest.testBreakOut(SwitchTest.java:1859)  I see this for several tests incl. both ""missing"" tests, but *not* for testMarysLamb()  My guess that the socket was unexpectedly closed has not yet been confirmed by logging. I may need to do more flushing to see if the missing log output is lost pending in some buffer."
I20130807-2000.  The label of the new JUnit view font is wrong. It should be "JUnit failure trace font".
"I think there’s a bug in the code that infers nullnes. It’s supposed to complain if you use a @Nullable value in a @NonNull context, unless it can deduce that it can’t be null, e.g. because you just tested it.  But this analysis has a bug in the particular case where the @Nullable value comes from a field rather than a local variable (e.g., this.maybenull). If you test that the field is not null, then it deduces correctly that it can’t be null. However, if you test if it is null, then on the “else” branch of the test it’s still considered nullable.   I’ve added a small class below that tests several of these cases. Compare first methods testIfThenBranch and  testIfElseBranch below. The first is accepted and the second fails, although logically they should be equivalent. Compare also with testIfElseBranchLocal, which shows that the same inference works if a local variable is involved instead of a field. I’ve also added some other similar cases, including a weird one where a similar test works in a “while” statement only if it is preceded by an “if”, even though the while is outside the if.   /* Start example: */      import javax.annotation.Nonnull;     import javax.annotation.Nullable;          public class Tests {       @Nullable       Object prop;              void test(@Nonnull Object param){         assert param != null;       }              void testIfThenBranch(){         if(this.prop != null) {           test(this.prop); // OK         }       }              void testIfElseBranch(){         if(this.prop == null) {           // ignore         } else {           test(this.prop); // FAILS!         }       }              void testIfThenReturn(){         if(this.prop == null) {           return;         }           test(this.prop); // FAILS!       }        void testIfElseBranchLocal(){         @Nullable Object local = this.prop; 		         if(local == null) {           // ignore         } else {           test(local); // OK         }       }              void testWhileAfterIf(){         if(this.prop != null) {           test(this.prop); // OK         }                  while(this.prop != null) {           test(this.prop); // OK         }       }              void testWhileAlone(){         while(this.prop != null) {           test(this.prop); // FAILS!         }       }     }  /* End example */   Exact version of JDT according to Eclipse’s about menu:  Eclipse Java Development Tools 3.9.0.v20130605-2000 org.eclipse.jdt.feature.group  In Eclipse’s preferences, in the compiler errors/warnings page, I have activated everything in the “Null analysis” section."
"4.4 M1.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.launching.EEVMType.validateInstallLocation(EEVMType.java:176) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$5.run(EEVMPage.java:198) 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage.validateDefinitionFile(EEVMPage.java:206) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage.access$4(EEVMPage.java:184) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$2.modifyText(EEVMPage.java:140) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:179) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1082) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063) 	at org.eclipse.swt.widgets.Text.wmCommandChild(Text.java:2974) 	at org.eclipse.swt.widgets.Control.WM_COMMAND(Control.java:4752) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4614) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method) 	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443) 	at org.eclipse.swt.widgets.Text.callWindowProc(Text.java:260) 	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4706) 	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2597) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977) 	at org.eclipse.swt.internal.win32.OS.SetWindowTextW(Native Method) 	at org.eclipse.swt.internal.win32.OS.SetWindowText(OS.java:3473) 	at org.eclipse.swt.widgets.Text.setText(Text.java:2252) 	at org.eclipse.jdt.internal.debug.ui.jres.EEVMPage$3.widgetSelected(EEVMPage.java:159) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) 	at org.eclipse.jface.window.Window.open(Window.java:803) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock.addVM(InstalledJREsBlock.java:710) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock.access$9(InstalledJREsBlock.java:707) 	at org.eclipse.jdt.internal.debug.ui.jres.InstalledJREsBlock$8.handleEvent(InstalledJREsBlock.java:462) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) 	at org.eclipse.jface.window.Window.open(Window.java:803) 	at org.eclipse.ui.internal.dialogs.WorkbenchPreferenceDialog.open(WorkbenchPreferenceDialog.java:215) 	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:65) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499) 	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:588) 	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:505) 	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:415) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4170) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:613) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
In Kepler there's a new feature, that also completes the trailing semicolon for method calls without parameters. That's nice. The caret jumps behind the trailing semicolon. Then for a short moment the enter key is blocked. That's not nice, because I used the enter key for code completion and now want to proceed to the next line.  Could you remove the enter key from blocked keys for this feature?
I20130813-1330 and N20130813-2000.  http://download.eclipse.org/eclipse/downloads/drops4/I20130813-1330/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.html   N/A  java.lang.NullPointerException at org.eclipse.jdt.debug.tests.core.JavaLibraryPathTests.testMultiVMArgsForRequiredProjectExplicitPath(JavaLibraryPathTests.java:155) at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2405) at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:55) at java.lang.Thread.run(Thread.java:662)   N/A  java.lang.NullPointerException at org.eclipse.jdt.debug.tests.core.JavaLibraryPathTests.testVMArgsForRequiredProjectExplicitPath(JavaLibraryPathTests.java:130) at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2405) at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:55) at java.lang.Thread.run(Thread.java:662)
Once bug 392099 has resolved the bulk of the work for null type annotations, the following list of TODOs must be investigated:  (1) Check para in Annotation.resolveType() starting   if ((annotationType.tagBits & TagBits.AnnotationTargetMASK) == TagBits.AnnotationForTypeUse) { -> Needed? When, why introduced? Overlap with 1.8 treatment below??  (2) ConditionalExpression: FIXME: we need t1 == t2 comparison, but don't yet handle mixed scenarios of types with nullTagBits + arguments -> also use unannotated() instead of original()!!  (3) ReturnStatement:  more detailed checking (incomp. due to annot on type detail) -> use findNullTypeAnnotationMismatch() & write more tests -> this method still needs to descend into type parameters  (4) Statement.findNullTypeAnnotationMismatch(..) - maybe int return can be replaced with boolean (isDefiniteConflict) - if so, maybe the method can actually do less for non-definite cases  (5) TypeDeclaration: -> Need to check if synth default constructors need treatment for JSR308  (6) LookupEnvironment.createAnnotatedType: + handle PolyTypeBinding  (7) SourceTypeBinding.resolveTypeFor() - here we translate NonNullByDefault into type annotation after the fact.   should we use different strategies up-front?  (8) ReferenceBinding.nullAnnotatedReadableName(..) - respect annotatable enclosing type  (9) NullTypeAnnotationTest: expect (and implement) more error messages   (individually marked "FIXME").
"It is when you used parser outside IDE and does not have got access to JavaProject. You will provide properly all data to parser but it fails on case like:  File A: ------- public class A  { } class B  {} -------  File C: ------- public class C extends B  {} -------  Goal: We want createAST() for file C.  It is caused that method findType() is broken in NameEnvironmentWithProgress  See: class CompilationUnitResolver method 	public static void resolve(...)  line: environment = new NameEnvironmentWithProgress(allEntries, null, monitor);  Method findType in this NameEnvironmentWithProgress could better support this case.  In findType going down few steps NameEnvironmentAnswer.findClass() this is place where is a bug in this case:  If class is on the class path then it is ok but in our case. Both classes are on one file with source code and second class is not in classpath and you have not got binaries. You do not want build it. You just want create AST then this aproach where you are searching for binary .class file names are completely fails. This will back you class not found and compile error when everything is fine.  Quick fix could be looks something like that:      @Override     public NameEnvironmentAnswer findType(final char[] aTypeName, final char[][] aaPackageName)     {         NameEnvironmentAnswer findType = super.findType(aTypeName, aaPackageName); // invoked actual version of findType()         if ((findType == null) && (_packagePrivateClasses != null) && CharOperation.equals(aaPackageName, _sOriginalPackage)) {             // if we could not find this type it means that could be package private type declared in another .java file. We should inspect all .java files in this             // package to discover it             final String string = getContainingJavaFileForType(CharOperation.charToString(aTypeName));             if (UString.isNonEmptyString(string)) {                 findType = super.findType(string.toCharArray(), aaPackageName);             }          }         return findType;     }  If you need more details to reproduce this bug on for ideas how to fix it please do not hesitate to contact me :)"
"REPRODUCING THE PROBLEM: 1) Create a workspace with one java project. In the Java-Compiler ""Errors/Warning"" -settings turn on ""enabled annotation-based null-analysis"".  2) Add the following two classes:  --- ClassA.java: import org.eclipse.jdt.annotation.NonNullByDefault;  @NonNullByDefault public class ClassA { 	public interface InterfaceA { 		public void method(Object arg); 	} } --- ClassB.java: import org.eclipse.jdt.annotation.NonNull;  public class ClassB { 	public static class ImplA implements ClassA.InterfaceA { 		@Override 		public void method(@NonNull Object arg) { 		} 	} }  3) Now close all Editor windows. 4) Chose Project > Clean ... > Clean all projects:  THE PROBLEM: The following error appears in the problems view: ""Illegal redefinition of parameter arg, inherited method from ClassA.InterfaceA does not constrain this parameter"", ClassB.java, line 6  ANALYSIS: In SourceTypeBinding.java, the field defaultNullness is accessed in the method hasNonNullDefault(), but was not initialized for some of the involved classed. (There is another reference to it in checkRedundantNullnessDefaultOne, which is not resposible for the bug in the example, but looks suspicous too) Invoking initializeNullDefault() before accessing defaultNullness fixes the problem. I will attach a patch which does that in both locations."
With type annotations for null analysis, more patterns of incompatibility arise which deserve specific analysis and reporting.  Consider:   List<@NonNull String> nonNullStrings;   List<@NonNull String> nullableStrings;   List<String> strings;  (A) Incompatible:   nonNullStrings = nullableStrings;   nullableStrings = nonNullStrings;  (B) Lossy (but safe) conversions:   strings = nonNullStrings;   strings = nullableStrings;  (C) Unchecked, unsafe conversions:   nonNullStrings = strings;   nullableStrings = strings;   Current status:  (A) is mostly implemented, exception:  - array content, nullable to nonnull incompatibility is not reported Currently, this kind of incompatibility influences overload resolution, which is wrong.  (B) works for array details, but not for type parameters.  (C) works for type parameters but not all situations involving array details   Note, that all checking for the above happens during resolve, no flow  analysis involved.
BETA_JAVA8: ----------  JSR308 2.1.2 states: Static member accesses are preceded by a type name, but  that type name may not be annotated:  @Illegal Outer.StaticNestedClass // illegal! @Illegal Outer.staticField // illegal!  While we reject the latter snippet, we silently accept the former.
"BETA_JAVA8:   From the spec:   ""An annotation on a wildcard type argument appears before the wildcard, as in  MyClass<@Immutable ? extends Comparable<MyClass>>""  However, when the following program is compiled, the annotations are accepted, but don't seem to make it to the class file:  // --- import java.lang.annotation.*; import java.util.List; import static java.lang.annotation.ElementType.*;  @Target(TYPE_USE) @interface Immutable {} class X { 	List<@Immutable ? extends Comparable<X>> x; }  // ----  javac 8b100 emits:  RuntimeInvisibleTypeAnnotations:       0: #9(): FIELD, location=[TYPE_ARGUMENT(0)]"
"BETA_JAVA8:  Given the following program:  // --- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target(TYPE_USE) @interface Immutable {} class Document {} class X { 	@Immutable X() { 	} } // ---  The annotation @Immutable does not make it to the class file.  8b100 emits:    X();     descriptor: ()V     flags:      Code:       stack=1, locals=1, args_size=1          0: aload_0                 1: invokespecial #1                  // Method java/lang/Object.""<init>"":()V          4: return               LineNumberTable:         line 7: 0         line 8: 4     RuntimeInvisibleTypeAnnotations:       0: #9(): METHOD_RETURN"
"REPRODUCING THE BUG: import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class ClassF { 	public interface X { 		@Nullable 		Object provideNullable(); 	}  	public static void needNonNull(@NonNull Object o) { 		o.hashCode(); 	}  	public void method(X x) { 		for (int j = 0; j < 1; j++) { 			try { 				this.hashCode(); 			} finally { 				for (int i = 0; i < 1; i++) { 					Object o = x.provideNullable(); 					needNonNull(o); 				} 			} 		} 	} } THE BUG: The compiler throws a NullPointerException in FinallyFlowContext.java:108, inside the ""if""-statement:  case ASSIGN_TO_NONNULL: 	int nullStatus = flowInfo.nullStatus(this.nullLocals[i]); 	if (nullStatus != FlowInfo.NON_NULL) { 		this.parent.recordNullityMismatch(scope, (Expression) location, 		this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus); 	} 	break;  ANALYSIS: It is assumed, that whenever the value ASSIGN_TO_NULL is used, then this.providedExpectedTypes is initalized.  This is wrong in one case: The value ASSIGN_TO_NULL may be passed from LoopingFlowContext, Line 290:  if (!(this.nullCheckTypes[i] == MAY_NULL &&  upstreamCopy.isDefinitelyNonNull(local))) { 	this.parent.recordUsingNullReference(scope, local, location,  			this.nullCheckTypes[i], flowInfo);  } to the implementation of recordUsingNullReference in FinallyFlowContext, at the end which in line 420, it invokes  recordNullReference(local, location, checkType); without invoking   recordProvidedExpectedTypes(providedType, expectedType, this.nullCount);  POSSIBLE FIX: diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java index 2befb45..7afdf13 100644 --- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java +++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java @@ -287,8 +287,10 @@  			// https://bugs.eclipse.org/376263: avoid further deferring if the upstream info  			// already has definite information (which might get lost for deferred checking).  			if (!(this.nullCheckTypes[i] == MAY_NULL && upstreamCopy.isDefinitelyNonNull(local))) { -				this.parent.recordUsingNullReference(scope, local, location, -						this.nullCheckTypes[i], flowInfo); +				if((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) != ASSIGN_TO_NONNULL) { +					this.parent.recordUsingNullReference(scope, local, location, +							this.nullCheckTypes[i], flowInfo); +				}  			}  		}  	}"
BETA_JAVA8:  When the following program is compiled:  // -- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;   @Target({TYPE_USE}) @interface TypeAnnotation { }  @Target({TYPE}) @interface Annotation { }  @Annotation @TypeAnnotation class X { }  // --  @TypeAnnotation does not seem to make it to the class file.  JSR308, section 2.3 expressly allows such usage. Excerpt:  "A type annotation (one meta-annotated with @Target(ElementType.TYPE USE))  is permitted to be written anywhere @Target(ElementType.TYPE) or  @Target(ElementType.TYPE PARAMETER) would permit—that is, on a class, interface, or enum declaration, or on a type parameter declaration. Strictly  speaking, these are declaration sites, not uses of a type. However, it is  convenient to write a type annotation at a type declaration, as shorthand for applying it at all uses. For example, @Interned class MyClass { ... } could  indicate that all uses of MyClass are interned, even though for other classes  some instances may be interned and other instances not interned."
"BETA_JAVA8:  From the spec:  ""Type annotations in the body of an initializer appear with the code that  performs the initialization, not on the field that is being initialized.  Type annotations in the body of instance initializer appear on on all initial constructors, and type annotations in the body of a class initializer  appear on the clinit symbol""  for the following program:  // ---  import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target({TYPE_USE}) @interface NonNull { } class X {  	static { 		new @NonNull Object(); 	} 	{ 		new @NonNull Object(); 	} 	X() { 		 	} 	X (int x) { 		 	} }   we generate the following code:  ""// Compiled from X.java (version 1.8 : 52.0, super bit)\n"" +  		""class X {\n"" +  		""  Constant pool:\n"" +  		""    constant #1 class: #2 X\n"" +  		""    constant #2 utf8: \""X\""\n"" +  		""    constant #3 class: #4 java/lang/Object\n"" +  		""    constant #4 utf8: \""java/lang/Object\""\n"" +  		""    constant #5 utf8: \""<clinit>\""\n"" +  		""    constant #6 utf8: \""()V\""\n"" +  		""    constant #7 utf8: \""Code\""\n"" +  		""    constant #8 method_ref: #3.#9 java/lang/Object.<init> ()V\n"" +  		""    constant #9 name_and_type: #10.#6 <init> ()V\n"" +  		""    constant #10 utf8: \""<init>\""\n"" +  		""    constant #11 utf8: \""LineNumberTable\""\n"" +  		""    constant #12 utf8: \""LocalVariableTable\""\n"" +  		""    constant #13 utf8: \""this\""\n"" +  		""    constant #14 utf8: \""LX;\""\n"" +  		""    constant #15 utf8: \""RuntimeInvisibleTypeAnnotations\""\n"" +  		""    constant #16 utf8: \""LNonNull;\""\n"" +  		""    constant #17 utf8: \""(I)V\""\n"" +  		""    constant #18 utf8: \""x\""\n"" +  		""    constant #19 utf8: \""I\""\n"" +  		""    constant #20 utf8: \""SourceFile\""\n"" +  		""    constant #21 utf8: \""X.java\""\n"" +  		""  \n"" +  		""  // Method descriptor #6 ()V\n"" +  		""  // Stack: 2, Locals: 1\n"" +  		""  static {};\n"" +  		""    0  new java.lang.Object [3]\n"" +  		""    3  dup\n"" +  		""    4  invokespecial java.lang.Object() [8]\n"" +  		""    7  astore_0\n"" +  		""    8  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 6]\n"" +  		""        [pc: 8, line: 7]\n"" +  		""  \n"" +  		""  // Method descriptor #6 ()V\n"" +  		""  // Stack: 1, Locals: 1\n"" +  		""  X();\n"" +  		""     0  aload_0 [this]\n"" +  		""     1  invokespecial java.lang.Object() [8]\n"" +  		""     4  new java.lang.Object [3]\n"" +  		""     7  invokespecial java.lang.Object() [8]\n"" +  		""    10  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 11]\n"" +  		""        [pc: 4, line: 9]\n"" +  		""        [pc: 10, line: 12]\n"" +  		""      Local variable table:\n"" +  		""        [pc: 0, pc: 11] local: this index: 0 type: X\n"" +  		""    RuntimeInvisibleTypeAnnotations: \n"" +  		""      #16 @NonNull(\n"" +  		""        target type = 0x44 NEW\n"" +  		""        offset = 4\n"" +  		""      )\n"" +  		""  \n"" +  		""  // Method descriptor #17 (I)V\n"" +  		""  // Stack: 1, Locals: 2\n"" +  		""  X(int x);\n"" +  		""     0  aload_0 [this]\n"" +  		""     1  invokespecial java.lang.Object() [8]\n"" +  		""     4  new java.lang.Object [3]\n"" +  		""     7  invokespecial java.lang.Object() [8]\n"" +  		""    10  return\n"" +  		""      Line numbers:\n"" +  		""        [pc: 0, line: 13]\n"" +  		""        [pc: 4, line: 9]\n"" +  		""        [pc: 10, line: 14]\n"" +  		""      Local variable table:\n"" +  		""        [pc: 0, pc: 11] local: this index: 0 type: X\n"" +  		""        [pc: 0, pc: 11] local: x index: 1 type: int\n"" +  		""    RuntimeInvisibleTypeAnnotations: \n"" +  		""      #16 @NonNull(\n"" +  		""        target type = 0x44 NEW\n"" +  		""        offset = 4\n"" +  		""      )\n"" +  		""}""  //---------------- This shows two problems in code generation:  (1) Static class initializer code is missing the type annotations attributes. (2) Checkcast instruction is not emitted - so the fix for bug 409244 may not be fully effective."
"BETA_JAVA8: ----------  From the spec:  ""When the annotation’s target is a bound of a type parameter of a class or  method, target info contains one type parameter bound target:   type_parameter_bound_target {     u1 type_parameter_index;     u1 bound_index; };  type parameter index specifies the index of the type parameter, while bound  index specifies the index of the bound. Indexes start at 0. Bound index 0 is always a class, not interface, type. If the programmer-supplied upper bound  of the type variable is an interface, it is treated as the second bound, and  the implicit first bound is java.lang.Object.  // ---  Given that, given the following program:  // --- import java.lang.annotation.*; import static java.lang.annotation.ElementType.*;  @Target({TYPE_USE}) @interface NonNull { }  class X <T extends @NonNull Comparable> { 	 } // --  we generate bad code:  ""  RuntimeInvisibleTypeAnnotations: \n"" +  				""    #21 @NonNull(\n"" +  				""      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n"" +  				""      type parameter index = 0 type parameter bound index = 0\n"" +  				""    )\n"" +  				""}""  javac 8b100 generates:    RuntimeInvisibleTypeAnnotations:     0: #13(): CLASS_TYPE_PARAMETER_BOUND, param_index=0, bound_index=1  which is correct."
As I'm trying to run tests along with platform build using surefire, I noticed that bundle org.eclipse.jdt.core.tests.compiler has for packaging type "eclipse-plugin". Shouldn't it be an "eclipse-test-plugin" so surefire would run tests?
I'm getting incorrect potential resource leaks in a for loop, with the close inside a try/catch. Let me show examples:      public void example1() throws IOException {         for (final File file : new File[] { new File("/") }) {             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 reader.close();             }         }     }  example1() has no problems.      public void example2() throws IOException {         for (final File file : new File[] { new File("/") }) {             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 try {                     reader.close();                 }                 catch (IOException e) {                 }             }         }     }  example2() shows the warning on variable "reader" - the difference between this and example1() is the try/catch around reader.close().      public void example3() throws IOException {         final File file = new File("/");          BufferedReader reader = null;         try {             reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));         }         finally {             try {                 reader.close();             }             catch (IOException e) {             }         }     }  example3() does NOT give me the warning - it is the same as example2() with the the for loop removed.      public void example4() throws IOException {         final File[] files = new File[] { new File("/") };          for (int i = 0; i < files.length; i++) {             File file = files[i];             BufferedReader reader = null;             try {                 reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));             }             finally {                 try {                     reader.close();                 }                 catch (IOException e) {                 }             }         }     }  example4() is an equivalent of example2(), with a regular for loop instead of enhanced-for loop. This showed a warning also.  All I can conclude is potential resource leak is not working with for loop (of either type) and a try/catch around the close.  I was compiling with Compiler compliance level of 1.6.
BETA_JAVA8: ----------  Per discussions in the EG list, the spec is being amended to require a target_type=CLASS_EXTENDS type annotation for the following case: This is apart from the target_type=NEW type annotation which we already emit.  Note that the reference compiler already emits the CLASS_EXTENDS type annotation, but not the NEW target type annotation, a bug has been raised against javac for this purpose.  // --- @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) @interface X {}  class C { void m() { new @X Foo() {}; } } // --  From the EG discussion:  ...  The wording for target_type=CLASS_EXTENDS (0x10) refers to a "type in  extends clause of class or interface declaration" so it's not clear that  the @X annotation should be stored this way. To clarify, the wording for  target_type=CLASS_EXTENDS should say:  "type in extends clause of class or interface declaration (including the  direct superclass of an anonymous class declaration), ..."  ...
"Testcase :  public class Sample{  interface Int { 		void setInt(int i);  	} public static void main(String[] args) {    		final int j; 		  		Int int1 = (int i) -> { 			j=10; 		};  }  }    Gives following error with javac :  Sample.java:14: error: cannot assign a value to final variable j                         j=10;                         ^ 1 error    Does not give error in eclipse."
BETA_JAVA8:  JEP 118 provides for storing of method parameter names, flags and such in a new attribute called MethodParameters. This is to be generated only when a programmer opts in for it.  https://bugs.eclipse.org/bugs/show_bug.cgi?id=407297 has implemented the Core changes for this option. See the javadoc for org.eclipse.jdt.core.JavaCore.COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR  ECJ implements -parameters command line option for this purpose.  We need support in the UI for enabling this. TIA.
As a big test to catch potential regressions caused by null analysis using type annotations, I ran all JDT/Core tests at 1.8 with null annotations enabled.  Currently this produces 124 errors and 37 failures.  I'm going to work through these regressions and provide patches via this bug.
We have the following code in EclipseCompiler.java, which is our implementation of JavaCompiler:    eclipseCompiler2.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);   eclipseCompiler2.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);   eclipseCompiler2.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);  There has to be a way clients, at least, JDT core tests that use this, can pass a different compliance level than this.  This is affecting the new tests I am planning to add as part of bug 414627.
"BETA_JAVA8:  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @Target(ElementType.TYPE_USE) @interface Marker { }  public class X { 	@Marker 	foo(String s) {  	} }   This snippet triggers an NPE on HEAD."
Set 'code.ignoredWarnings' for test bundles in order to use the global build settings and reduce the discouraged access warnings in the official build.  The easiest way to do this is:  1. in the repository root add a folder 'tests-pom' 2. into the new folder add the following pom.xml:      http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/plain/tests-pom/pom.xml 3. adjust the parent group and artifact id in that file 4. in each test bundle modify the pom.xml as follows:    a) replace the parent artifact id with "tests-pom"    b) add this to the parent declaration:       <relativePath>../tests-pom/</relativePath>  As a template you can use e.g. http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/
"The following code: public class Bug { 	public static void main(String[] args) throws Exception { 		System.out.println(ParseExpr11()); 	}  	static final public Object ParseExpr11() throws Exception { 		Object expr; 		Object op = null; 		expr = ParseVarExpr(); 		if (op == null) { 			if (true) 				return expr; 		} 		{ 			throw new Exception(""++/-- not supported in TUD Bantam Java.""); 		} 	}  	private static Object ParseVarExpr() { 		// TODO Auto-generated method stub 		return ""test""; 	} }  throws  Exception in thread ""main"" java.lang.VerifyError: Expecting a stackmap frame at branch target 12 in method Bug.ParseExpr11()Ljava/lang/Object; at offset 7 	at java.lang.Class.getDeclaredMethods0(Native Method) 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2451) 	at java.lang.Class.getMethod0(Class.java:2694) 	at java.lang.Class.getMethod(Class.java:1622) 	at sun.launcher.LauncherHelper.getMainMethod(LauncherHelper.java:494) 	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:486)   Expected: ""test""   It is generated by JavaCC, which is why the formatting/syntax sucks. Works fine with javac.  -- Configuration Details -- Product: Eclipse 1.5.2.20130110-1126 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.8.2.v20130116-090414-8-8nFu3FNOfwKLRuqgXKIy9z0I83"
"Consider this code fed to the APT:  @TypeUseAnnotation(""class"") @Deprecated public class TypeAnnotationTest extends @TypeUseAnnotation(""super"") Object {}  And the following code in AnnotationDiscoveryVisitor:  private void resolveAnnotations( 		BlockScope scope, 		Annotation[] annotations, 		Binding currentBinding) { 	ASTNode.resolveAnnotations(scope, annotations, currentBinding); 	 	for (Annotation annotation : annotations) { 		AnnotationBinding binding = annotation.getCompilerAnnotation(); 		if (binding != null) { 			TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType());  			Element element = _factory.newElement(currentBinding); 			_annoToElement.put(anno, element); 		} 	} }  Looks like the new element instance created for the currentBinding is just not necessary."
Update the preference UI to support Java 1.8 target platform.  Jay, kindly update the Javadoc for JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM.
Performed code formatting at project level containing more than 100 Java files.  Expected: The code must be formatted as per the template. Actual: The formatter threw exception saying: Some characters cannot be mapped using "Cp1252" character encoding. Either change the encoding or remove the characters which are not supported by the "Cp1252" character encoding.  There are two problems here: 1) The root cause for the exception 2) The exception details are not enough - it doesn't state in which file the exception occurred. Now I have to dig through all the files one by one.  -- Configuration Details -- Product: Eclipse 2.0.0.20130613-0530 (org.eclipse.epp.package.jee.product) Installed Features:  org.eclipse.jdt 3.9.0.v20130605-2000
The compile side of work for JEP118 (Runtime method parameter name access) was accomplished via bug 406966 and its children. APT should respond to the model API changes mandated by the JEP.  The current bug is to track that.
Failed at http://download.eclipse.org/eclipse/downloads/drops4/I20130828-1800/testresults/html/org.eclipse.jdt.core.tests.model_linux.gtk.x86_6.0.html
"public class A { 	class B { 		interface I { // Error			 		} 	} } ------------------------- public class A { 	class B { 		@interface I { // Error			 		} 	} } ------------------------- The error message says: ""The member interface/annotation I can *only* be defined inside a top-level class or interface"". However, these can also be defined inside a static member type, which is not reflected in the error message."
"// -- following program does not compile: good;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	class Y {} 	@NonNull String  foo(X.@NonNull Y xy) { 		return """"; 	} }  class Z extends X { 	String  foo(X.Y xy) { 		return null; 	} }  // -- following program does compile: bad; import org.eclipse.jdt.annotation.NonNull;  public class X { 	class Y {} 	X.@NonNull Y  foo(X.@NonNull Y xy) { 		return new X().new Y(); 	} }  class Z extends X { 	X.@NonNull Y  foo(X.Y xy) { 		return null; 	} }"
"// -- import java.util.List;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	void  foo(List<X> lx) { 	} }  class Z extends X { 	void  foo(List<@NonNull X> xy) { 	} }  results in a name clash error:   ""Name clash: The method foo(List<X>) of type Z has the same erasure as foo(List<X>) of type X but does not override it"""
"// --  import java.util.ArrayList; import java.util.List;  import org.eclipse.jdt.annotation.NonNull;  public class X { 	public static void main(String[] args) { 		List<@NonNull ? extends @NonNull String> ls = new ArrayList<String>(); 		ls.add(null); 		@NonNull String s = ls.get(0); 	} } // triggers an NPE."
"// -- import org.eclipse.jdt.annotation.NonNull;  public class X<@NonNull T> { 	T foo(T t) { 		return t; 	} }   // ---  produces a stack overflow error. Probably due to a missing unannotated() implementation in TVB."
"// --- Expect two errors, but got one  import org.eclipse.jdt.annotation.NonNull;  public class X<T> { 	class Y { 		 	} 	 	X<String>.@NonNull Y y = null; // no error here, bad. 	 	@NonNull Y y2 = null; // error here. Good. }"
"// -- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class X<T> { 	T foo(@NonNull T t) { 		return t; 	} 	public static void main(String[] args) { 		X<@Nullable String> xs = new X<String>(); 		xs.foo(null); 	} 	 }  // -- 1. Allowing X<@Nullable String> creates contradiction for X#foo which we don't complain about.  2. The unchecked conversion message reads strange. Target type @Nullable, we should probably be just silent as it is always a safe conversion."
"// -- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;  public class X<T> { 	T foo(@NonNull T t) { 		return t; 	} 	public static void main(String[] args) { 		X<String> xs = new X<String>(); 		xs.foo(""""); 	} 	 }   // without null analysis enabled, compiles ok."
See NullTypeAnnotationTest#testBug416174() for a situation that is not yet detected. Here the incompatibility is only by an annotation on a type parameter.
"Here is the code snippet before applying inline refactoring:  public class A { 	public static int i;  	public static int getI() {         // APPLY INLINE HERE 		return i; 	} }  public enum B { 	m(A.getI()); 	 	B(int j){		 	} }  Applying inline refactoring to getI() cannot update A.getI() that is a parameter of enum constructor call:  public class A { 	public static int i; }  public enum B { 	m(A.getI());             // ERROR 	 	B(int j){		 	} }"
"Using Eclipse SDK Version: 4.4.0 Build id: I20130829-2000  I'm not sure exactly what code triggers the NPE but it seems it's when I hover on certain methods that override other methods. I'll try to isolate the code.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:274) 	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:970) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:510) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:265) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:469) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1185) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1295) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:561) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:789) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:592) 	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:115) 	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:135) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:300) 	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1267) 	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:739) 	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:691) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144) 	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:96) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getTypeHierarchy(JavadocContentAccess2.java:432) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getInheritedDescription(JavadocContentAccess2.java:386) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$JavadocLookup.getInheritedMainDescription(JavadocContentAccess2.java:302) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.toHTML(JavadocContentAccess2.java:831) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.javadoc2HTML(JavadocContentAccess2.java:682) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:604) 	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:495) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:694) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:612) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:604) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) 	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) 	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) 	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
"In this snipped:  // === import java.util.Map;  import org.eclipse.jdt.annotation.*;  abstract public class X<Y> implements Map<@NonNull String,Y> { 	void foo(X<Object> x) { 		Map<@NonNull String, Object> m1 = x; // OK 		Map<@Nullable String, Object> m2 = x; // NOK 	} } // ===  we should see one error at (NOK), but the compiler fails to see that X specifies type parameter Map.K as @NonNull."
BETA_JAVA8:  org.eclipse.jdt.internal.compiler.lookup.TypeIds.T_JavaLangFunctionalInterface & org.eclipse.jdt.internal.compiler.lookup.TypeIds.T_JunitFrameworkAssert  both have the same type id 69 :)  Possibly other cases too. Please sort and eliminate duplicates and reassign suitable values.
"I was day dreaming along these lines (see bug 416304):    <N extends Annotation> @N B f(@N A a)  Much to my surprise ecj didn't call me nuts but simply answered:  	<N extends Annotation> @N B f(@N A a) 	                       ^^ 	Syntax error, type annotations are illegal here  Oops, this seems to be derived from (JSR 308 draft):    MethodOrFieldDecl: 	UnannType Identifier MethodOrFieldRest  where in fact these original rule should apply:    GenericMethodOrConstructorDecl: 	TypeParameters GenericMethodOrConstructorRest    GenericMethodOrConstructorRest: 	(Type | void) Identifier MethodDeclaratorRest 	Identifier ConstructorDeclaratorRest  in the second rule, unchanged for JSR 308, the NT Type now expands to    [Annotations] UnannType  Ergo: the above syntax should be accepted, leaving the question *why* the above snippet is illegal as an exercise for the reader :)   As an aside, this implies that the following is legal though totally crazy:    @NonNull <T> @Nullable String foo() { return null; }  Bonus question: Can @NonNull in this example still be interpreted as a type annotation?"
Consider this example:    import java.lang.annotation.*;   ...   <T extends Annotation> String foo(@T String s) { return null; }  ecj will answer:    <T extends Annotation> String foo(@T String s) { return null; }                                      ^   Type mismatch: cannot convert from T to Annotation  Mh, that's the wrong error to show, T *is* compatible to Annotation.  Looking at JLS 9.6:    "A consequence of the fact that an annotation type cannot explicitly declare a    superclass or superinterface is that a subclass or subinterface of an annotation type    is never itself an annotation type."  subtyping isn't actually the issue we're interested in.  The thing *must be an annotation type*, and that's what ecj should complain about (and its how the check is already implemented ...)  Not marking [1.8] since the problem already exists in master,  although this is even more fun with JSR 308 :)
Found that 'Inline finally blocks' option is enabled incorrectly: 1. In the compiler preference page, select 'Configure Project Specific Settings' and choose a Java 1.4 project. Select the 'Java Build Path' and modify the EE to J2SE-1.5. Use the back button or directly click on the Java Compiler to come back to the previous page where the project specific setting was being modified. See that the 'Inline finally blocks' is enabled for Java-1.5, which is wrong.  2. In the compiler preference page, select 1.4 compliance level. Now uncheck 'Inline finally blocks' option. Now change the compliance level to 1.5 and then change to 1.6 and now change it back to 1.4, the checkbox is now checked. This also looks wrong.
Created attachment 235123 [details] SneakyCaster.java  To reproduce, compile (and then run) the attached SneakyCaster.java using both javac and ECJ.  ECJ misses the checkcast instruction at the end of the cast() method. This allows assignment of an Object to a Runnable variable. Eventually, the JVM throws an IncompatibleClassChangeError, but clearly, as there is only one .class file, that's not right.  javac correctly includes the checkcast instruction, and a ClassCastException is thrown before the invalid assignment could ever be made.
The IVariableBinding for a LambdaExpression parameter has a non-unique key:      IntPredicate f = (i) -> i == 1;     IntPredicate g = (i) -> i != 2;  Key for both variables 'i' is just '#i'. Should be prefixed with the LambdaExpression's method binding key.
"Created attachment 235166 [details] Screenshot  package misc.test;  interface FI { 	int foo(int s1, int s2); }  class Test { 	FI fi= /*a*/ (int n1, int n2) -> n1 * n2; } -------------------------- Steps: 1. To get the JLS8 AST, set org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.SHARED_AST_LEVEL to AST.JLS8. 2. Add a breakpoint in org.eclipse.jdt.internal.core.CompilationUnit.reconcile(int astLevel, int reconcileFlags, WorkingCopyOwner workingCopyOwner, IProgressMonitor monitor). 3. Paste the above example in package explorer of the runtime workbench. 4. Edit the file and check the AST created in #reconcile(..) for the lambda parameter ""int n1"".  The startPosition and length are wrong as shown in the attached screenshot. (Example: length is 13 instead of 6. It includes the comment /*a*/ also along with ""int n1"")"
The MANIFEST.MF holds:  org.eclipse.jdt.annotation;bundle-version="[1.1.0,2.0.0)", org.eclipse.jdt.annotation;bundle-version="[2.0.0,3.0.0)"  which looks strange to me why not directly setting   org.eclipse.jdt.annotation;bundle-version="[1.1.0,3.0.0)"  the CBI builds fails with the current definition
While generifying API tools I came across some use of TagElement#fragments and while trying to update our code I realized IDocElement is not an API (or even visible) class - which is mentioned in the API docs as the list type:  * @return the live list of doc elements in this tag element * (element type: {@link IDocElement}) */ public List fragments() { ... }  The doc does mention what kinds of nodes (implementations of IDocElement) can appear in the list, but it does not make sense to mention a private class in the API docs.   Consumers basically have to do the following:  List<ASTNode> fragments = tagelement.fragments();  when they are expecting to be able to do (according to the docs):  List<IDocElement> fragments = tagelement.fragments();
Looks like the M-build needs to be touched.
The CHKPII rule is: Messages that contain {0} etc. must use '' as single quote, but messages without any placeholders must use a single ' .
Shouldn't we update http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties?h=R4_3_maintenance to say 3.9.1 in compiler.version?
"Created attachment 235330 [details] Test case to reproduce the issue  Exception in thread ""main"" java.lang.IncompatibleClassChangeError 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:383) 	at X.main(X.java:4) Caused by: java.lang.NoSuchMethodException: no such method: java.lang.invoke.LambdaMetafactory.metaFactory(Lookup,String,MethodType,MethodHandle,MethodHandle,MethodType)CallSite/invokeStatic 	at java.lang.invoke.MemberName.makeAccessException(MemberName.java:765) 	at java.lang.invoke.MemberName$Factory.resolveOrFail(MemberName.java:882) 	at java.lang.invoke.MethodHandles$Lookup.resolveOrFail(MethodHandles.java:1019) 	at java.lang.invoke.MethodHandles$Lookup.linkMethodHandleConstant(MethodHandles.java:1284) 	at java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:381) 	... 1 more Caused by: java.lang.NoSuchMethodError: java.lang.invoke.LambdaMetafactory.metaFactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; 	at java.lang.invoke.MethodHandleNatives.resolve(Native Method) 	at java.lang.invoke.MemberName$Factory.resolve(MemberName.java:854) 	at java.lang.invoke.MemberName$Factory.resolveOrFail(MemberName.java:879) 	... 4 more  Use b104 build on windows for JRE 1.8 to reproduce the issue As a follow up for bug 413913  Also see http://dev.eclipse.org/mhonarc/lists/jdt-core-dev/msg02324.html"
BETA_JAVA8:  This test asserts in the last line:   assertEquals("Wrong qualified name", "test404489.bug.X.Y", binding.getQualifiedName())  The bindings qualified name is actually test404489.bug.X.  I have disabled this line. Please reenable after fix.
+++ This bug was initially created as a clone of Bug #416904 +++  In order to lower entry barrier for contribution and execution of unit tests, it would be quite helpful to make it possible to run tests with tycho-surefire-plugin and a simple "mvn clean v
"The quick assist (Convert to 'if-!-return') is not offered in a lambda body at valid 'if' locations. Examples:  package misc.test;  @FunctionalInterface interface A { 	void run(int n); }  @FunctionalInterface interface B { 	A foo(int x); }  public class Test { 	A fi0 = (n) -> { 		if (n == 0) {	// [1] 			System.out.println(n); 			return; 		} 	}; 	 	int fun1(int a, int b) { 		A fi2 = (n) -> { 			if (a == b) {	// [2] 				System.out.println(n); 				return; 			} 		}; 		return a + b; 	}  	A fun2(int a, int b) { 		return (n) -> { 			if (a == b) {	// [3] 				System.out.println(n); 				return; 			} 		}; 	}  	int fun3(int a, int b) { 		B fi3 = (x) -> (n) -> { 			if (a == b) {	// [4] 				System.out.println(a); 				return; 			} 		}; 		return a + b; 	} }"
After ASTNodes#getType(VariableDeclaration) method is updated to return 'null' for a type inferred lambda parameter, callers of the method need to be fixed iff there's a possibility that the given VariableDeclaration is a type inferred lambda parameter.  Patch to update ASTNodes#getType(VariableDeclaration) to return 'null' is attached in bug 407985 comment #3.
I20130810  The fix for bug 338350 uncovered lots of new "unchecked cast" warnings in my code (core.resources). No quick fix is proposed in this case. It would be useful to have a quick fix to resolve these new problems.
"--------------------------- package test.bugs;  @FunctionalInterface interface FI { 	int foo1(int a); }  class FI_1 { 	void fun(int a) { 		FI i1 = x1-> x1; 		FI i2 = xxx-> { 			i1.foo1(a); 			return xxx; 		}; 	} } --------------------------- Steps: 1. To "
4.3 and 4.3.1.  Currently the 'compiler.version' in  /org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties has to be updated manually when the version changes. Only the qualifier is a variable. This can lead to mismatches (see e.g. bug 416780). We should use (create if not yet there) bundle_version instead, i.e. compiler.version = bundle_version
"BETA_JAVA8:  Eclispe compiler has trouble with the following code:  package p; public class XX { 	public @Marker(""1"") String foo(int @Marker @Marker2 ... args) { 	      return null; 	} }  The following is compiled with no issues:  package p; public class XX { 	public @Marker(""1"") String foo(int @Marker @Marker2 [] args) { 	      return null; 	} }"
"While reviewing bug 409586, follow-up items start to pile up. Using this bug to collect and track those even though the original bug is not yet resolved so as to allow the main portion to be released soon.  From bug 409586 comment 65: (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.  (2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.  (3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.  (4) Error messages in testBug416175() 1.: mixing short and long names 2.: I like ""required \'@NonNull ? extends String\'"" better than ""required \'@NonNull capture#\'"" when it's clear we're not interested in compatibility of the capture itself, only in null safety.  From bug 409586 comment 83: (5) Investigate new locations throwing IllegalStateException to see if we can convince ourselves that these are ""impossible to reach"" :)   New items: (6) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous. Any client expecting this to show per-use null annotation tagbits will fail. Currently there appear to be no such clients, but ...  (7) Investigate: To challenge whether delegation to prototype is OK in STB#memberTypes(): will annotated reference to member type @TA Outer.Inner see its Outer as @TA (at the binding level)?  (8) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits! 'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:   @NonNullByDefault class AllAreNonNull { 	String s3 = """"; // leaving this uninitialized would be detected 	void test() { 		this.s3 = null; // this goes unnoticed!!! 	}   } Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+   (9) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:   this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});   this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()}); Seeing these as marked TODO could indicate there's more to this??  (10) BinaryTB#toString() needs update for instantiations similar to STB."
"BETA_JAVA8:  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd released on behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=417113 needs some tweaking/massaging in the type annotated null analysis support. These were captured during review of the mentioned patch and the present CR is being opened to track such tasks.  From bug 409586 comment 65: (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.  (2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.  (3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.  (4) Error messages in testBug416175() 1.: mixing short and long names 2.: I like ""required \'@NonNull ? extends String\'"" better than ""required \'@NonNull capture#\'"" when it's clear we're not interested in compatibility of the capture itself, only in null safety.   (5) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits! 'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:   @NonNullByDefault class AllAreNonNull { 	String s3 = """"; // leaving this uninitialized would be detected 	void test() { 		this.s3 = null; // this goes unnoticed!!! 	}   } Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+   (6) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:   this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});   this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()}); Seeing these as marked TODO could indicate there's more to this??  [No, I didn't know env.getNonNullAnnotation() was available]  (7) BinaryTB#scanFieldForNullAnnotation had an initial stanza which served two purposes for the 1.8+ case: - apply a @NonNullByDefault to the field's type binding - shortcut everything else that is needed only for 1.7-  Frankly, I don't understand this change. The first aspect may partly be covered by VariableBinding#isNonNull() which checks tagBits at the FieldBinding AND at its type, but this is probably not sufficient/safe.  [Sorry, I may have been guilty of over-pruning here and in a few other places]"
"Here is a simple code:  class X { 	public void foo(@Marker int p) {} }  Now, for parameter 'p', Argument#type#resolvedType (which is a BaseTypeBinding)doesn't contain the type use annotations. Interestingly, Argument#binding#type (which is also a BaseTypeBinding) contains the annotations correctly. Ideally, they should be referencing the same object."
Following tests fail when the following debug options are on:  org.eclipse.jdt.core/debug/dom/ast=true org.eclipse.jdt.core/debug/dom/ast/throw= true org.eclipse.jdt.core/debug/dom/ast/rewrite = true  The failures are listed below:  TypeAnnotationsConverterTests : test0003, test0004, test0005, test0008. ASTConverter18Test : test0004, test0006, test0015, test399794. ASTRewritingMethodDeclTest: testListInserts(JLS8), TestMethodReturnTypeChanges2_only_2( JLS2),TestMethodReturnTypeChanges_only_2 (JLS2). ASTRewritingTypeAnnotationsTest: testClassInheritenceAnnotations(JLS8). ASTRewritingReferenceExpressionsTest: 4 failures testRE_test00{1,3,4,5}_since_8   This may be converted to an umbrella bug for better tracking if the patches are grouped for particular sets.
Created attachment 235645 [details] Test code to reproduce the issue  ArrayTypeReference generated for argument is incorrect.  Expected: int [] @TakeType(int[].class) []  Actual: int @TakeType(int[][].class) []  (only 1 dimension shown in actual, while the 2nd dimension is shown as part of annotations).
"Use the ASTView on the following code and get an error dialog about 'Bad AST Node structure.  package p; public class X  {     public static void main(String [] args) {     	W w = (@Marker W<String>) null;     } } class W<T> { } @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE) @interface Marker {}  The problem appears that in this particular case the AnnotatableType (@Marker W<String>) doesn't include the annotation in it's source range."
"BETA_JAVA8:  // --  import org.eclipse.jdt.annotation.NonNull;  public class X<T> {     	public static void main(String[] args) { 		@NonNull String @NonNull [] s = new @NonNull String [] { null }; 		if (s != null && s[0] != null) { 			System.out.println(""Not null""); 		} 		System.out.println(""Length = "" + s[0].length()); 	} }  // ---  Program generates an NPE. The warnings about redundant null check from previous  lines give false assurance, since we don't warn at the array creation site, where a null sneaks in."
"BETA_JAVA8:  Following program causes the compiler to cause an NPE:  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;  import org.eclipse.jdt.annotation.NonNull;  @Target(ElementType.TYPE_USE) @interface TypeAnnotation { 	 } public class X<T> {    class Y {} 	void foo(@NonNull X<@NonNull ?> l) {  	}	 	public static void main(String[] args) { 		X<String> s = new X<>();                 s.foo(s);  	} }"
Eclipse Kepler  There appears to be a case where NewJavaProjectWizardPageTwo causes an SWT Invalid Thread Access when using Bndtools.  This problem has been reproduced by others.  To reproduce, create a new workspace, switch to the Bndtools perspective, create a new Bndtools OSGi project.  You should get the Invalid Thread Access.  The workaround is to delete the project you just created and create it again.  I believe the key here is that you have a brand new workspace.  Here is the stack trace.  org.eclipse.swt.SWTException: Invalid thread access    at org.eclipse.swt.SWT.error(SWT.java:4397)    at org.eclipse.swt.SWT.error(SWT.java:4312)    at org.eclipse.swt.SWT.error(SWT.java:4283)    at org.eclipse.swt.widgets.Display.error(Display.java:1204)    at org.eclipse.swt.widgets.Display.checkDevice(Display.java:759)    at org.eclipse.swt.widgets.Display.disposeExec(Display.java:1181)    at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.hookDisplay(ImageDescriptorRegistry.java:77)    at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.<init>(ImageDescriptorRegistry.java:40)    at org.eclipse.jdt.internal.ui.JavaPlugin.internalGetImageDescriptorRegistry(JavaPlugin.java:954)    at org.eclipse.jdt.internal.ui.JavaPlugin.getImageDescriptorRegistry(JavaPlugin.java:347)    at org.eclipse.jdt.internal.ui.wizards.buildpaths.CPListLabelProvider.<init>(CPListLabelProvider.java:68)    at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.<init>(BuildPathsBlock.java:189)    at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.getBuildPathsBlock(JavaCapabilityConfigurationPage.java:95)    at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.init(JavaCapabilityConfigurationPage.java:151)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.initializeBuildPath(NewJavaProjectWizardPageTwo.java:318)    at bndtools.wizards.project.NewBndProjectWizardPageTwo.initializeBuildPath(NewBndProjectWizardPageTwo.java:106)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:252)    at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.performFinish(NewJavaProjectWizardPageTwo.java:484)    at org.eclipse.jdt.internal.ui.wizards.JavaProjectWizard.finishPage(JavaProjectWizard.java:82)    at org.eclipse.jdt.internal.ui.wizards.NewElementWizard$2.run(NewElementWizard.java:118)    at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)    at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)    at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345)    at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5331)    at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)    at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
A quick assist can be added to infer lambda parameters in a lambda expression which has type inferred (type-less) parameters.   It would be useful to know the types of the lambda parameters explicitly, in cases where the functional interface is not in the same class or project.  Example: Invoking infer lambda parameters quick assist on the lambda expression:   Button button = new Button(); button.addActionListener(e -> foo());  should result in:  Button button = new Button(); button.addActionListener((ActionEvent e) -> foo());
BETA_JAVA8:   With the deep encoding of type annotations, most subsystems of the compiler should stop using == and != for binding comparisons and use TypeBinding.equalsEquals and its counterpart.  We need an automated way to catch these places. I propose that we build a special build environment compiler that would warn on type binding comparisons.  Once it is operational, we may want to allow a mechanism to tolerate == and != comparisons on specially tagged situations like the FALL-THROUGH tag for switch cases without breaks.
In the ArrayType implementation specify the white space requirements  Ref bug 413569 comment 18 last two items (reproduced below)  - ASTRewritingStatementsTest file, testBug400568_a_since_8 has two additional white spaced after removal of annotations on dimensions. To be changed?  - TypeAnnotationsConverterTest -  String [] [] [] [] - do we need these spaces if there are no annotations on dimensions?
"import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator;  public class Snippet {  	void foo() { 		Collections.sort(new ArrayList<String>(Arrays.asList(""c"", ""b"", ""a"")), 				new Comparator<String>() { 					@Override 					public int compare(String o1, String o2) { 						return o1.compareTo(o2); //[1] 					} 				});  		Collections.sort(new ArrayList<String>(Arrays.asList(""c"", ""b"", ""a"")), 				(String o1, String o2) -> o1.compareTo(o2)); //[2] 	} } -------------------------  Hover over #compareTo at the specified locations [1] and [2]. Javadoc is shown on hover only at [1] and not at [2]."
Consider the below method: public void foo(java.io.@TypeUse FileNotFoundException arg, A type){ } When 'move' refactoring is invoked on #foo: ImportRewrite#addImport(ITypeBinding binding, AST ast, ImportRewriteContext context) is invoked with the VariableBinding corresponding to <java.io.@TypeUse FileNotFoundException arg>, where it is expected to return a PackageQualifiedType which contains the TYPE_USE annotation details as well. This is not currently handled in #addImport(...)and the method returns a SimpleType and the TYPE_USE annotation details are missing.
We must support the extension to the language model API - specifically javax.lang.model.AnnotatedConstruct.getAnnotationsByType(Class<A>) - in order to support annotation processing of repeated annotations.
"package org.eclipse.jdt.demo;  class Math { 	public static int max(int a, int b) { 		if (a > b) return a; 		return b; 	} 	public static int min(int a, int b) { 		if (a < b) return a; 		return b; 	} 	// ... }  interface BinaryOperator<T> { 	T evaluate(T left, T right); }  class Calc { 	BinaryOperator<Integer> max1 = (a, b) -> Math.max(a, b); 	BinaryOperator<Integer> max1 = Math.max| }  Ctrl+Space at the specified location ""|"" after Math.max results in NPE:  org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred 	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63) ... ... Caused by: org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:125) ... ... Caused by: java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.util.ObjectVector.contains(ObjectVector.java:75) 	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.computeVisibleElementBindings(InternalExtendedCompletionContext.java:224) 	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.getVisibleElements(InternalExtendedCompletionContext.java:376) 	at org.eclipse.jdt.internal.codeassist.InternalCompletionContext.getVisibleElements(InternalCompletionContext.java:324) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.getAssignableElements(ParameterGuessingProposal.java:113) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.guessParameters(ParameterGuessingProposal.java:322) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeGuessingCompletion(ParameterGuessingProposal.java:254) 	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeReplacementString(ParameterGuessingProposal.java:220) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getReplacementString(LazyJavaCompletionProposal.java:331) ..."
"package com.test_a.t1;  import java.lang.annotation.ElementType; import java.lang.annotation.Target; import java.util.List;   @Target(ElementType.TYPE_USE) @interface Readonly { }  class UnmodifiableList<T> implements @Readonly List<@Readonly T> { }  ---------------------------- Edit the file. We get multiple exceptions in the error log view:  Error in JDT Core during AST creation  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.constantPoolName(TypeVariableBinding.java:303) 	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.signature(ReferenceBinding.java:1651) 	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.signature(MethodBinding.java:1142) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateMethodInfoHeader(ClassFile.java:3282) 	at org.eclipse.jdt.internal.compiler.ClassFile.addMissingAbstractProblemMethod(ClassFile.java:584) 	at org.eclipse.jdt.internal.compiler.ClassFile.generateMissingAbstractMethods(ClassFile.java:3342) 	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:853) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:573) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:367) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1213) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541) 	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484) 	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132) ..."
"Fresh install of Eclipse 4.3 with a new workspace. Create a new maven based projects based on the quickstart archetype. Add a dependency on org.jooq:jooq:3.1 (http://www.jooq.org/) Create a new class with a main method. In the method type:     DSLContext ctx=DSL.using(SQLDialect.ORACLE);     ctx.  <- autocompletion pops up here Press 's' (to look for 'select' method)  Autocompletion stops working and the following exception is logged in the error.log: Message: Unhandled event loop exception Stack trace: org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.ArrayIndexOutOfBoundsException: 1) 	at org.eclipse.swt.SWT.error(SWT.java:4397) 	at org.eclipse.swt.SWT.error(SWT.java:4312) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3717) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3366) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) 	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138) 	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1450) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Caused by: java.lang.ArrayIndexOutOfBoundsException: 1 	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findMethodParameterNames(InternalCompletionProposal.java:314) 	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findParameterNames(InternalCompletionProposal.java:1440) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.appendUnboundedParameterList(CompletionProposalLabelProvider.java:113) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createMethodProposalLabel(CompletionProposalLabelProvider.java:272) 	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createStyledLabel(CompletionProposalLabelProvider.java:570) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.computeDisplayString(LazyJavaCompletionProposal.java:263) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getDisplayString(LazyJavaCompletionProposal.java:246) 	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.isValidPrefix(AbstractJavaCompletionProposal.java:802) 	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.isValidPrefix(LazyJavaCompletionProposal.java:378) 	at org.eclipse.jdt.internal.ui.text.java.JavaMethodCompletionProposal.isValidPrefix(JavaMethodCompletionProposal.java:289) 	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.validate(AbstractJavaCompletionProposal.java:754) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1486) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1449) 	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:375) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) 	... 24 more  Googling for a solution I've also found the same issue reported in the following bug report on a different library: https://code.google.com/p/projectlombok/issues/detail?id=545  Session data: eclipse.buildId=4.3.0.I20130605-2000 java.version=1.7.0_25 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=it_IT Framework arguments:  -product org.eclipse.epp.package.jee.product Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product"
"BETA_JAVA8:  We just ran into this testing APT changes for JSR308.  Given:  // --- import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable;   public class X { 	int @Nullable [] f @NonNull [] = null;  } // ----   on the compiler side, when incorrectly fold the extra dimensions into total  dimensions and end up with   int @Nullable [] @NonNull [] f;  It should be   int @NonNull [] @Nullable[] f;  Since in a C style array declaration, the extra dimension should bind more readily with the field than any type components preceding it.  While the compiler side story is easy to fix, it will break DOM/AST encoding unless care it taken: some original dimensions could start showing up as extra dimensions and vice versa !  I think it is not hard to fix cleanly end to end. I'll see what can be done."
"Created attachment 235915 [details] Project  Tested on Eclipse 4.3  Steps to reproduce: 1 _ download and install attached project 2 _ notice the nullness error on doSomething which is correct 3 _ check doSomethingGeneric method. It is declared the same way as doSomething, expect it uses generic. However no error is reported  Expect behavior: An error should be reported for the generic type as well  Tested code:  public interface GenericInterface<T> { 	T doSomethingGeneric(T o); }  public interface Interface { 	Object doSomething(Object o); }  @ParametersAreNonnullByDefault public class Implementation implements GenericInterface<Object>, Interface {  	@Override 	public Object doSomethingGeneric(Object o) { // <-- this error is not reported 		return o; 	}  	@Override 	public Object doSomething(Object o) { // <-- this error is correctly reported 		return o; 	} }"
"BETA_JAVA8:  // --- class Outer<K>  { 	class Inner<P> { 	} 	public @T(1) Outer<@T(2) String>.@T(3) Inner<@T(4) Integer> @T(5) [] omi @T(6) []; } @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE) @interface T { 	int value(); } // --  Given the above, ECJ generates only 5 annotations. There should be 6. The one with the type path: FIELD, location=[ARRAY, ARRAY, INNER_TYPE] is absconding.  AST and bindings look correct.   While debugging, you may notice that the extended dimensions would appear ahead  of the base dimension. This is the right behavior. See bug 418096."
Version: 4.2.0  Build id: I20120608-1400  Tests below started to fail from JDK8 b108 in org.eclipse.ltk.core.refactoring.tests package: testReadDescriptor4 testReadDescriptor5   Expected refactoring descriptor is not equal to actual one: expected:<... comment,arguments={[arg1=value 1, version=1.0]},flags=1]> but was:<... comment,arguments={[version=1.0, arg1=value 1]},flags=1]>  junit.framework.ComparisonFailure: Expected refactoring descriptor is not equal to actual one: expected:<... comment,arguments={[arg1=value 1, version=1.0]},flags=1]> but was:<... comment,arguments={[version=1.0, arg1=value 1]},flags=1]> at org.eclipse.ltk.core.refactoring.tests.history.RefactoringHistorySerializationTests.compareReadHistory(RefactoringHistorySerializationTests.java:65) at org.eclipse.ltk.core.refactoring.tests.history.RefactoringHistorySerializationTests.testReadDescriptor4(RefactoringHistorySerializationTests.java:216) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:501) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:259) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3529) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3182) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1022) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:916) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:585) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:540) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) at org.eclipse.equinox.launcher.Main.run(Main.java:1438) at org.eclipse.equinox.launcher.Main.main(Main.java:1414) at org.eclipse.core.launcher.Main.main(Main.java:34)  Steps to Reproduce: Use eclipse-Automated-Tests-4.2 to run automated tests with jdk8. 1. Install jdk8 (b108 or b109) from http://jdk8.java.net/download.html  2. Run ltkcorerefactoringtests   The failures are reproducible on solaris & windows (32-bit)
"The following NPE ensures I don't get any work done.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getEnclosingReferenceTypeName(JavaBreakpoint.java:242) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.createRequests(JavaBreakpoint.java:595) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.addToTarget(JavaBreakpoint.java:584) 	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.addToTarget(JavaLineBreakpoint.java:172) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointAdded(JDIDebugTarget.java:1287) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initializeBreakpoints(JDIDebugTarget.java:522) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initialize(JDIDebugTarget.java:448) 	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.<init>(JDIDebugTarget.java:315) 	at org.eclipse.jdt.debug.core.JDIDebugModel$1.run(JDIDebugModel.java:183) 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) 	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:187) 	at org.eclipse.jdt.internal.launching.StandardVMDebugger.createDebugTarget(StandardVMDebugger.java:471) 	at org.eclipse.jdt.internal.launching.StandardVMDebugger.run(StandardVMDebugger.java:347) 	at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.launch(JUnitLaunchConfigurationDelegate.java:174) 	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:858) 	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:707) 	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1018) 	at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1222) 	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
BETA_JAVA8:  There is some set up issue in TypeBindingTests308.java - when run by itself the tests testAnnotatedBinaryType* pass. When run as part of RunAllJava8Tests they fail. I fixed one issue to with picking up wrong JCL libraries, but that does not seem to be all there is to it. Now the tests are failing with "Outer cannot be found" which tells me that the library got added to the wrong project - i.e the working copy from which an AST is built is from a different project than the one to which the library was addeded.
We have gone back and forth with a few different attempts at this, but no satisfactory solution so far.  NTAT:_testConditional2 is the disabled test.  I would recommend we explore an option that does not modify the routines invoked by scope.lowerUpperBound and keep all machinery to support this outside if possible.  -- We don't have an issue if types are == -- We likely don't have an issue if lowerUpperBound returns an intersection type as is (is this true ?) -- We have an issue when the disparately annotated types collapse into one of the constituents.  Perhaps we can write a method ConditionalExpression#lowerUpperBound that would call scope.scope.lowerUpperBound and trap the case where the latter returns a single type and come up with a solution that would reannotate  appropriately. This would leave the JLS routines untouched. I think some incarnations of this may have existed earlier and I may have pruned it believing a simpler solution could be come up with - sorry if this is the case.  We need to see if the same issue rears it heads with multi catch blocks. Jay, please write an annotation processor that would query the type of a catch parameter - I believe local variables annotations are exposed.  We want to see what the binding that corresponds to the UTC contains when the constituent type references are equally type annotated and unequally type annotated.
##### Bug explanation #####  Usage of  ASTParser.createASTs(String[] sourceFilePaths, String[] encodings, String[] bindingKeys, FileASTRequestor requestor, IProgressMonitor monitor) with option ASTParser.setResolveBindings( true ) produce many org.eclipse.jdt.core.dom.CompilationUnit objects. Each of them contains its own AST object,  with own DefaultBindingResolver object,  which shares SINGLE DefaultBindingResolver.BindingTables with every other DefaultBindingResolver (and so AST,  and CompilationUnit objects) created during  single "createASTs" batch parsing call.  DefaultBindinResolver Javadoc says: "* IMPORTANT: The methods on this class are synchronized. This is required  * because there may be multiple clients in separate threads concurrently  * reading an AST and asking for bindings for its nodes. These requests all  * end up invoking instance methods on this class. There are various internal  * tables and caches which are built and maintained in the course of looking  * up bindings. To ensure that they remain coherent in the presence of multiple  * threads, the methods are synchronized on the DefaultBindingResolver instance."  Unfortunately parsing (performed as described above) creates many  DefaultBindingResolvers with shared single BindingTables object so all those synchronisations on methods do nothing to prevent asynchronous modifications of this maps. Such events do happen during any of various "resolveBinding()"-like method calls performed by multiple threads.  ######## Errors the bug causes ########  In case of our project the bug often cause a damage of DefaultBindingResolver.BindingTables.compilerBindingsToASTBindings HashMap, which makes our threads constantly running on HashMap.getEntry on  INFINITE LOOP, which looks like following:  java.lang.Thread.State: RUNNABLE at java.util.HashMap.getEntry(HashMap.java:446) at java.util.HashMap.get(HashMap.java:405) at org.eclipse.jdt.core.dom.DefaultBindingResolver.getTypeBinding (DefaultBindingResolver.java:526) - locked <0x00000000b6da8bb0>  (a org.eclipse.jdt.core.dom.DefaultBindingResolver) at org.eclipse.jdt.core.dom.MethodBinding.getDeclaringClass (MethodBinding.java:131) ...  We use ASTParser.createASTs(..) instead of multiple ASTParser.createAST(..)  because the amount of used memory drop is quite significant (we had to store part of IBinding objects in memory).   ######## Proposed solution ########  The solution may be as simple as using ConcurrentHashMap in  DefaultBindingResolver.BindingTables.
http://download.eclipse.org/eclipse/downloads/drops4/N20131002-2000/testResults.php
Created attachment 236121 [details] the semicolon makes the difference  The result of detecting so called 'additional occurences' depends on whether or not the selection includes the semicolon.  See Screenshot.
NullTypeAnnotationTest.testWildcardCapture3() shows an example where a @Nullable type is successfully passed to a @NonNull parameter.  The expected type has contradictory annotations and I think we look at @Nullable first and allow it to pass through.  I think it may in general be a good idea to check for @NonNull first since violating it unsafe.
"BETA_JAVA8:  In LookupEnvironment::LookupEnvironment, we have this code:  boolean stillTesting = true; if (this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && (stillTesting || this.globalOptions.storeAnnotations)) { 		this.typeSystem = new AnnotatableTypeSystem(this); 	} else { 		this.typeSystem = new UnannotatedTypeSystem(this); 	}  At some suitable point, we should remove the boolean and let the other gating conditions decide whether bindings should carry annotations or not.  Raising this defect so we don't drop this ball."
"From https://bugs.eclipse.org/bugs/show_bug.cgi?id=413613#c24:  That leaves us with 3 old failures. These are in two buckets:  (1) testTypesWithSystemCompiler and testTypesWithEclipseCompiler are due to the same problem. In JRE8, the class HashMap#HashIterator is not generic. I believe it was previously generic (JRE7 ?)  I suspect this class is not standard API since it is missing in IBM JREs (See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=258906)  Tests should be rewritten to avoid using non-standard classes.  (2) The other bug is due to as Jay mentioned how the javadoc is differently formatted. I see this comment in ElementsImpl#formatJavadoc:  /** 	 * Strip the comment characters from a javadoc comment. Assume the comment is already 	 * missing its closing delimiter. 	 * 	 * Javac's behavior with regard to tab expansion and trimming of whitespace and 	 * asterisks is bizarre and undocumented.  We do our best here to emulate it. 	 */  So the tests should be rewritten to convert all tabs to spaces, strip out all non-significant white spaces before comparing."
BETA_JAVA8:   We presently copy, but we should move the SE8 annotations that feature in SE7  locations so the field, local, parameter, method does not reflect this binding.  See org.eclipse.jdt.internal.compiler.ast.ASTNode.copySE8AnnotationsToType(BlockScope, Binding, Annotation[])
ASTRewrite should allow removing the left and right operands of an infix expression. We need this for a clean fix for bug 406347. Fix is already ready.  <rant>The design of InfixExpression is flawed. We should not have created separate properties for the first two operands. We can't change that now, but we should keep this in mind for future AST nodes.</rant>
Created attachment 236249 [details] Test case to reproduce the issue  Outer1. @Marker1 Inner is represented as a SimpleType of QualifiedName where the anotations sit on SimpleType, while QN includes Outer1 and Inner but not the annotation. Need to alter the representation. [follow up of bug 417659]
JDT Core: 3.9.1.v20131009-0108-BETA_JAVA8  The following code is flagged as incorrect:           // Person: one of its methods is public String getLast() {...}         List<Person> roster = ...;                  Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         p -> p.getLast(), [1]                         p -> p            [2]                     ));  The BETA_8 JDT shows these 2 error message:  [1] The method getLast() is undefined for the type T [2] Type mismatch: cannot convert from T to U  If expressed as follows:           Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         Person::getLast,     [3]                         Function.identity()                     ));  The BETA_8 JDT now shows this error:  [3] The type Person does not define getLast(T) that is applicable here  Even the following has a problem:           Map<String, Person> map =              roster                 .stream()                 .collect(                     Collectors.toMap(                         new Function<Person, String>() {    [4]                             public String apply(Person p) {                                  return p.getLast();                              }                          },                         Function.identity()                     ));  [4] Type mismatch: cannot convert from Map<String,Object> to Map<String,Person>  There actually seems to be a regression with the most recent nightly build compared to some from a few weeks ago: in the earlier one, problem #[4] did not occur.   For contrast, Netbeans nightly build (201310070001) handles all these just fine, and it actually makes suggestions for refactoring from the anonymous class to a lambda, and more.   Eclipse can be seen to be lagging a good bit behind here, I'm sorry to say.
"master and BETA_JAVA8  ITypeBinding#getModifiers() misses the implicit ""static"" modifier for member interfaces of a class:  public class C { 	interface IC {} // implicitly static, see JLS7 8.5.1 }  (If you wonder about the reference to JLS7 8.5.1, then you may have an old version of JLS7 that contains a section 8.5.2 and a bogus 8.5.1 that said IC would be implicitly public -- that part has been removed again)."
BETA_JAVA8:  From https://bugs.eclipse.org/bugs/show_bug.cgi?id=417113#c63:  // -- Working on type inference I discovered: - an InferenceVariable (subclass of TypeVariableBinding) appeared twice as a key in a HashMap, assumably caused by: - TypeBinding.hashCode relies on stability of TypeBinding.id - UnannotatedTypeSystem lazily assigns ids, which violates stability  In that particular case I can workaround by either of: - eagerly registering with UTS - overriding hashCode() and equals()  Raising this issue here, because: - the problem could potentially affect other subclasses of TypeBinding? - the lone hashCode() looks strange without a matching equals()  @Srikanth, do you have reasons at hand, why the existing code is safe, or should I file a new bug?  // --  No, the existing code is not safe as your HashMap experience shows. The id assignment is safe from the pov of UTS + ATS, but that is not good enough.  I'll work on resolving this asap. Thanks for catching this.
The spec says:  It is a compile-time error if a declaration is annotated with any annotations of a repeatable annotation type T and more than one annotation of the containing annotation type of T.  Assuming FooContainer is itself a repeatable annotation type with a containing annotation type of FooContainerContainer, one might expect the following code to be legal:  @Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)}) class A {}  But this code is allowed by eclipse compiler.
The implementation of JavaCorePreferenceModifyListener#preApply may cause unexpected removal of Java preferences. The issue was reported initially in bug 418046 and this bug will focus on changes required to fix the jdt.core part.  The node passed as an argument to the preApply method is always an IExportedPreferences node which means it is a "delta" that will be applied to the global hierarchy. If a listener modifies this delta by creating an empty node, then all preferences of this node will be removed in the global hierarchy.  Reproducible scenario: 1. Download the plugin from https://bugs.eclipse.org/bugs/attachment.cgi?id=235817 2. Import it to your workspace. 3. Start self-hosted Eclipse. 4. Modify one of Java preferences in Window > Preferences > Java > Compiler, e.g. change compiler compliance to "1.3". Click OK. 5. Restart the inner Eclipse. => Check that compiler compliance is set back to the default and our "1.3" is lost.
In my current understanding of JSR 335 spec 0.6.3, type inference needs the following bits of information, which should probably be computed and stored during overload resolution:  - strict / loose / variable-arity invocation  - "pertinent to applicability"  Both are   produced by: 15.12.2.2-4   consumed by: 18.5.1 (and .2)
The features 'all references' and 'all instances' may not work properly and throw NPE in Eclipse.  Cause: JDIDebugTarget.getJavaTypes(String) returns null if requested object was not loaded. The JDI Model implementation assumes that java.lang.Object[] is loaded whenever 'all references' or 'all instances' features are executed.  Fix suggestion: Check for a null value in constructors JDIReferenceListValue.<init>(IJavaObject) and JDIAllInstancesValue.<init>(JDIDebugTarget, JDIReferenceType). The null value can be returned by JDIDebugTarget.getJavaTypes(String) method.   I must admit I cannot proof what exactly is in accordance with the JVM Specification but I am deeply convinced the Object[] is not guaranteed to be loaded before the main method of the application is entered.   How to reproduce this bug: Use a VM that doesn't load java.lang.Object[] by default such as Java PathFinder (http://babelfish.arc.nasa.gov/trac/jpf).   I will create a pull request on Github to fix this bug.   Thanks, Stepan
BETA_JAVA8:  The following program fails to compile. We get: Type mismatch: cannot convert from Class<TC> to Class<? extends Annotation>  // -- import java.lang.annotation.Annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Target;  @R(TC.class) @Target(ElementType.TYPE_PARAMETER) @interface T { }  interface I<@T K> { }  @Deprecated @interface TC {  }  @Target(ElementType.ANNOTATION_TYPE) @interface R {     Class<? extends Annotation> value(); }  I have released a test TypeAnnotationTest.testForwardReference() encoding the wrong behavior - The test needs to fixed along with the problem.
Created attachment 236449 [details] Patch changing the ordering of boot and endorsed libs  The org.eclipse.jdt.internal.compiler.batch.Main used in a standalone environment has problems with initializing the classpath in the correct ordering. The relevant elements are: * The bootclasspaths containing the JVM libraries * The endorsedDirClasspaths containing the endorsed libs (http://docs.oracle.com/javase/6/docs/technotes/guides/standards/)  The endorsed libs need to overrule the JVM bootclasspath to fulfill it's purpose. In the current implementation the bootclasspath is added first and the endorsed are added later. This causes, that the compiler loads the JVM classes prior the classes contained in endorsed directory, which makes them useless.  The wrong ordering is initialized in the setPaths(..) method of the org.eclipse.jdt.internal.compiler.batch.Main class. In line 4533 the assembling of the final classpath starts with the bootclasspaths and adds the endorsedDirClasspaths in the first step, which causes the wrong ordering. A attached a patch which corrects the ordering.
"BETA_JAVA8:  The following program results in a class file in which the method foo() is annotated with @T. This is incorrect and needs to be fixed:  // --- import java.lang.annotation.ElementType; import java.lang.annotation.Target;   @Target({ElementType.TYPE_USE, ElementType.FIELD}) @interface T { 	 } public class X {     @T  	int foo() {  	   return 0;    } }"
"I see 3 POM version tool failures in my BETA_JAVA8 workspace:  Description	Resource	Path	Location	Type POM artifact version 3.3.401 does not match bundle version 3.3.400	pom.xml	/org.eclipse.jdt.apt.tests	line 22	POM Version Problem POM artifact version 3.9.0 does not match bundle version 3.8.2	pom.xml	/org.eclipse.jdt.core.tests.model	line 22	POM Version Problem POM artifact version 3.9.0 does not match bundle version 3.8.3	pom.xml	/org.eclipse.jdt.core.tests.compiler	line 22	POM Version Problem"
"I faced a NPE thrown in my runtime Eclipse. In this Eclipse instance I had no JRE's configured.  When now the project settings dialog is opened and selecting    Java Build Path / Libraries and selecting an unbound JRE System Library and pressing now the ""Edit"" button, a NPE is thrown.  I debugged that JavaRuntime#getDefaultVMInstall() returns null.  Inspecting this method I see that JavaRuntime#getDefaultVMId() returns ""52,org.eclipse.jdt.internal.launching.macosx.MacOSXType24,com.oracle.java.7u21.jdk"". getVMFromCompositeId() returns null for this identifier in my setup.  The error is caused by a misconfiguration in a rather unlikely scenario. However, BuildJREDescriptor#getDescription() should be more defensive for the case that no default VM is configured.   ---STACKTRACE-------------------------------------------- java.lang.NullPointerException 	at org.eclipse.jdt.internal.debug.ui.jres.BuildJREDescriptor.getDescription(BuildJREDescriptor.java:26) 	at org.eclipse.jdt.internal.debug.ui.jres.JREsComboBlock.createDefaultJREControls(JREsComboBlock.java:274) 	at org.eclipse.jdt.internal.debug.ui.jres.JREsComboBlock.createControl(JREsComboBlock.java:185) 	at org.eclipse.jdt.internal.debug.ui.jres.JREContainerWizardPage.createControl(JREContainerWizardPage.java:100) 	at org.eclipse.jface.wizard.Wizard.createPageControls(Wizard.java:174) 	at org.eclipse.jface.wizard.WizardDialog.createPageControls(WizardDialog.java:736) 	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:608) 	at org.eclipse.jface.window.Window.create(Window.java:431) 	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1089) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.ClasspathContainerWizard.openWizard(ClasspathContainerWizard.java:229) 	at org.eclipse.jdt.ui.wizards.BuildPathDialogAccess.configureContainerEntry(BuildPathDialogAccess.java:269) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.openContainerSelectionDialog(LibrariesWorkbookPage.java:888) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.editElementEntry(LibrariesWorkbookPage.java:564) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.editEntry(LibrariesWorkbookPage.java:477) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.libaryPageCustomButtonPressed(LibrariesWorkbookPage.java:272) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage.access$0(LibrariesWorkbookPage.java:250) 	at org.eclipse.jdt.internal.ui.wizards.buildpaths.LibrariesWorkbookPage$LibrariesAdapter.customButtonPressed(LibrariesWorkbookPage.java:199) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.buttonPressed(TreeListDialogField.java:171) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.doButtonSelected(TreeListDialogField.java:400) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.access$2(TreeListDialogField.java:396) 	at org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField$2.widgetSelected(TreeListDialogField.java:361) 	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4136) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1458) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1481) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1271) 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3982) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3621) 	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825) 	at org.eclipse.jface.window.Window.open(Window.java:801) 	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:158) 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498) 	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119) 	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) 	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) 	at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:468) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:885) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:567) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:508) 	at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:123) 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) 	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1074) 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4135) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1458) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1481) 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466) 	at org.eclipse.swt.widgets.Control.traverse(Control.java:4789) 	at org.eclipse.swt.widgets.Control.translateTraversal(Control.java:4573) 	at org.eclipse.swt.widgets.Control.keyDown(Control.java:2369) 	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:600) 	at org.eclipse.swt.widgets.Tree.keyDown(Tree.java:1966) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5497) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) 	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2102) 	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2299) 	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5559) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method) 	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5004) 	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5153) 	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method) 	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3618) 	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701) 	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665) 	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499) 	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1438) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1414)"
BETA_JAVA8:  (1)  org.eclipse.jdt.internal.compiler.apt.model.Factory.getAnnotationsByType(AnnotationBinding[], Class<A>) returns an Annotation[] - this is wrong. It should return an A[].  (2) We should make a best case effort to match up AnnotationMirror#toString() output with javac, so that testing can be easy
This bug was reported in bug 402983 comment 21 https://bugs.eclipse.org/bugs/show_bug.cgi?id=402983#c21
"MethodDeclaration's receiverType cannot be an AnnotatableType, since ParameterizedType is not an AnnotatableType. Example:   package jsr335.invalid;  public class C {     class A<T> {         class Inner {              public Inner(A<T> A.this) { }         }     } }  java.lang.ClassCastException: org.eclipse.jdt.core.dom.ParameterizedType cannot be cast to org.eclipse.jdt.core.dom.AnnotatableType 	at org.eclipse.jdt.core.dom.ASTConverter.convertAndSetReceiver(ASTConverter.java:888) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:543) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956) 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295) 	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212) 	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
Hello,  at http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/Filer.html it is suggested to inherit from classes generated by annotation processors:  "Instead of modifying a class directly, the class is designed so that either its superclass is generated by annotation processing or ..."  I tried that approach and regognized the following: Eclipse APT seems to "forget" any error messages, that are reported by an annotation processor, as soon as the user creates a subclass of a generated class.  To reproduce, I have created a very simple processor, the always creates an error message and a single class called GeneratedClass. At first, the error message is shown as expected (for annotated class called "ExampleAnnotatedClass"). As soon as a subclass of GeneratedClass is added , the error message disappears. With maven , the error message is shown in both cases.  Steps to reproduce:  1.) unzip attachement 2.) for project eclipse-bug-processor, call "mvn install" to create the processor 3.) import project "eclipse-bug-test" as maven project into eclipse 4.) Either install the m2e-apt connector as suggested. (if not done before) Make sure, the m2e-option "Automatically configure JDT APT is selected" 5.) There is no APT error reported! 6.) Delete the class test.InheritedClass which extends GeneratedClass  7.) Clean / build the project 8.) Now, the error "Some Error Message" appears for ExampleAnnotatedClass.  (Note: I just use m2e-apt for easier configuration of the project. The bug also is there without maven... I have also attached the jar of the annotation processor. So, you don't have to use maven at all to reproduce.)
This looks the result of fix made in bug 416911.  http://download.eclipse.org/eclipse/downloads/drops4/N20131016-2000/testresults/html/org.eclipse.jdt.compiler.apt.tests_win32.win32.x86_7.0.html  And here:  http://download.eclipse.org/eclipse/downloads/drops4/N20131016-2000/testresults/html/org.eclipse.jdt.apt.tests_win32.win32.x86_7.0.html
"The code:  @Target({ElementType.TYPE_USE}) @Repeatable(FooContainer.class) @interface Foo {} @Target({ElementType.TYPE, ElementType.TYPE_USE}) @interface FooContainer { 	Foo[] value(); }   Produces an error: The container annotation type @FooContainer is allowed at targets where the repeatable annotation type @Foo is not: TYPE   The spec seems to mention something in the lines:  ""If Foo has an @Target meta-annotation, then in the judgment of the designers of the Java programming language, FooContainer must be declared with knowledge of the Foo's applicability. Specifically, the kind of program element where FooContainer may appear must be the same as, or a subset of, Foo's kinds.""  But not very specific. This bug is to discuss this further and take it to the EG if required.  Also note that the following code is allowed after removing TYPE from @Target of FooContainer:  @FooContainer({@Foo, @Foo}) public class X { }"
"Consider the below testcase:  @Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface TypeUse {  	int value(); }  public class Shape {  }  public class Square extends @TypeUse(1) Shape implements java.awt.@TypeUse Shape{ 	 }  In Square there will be 2 compiler errors. First resolve ""Add unimplemented methods"".  After this go to the second error, place the cursor just before <|>Shape{ press backspace so now there is no space between @TypeUse and Shape{, wait for a millisecond and now the Error Log will have few NPE's.  java.lang.NullPointerException 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.copySE8AnnotationsToType(ASTNode.java:982) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1903) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1448) 	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:836) 	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200) 	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)   Java Model Exception: java.lang.NullPointerException 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:248) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at"
M2: (This is probably a platform bug but ...)  Normally the JUnit view updates each test with a pass/fail decoration as the tests progress.  With M2 I am quite frequently seeing that some of the icon decoration updates have got lost. For instance I can open a test suite that reports that it and its predecessors are still to do, but discover that the tests have actually run (the per-test decorations are correct).  The "Runs" counts seem to update correctly, so the problem seems to be just one of decorator refresh.
BETA_JAVA8:  BinaryTypeBinding:655 reads:  // Note(stephan): currently the compiler is not interested in retrieving receiver annotations, here is how we would do it: // IBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor();  Apart from this action, we also need to create an annotated type instance for the declaring class and store it in org.eclipse.jdt.internal.compiler.lookup.MethodBinding.receiver.  javax.lang.model.element.ExecutableElement.getReceiverType() and javax.lang.model.type.ExecutableType.getReceiverType() should answer the annotated type.
BETA_JAVA8:  Element.getAnnotation() should return the annotations present on an element.  An annotation A is present on a construct C if either: ◆ A is directly present on C; or ◆ No annotation of A's type is directly present on C, and C is a class,  and A's type is inheritable (§9.6.3.3), and A is present on the superclass of C.  Element.getAnnotationsByType() should return all annotations associated with an element:  An annotation A is associated with a construct C if either: ◆ A is directly or indirectly present on C; or ◆ No annotation of A's type is directly or indirectly present on C, and  C is a class, and A's type is inheritable (§9.6.3.3), and A is associated  with the superclass of C.
A recent commit that addressed the need for hashCode and equals method to be defined for AnnotationBinding is causing a failure in this test which has been temporarily disabled.  org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test._test0276  The state is restored somewhat to what it was before https://bugs.eclipse.org/bugs/show_bug.cgi?id=192774.  Needs investigation.
BETA_JAVA8:  When calling getAnnotations() on an annotation type, I don't see TYPE_USE and TYPE_PARAMETER targets being restored properly.  Patch will follow shortly.
"BETA_JAVA8:  The following program is tolerated by javac 8b108;  // -- import java.lang.annotation.ElementType; import java.lang.annotation.Target;   @Target(ElementType.TYPE_USE) @interface T { }  public class X { 	public static void main(String[] args) { 		Class<?> c = int @T [].class;  	} }   I believe oracle compiler is definitely at fault - this issue has been reported to them  until we hear confirmtion, we should turn our error into warning for now."
"1. Have an annotation and it's container as below in a project, let's say A:  @Deprecated public @interface FooContainer { 	Foo[] value(); }  @Repeatable(FooContainer.class) public @interface Foo { }  2. In the same project have this in another unit:  @FooContainer({@Foo(), @Foo()}) public class Main { }  You see the deprecated warning about FooContainer.  3. Create another project whose build path includes the bin folder of project 'A' 4. Create a similar class in the new project as step 2. 5. Notice no warning about FooContainer being deprecated."
"This code produces compilation errors:  public abstract class TestClass extends ParentClass { }  interface TestInterface { 	default int intMethod(){return 1;} }  class SuperParentClass { 	public int intMethod(){return 1;} }  abstract class ParentClass extends SuperParentClass implements TestInterface { 	abstract void parentMethod(String s); }  The reported errors (twice) being:  ""Duplicate methods named intMethod with the parameters () and () are inherited from the types SuperParentClass and TestInterface"""
"This is already allowed for static method imports from classes and the same should be allowed from interfaces too. Consider these two units:  -------------------- package a.b;  public interface J { 	static int foo(){return 0;} }  --------------------  package a;  import static a.b.J.foo; public interface I { 	static int call() { 		return foo(); 	} }  --------------------  Invocation of foo() is rejected with the following error but should not be:       This static method of interface J can only be accessed as J.foo"
Preparing to speak about JSR 308 at ECE I see that "Add implemented methods" nicely copies old annotations, but ignores type annotations.  While the implementation looks straight-forward, I'm not sure what's the plan regarding ASTProvider.SHARED_AST_LEVEL. Is it still at JLS4 because some operations are still used that only exist below JLS8?
org.eclipse.jdt.internal.corext.dom.Bindings.containsTypeVariables(ITypeBinding type)  This method consists of 6 if statements in a row. The 1st and 5th if statement are the same. Therefore the 5th one is never going to get executed because the first on returns.
BETA_JAVA8  package pack; import java.io.Serializable; import java.util.List; class C {     void foo(List<Integer> l) {         Integer i = (Integer & Serializable) l.get(0);     } }  On "l.get(0)", I get a wrong compile error: "The type Integer & Serializable is not visible".
"!ENTRY org.eclipse.jdt.core 4 4 2013-10-24 16:35:49.414 !MESSAGE Exception occurred during problem detection: ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr308.myex;  import java.io.Serializable; import java.util.List;  class En {     void foo(Object o) {         Integer i = (Integer & Serializable) o;         List<@NonNull Integer> l;     } }  ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:269) 	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:299) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:349) 	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:266) 	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:951) 	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:894) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveAnnotations(TypeReference.java:588) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:495) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:546) 	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument(TypeReference.java:554) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:238) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146) 	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:359) 	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:191) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620) 	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303) 	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209) 	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319) 	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:568) 	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920) 	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196) 	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195) 	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258) 	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521) 	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170) 	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89) 	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) 	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) 	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) 	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) 	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) 	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) 	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104) 	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) 	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
"BETA_JAVA8  Bad AST recovery with a type annotation in a ParameterizedType and an unrelated syntax error in a secondary type.  The method En#bar() is missing a ; or a {}. This syntax error in the secondary class apparently turns the @NonNull annotation into a modifier of the FieldDeclaration for MyExamples#list2.   !ENTRY org.eclipse.jdt.core 4 4 2013-10-24 21:18:29.919 !MESSAGE Bad AST node structure: - parent [52, 80] org.eclipse.jdt.core.dom.FieldDeclaration    previous [57, 65] org.eclipse.jdt.core.dom.MarkerAnnotation    type [52, 73] org.eclipse.jdt.core.dom.ParameterizedType  ----------------------------------- SOURCE BEGIN ------------------------------------- package jsr308.myex;  public class MyExamples { 	List<@NonNull String> list2; } class En {     void bar()     void foo() { } }   ----------------------------------- SOURCE END ------------------------------------- !STACK 0 java.lang.IllegalStateException: Bad AST node structure 	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)"
Missing: org.eclipse.jdt.core.tests.dom,
BETA_JAVA8  AST#newArrayType(Type, int) should allow to create zero-dimension arrays. Otherwise, a client who already has Dimension nodes has to remove the auto-created first dimension.
Caused by fix for bug 416911.  Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131026-1500"; singleton:="true""  org.eclipse.test.EclipseTestRunner$TestFailedException: Class not found "org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity="org.eclipse.jdt.apt.tests"; type="osgi.bundle"; version:Version="3.3.401.N20131026-1500"; singleton:="true"" at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:582) at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:521) at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308) at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36) at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32) at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) at org.eclipse.core.launcher.Main.main(Main.java:34)
"BETA_JAVA8:  The following program generates an AIOOB exception:  // -- import java.util.Arrays;  public class X { 	public static void main(String [] args) { 		Integer [] array = new Integer[10]; 		Arrays.sort(array, Integer::compare);  	} }"
BETA_JAVA8  For JLS8, the ASTParser gives up on multi-dimensional array references in a MethodRefParameter and leaves the whole Javadoc node without any children. Still Works fine for JLS4.  /**  * Hello.  * @see #foo(Object[][][])  */